{"articles":{"tree shaking (patterns.dev)":{"id":90,"title":"트리 쉐이킹 번역 글","content":"# Tree Shaking (트리 쉐이킹)\n\n## Reduce the bundle size by eliminating dead code (데드 코드를 제거하여 번들사이즈를 줄이기)\n\n> 이 글의 원글은 https://www.patterns.dev/posts/tree-shaking/ 이며, 번역 글입니다\n\n가끔 우리는 어디에도 우리 앱에서 쓰이지 않는 코드를 작성하기도 한다. 죽은 코드 조각들은 번들 사이즈를 줄이기와 불필요하게 더 많은 데이터를 적재하는 것을 막기 위해서 제거될 수 있다! 우리의 번들에 넣기 전에 데드 코드를 제거하는 프로세스를 tree-shaking (트리 쉐이킹)이라고 한다.\n\n트리 쉐이킹은 `math`와 같은 간단한 모듈들에서 동작하기도 하지만, 트리 쉐이킹이 꽤나 까다로운 케이스들도 있다.\n\n### Concepts\n\n트리 쉐이킹은 최종 자바스크립트 번들에서 쓰이지 않는 코드를 제거하는데 목적을 갖고 있다. 올바르게 작업이 된다면, 자바 스크립트 번들의 사이즈를 줄일 수 있고, 더 가볍게 다운로드 할수 있으며 파싱과 실행 시간을 줄일 수 있다. 모듈 번들러 (웹팩이나 롤업과 같은)를 사용하는 모던 자바스크립트 앱들을 위해서, 번들러들은 자동으로 당신의 예상대로 죽은 코드를 없앤다.\n\n당신의 어플리케이션과 그것의 추상적인 신택스 트리 디펜던시들을 고려해 보라. (우리는 그 신택스 트리를 최적화 하기위해서 \"shake\" 하고 싶다.) 트리 내부의 각각의 노드는 당신의 앱을 기능하게 하는 디펜던시들 이다. 트리쉐이킹에서, input file들은 그래프로 취급된다. 각 그래프의 각각의 노드는 코드의 \"part\"라고 불리는 최상위 레벨의 상태이다. 트리쉐이킹은 순환하는 그래프이다. 엔트리포인트 부터 시작하여 포함하는 어떤 것들을 경로에 따라 모두 순회한다.\n\n모든 컴포넌트는 심볼, 심볼 레퍼런스를 선언할수 있고 다른 파일들에 의존적이다. \"parts\"가 사이드이펙트를 가지고 있다고 표시되어 있든 아니든간에 말이다. 예를 들면, `let firstName = 'Jane'`이라는 선언은 사이드이펙트가 없다. 왜냐면 저 선언은 만약 어떤데에서도 firstName을 쓰지 않는다면 제거될수 있기 때문이다. `let firstName = getName()`이라는 선언은 사이드이펙트를 가지고 있다. 왜냐하면 `getName()`이라는 함수는 지워질수 없기때문이다. 만약 아무도 firstName이라는 변수를 쓰지 않아도 말이다.\n\n### Imports\nES2015 모듈 신택스(`import`와 `export`)를 따라서 선언된 모듈들만이 트리쉐이킹을 할 수 있다. 당신이 모듈을 임포트하는 방식이 그 모듈이 트리쉐이킹 할수 있는지 여부를 나타낸다.\n\n트리쉐이킹은 사이드 이펙트와 함께 엔트리 포인트의 모든 파트들을 거치면서 시작된다. 그리고 새로운 섹션에 도달할때 까지 그래프의 가장자리들까지 순회한다. 순회가 완료된다면, 자바스크립트 번들은 순회가 이루어지는 동안에 도달한 부분들만 포함한다. 그 외의 조각들은 포함되지 않는다. 다음과 같은 `utilities.js`라는 파일을 만들었다고 해보자:\n\n```js\nexport function read(props) {⁣⁣\n    return props.book⁣⁣\n}⁣⁣\n⁣⁣\nexport function nap(props) {⁣⁣\n    return props.winks⁣⁣\n}\n```\n\n그리고 다음과 같은 index.js 파일이 있다:\n\n```js\nimport { read } from 'utilities';⁣⁣\n⁣⁣\neventHandler = (e) => {⁣⁣\n    read({ book: e.target.value })⁣⁣\n}\n```\n\n예시에서, `nap()`은 중요하지 않다. 그러므로 번들에 포함되지 않는다.\n\n### Side Effects\n\n우리가 ES6 모듈들을 임포트 할때, 이 모듈은 즉시 실행된다. 우리가 어디에서도 모듈의 exports들을 코드에서 언급하진 않더라도, 모듈 자체가 실행될때 글로벌 스코프에 영향을 미치면서 발생 할수 있다. (polyfill 혹은 global stylesheets 같은 것들) 우리는 이것을 사이드 이펙트 (side effect)라고 부른다. 모듈 자체의 exports를 언급하지 않더라도, 만약 모듈이 시작과 함께 값들을 exports 한다고 하면, 모듈은 트리쉐이킹 될 수 없다. 그것이 import될때에 특정한 행동 동안에는 말이다.\n\nWebpack 다큐먼트가 [트리 쉐이킹의 명확한 설명](https://webpack.js.org/guides/tree-shaking/#clarifying-tree-shaking-and-sideeffects)을 해준다. 그리고 어떻게 트리쉐이킹을 잘하게 만드는지도 알려준다.\n\n\n\n\n\n\n\n\n\n","thumbnail":"js.png","excerpt":"tree shaking (patterns.dev)","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-11-27T11:26:37.217Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[{"blogArticleTag":{"name":"tree shaking"}},{"blogArticleTag":{"name":"트리 쉐이킹"}},{"blogArticleTag":{"name":"patterns.dev"}}]},"생활과건강 - 10강. 스트레스의 이해와 관리":{"id":91,"title":"생활과건강 - 10강. 스트레스의 이해와 관리","content":"# 생활과건강 - 10강. 스트레스의 이해와 관리\n\n## 1. 스트레스의 이해\n* 반응으로서의 스트레스\n\t* 기전\n    \t* 시상 하부\n        * 자율 신경계\n        * 내분비계\n        \t* 뇌하수체\n\t* 투쟁-도피 반응\n    \t* 캐넌\n        \t* 스트레스가 질병의 원인이 될 수 있음을 밝혀냄\n            * 항상성 장애\n            * 에피네프린, 노르에피네프린, 코르티솔 등 혈액 내로 유리\n            * 생존에 필요한 에너지 위해 간에 저장된 당 혈액 내로 유리\n            * 소화 느려짐 (혈류가 소화기 계통에서 근육과 뇌로 집중)\n\t* 정신면역학\n    \t* T세포 증식 감소\n        * 시상하부-뇌하수체-부신피질 축이 중요한 역할\n        * 코르티솔의 증가 -> 림프구 수와 기능 저하 등 면역체계 방해\n     * 셀리\n     \t* 내 외적 환경으로부터 생명유지에 필요한 균형을 유지하기 위해 나타나는 비특이적 반응\n        * 일반 적응 증후군 (GAS: general adaption syndrome)\n        * 스트레스 요인이 지각됐을때 일어나는 반응\n        * 경고 반응단계\n        * 저항단계\n        * 소진단계\n\t* 적응 반응\n    \t* 지속적인 스트레스가 유발할 수 있는 증상\n        * 고혈압, 협심증, 심근경색\n        * 스트레스 -> 뇌의 신경전달 물질, 신경 호르몬에 영향 -> 정신적 반응 유발\n* 자극으로서의 스트레스\n\t* 부정적 스트레스\n    \t* 주로 괴로움과 고통을 주는 스트레스\n\t* 긍정적 스트레스\n    \t* 삶의 활력소가 되고 행복감을 줌\n\t* 스트레스 생활 사건\n    \t* 스트레스 요인\n        * 생명을 위협하는 정도의 건강 문제, 죽음, 사회 활동이나 인간관계에서의 크고작은 일상적 사건 등\n        * 홈즈와 라헤\n        \t* 스트레스 정도가 건강 변화 가능성, 질병의 경과나 중증도에 영향\n            * 생활변화에 따른 적응 요구도 높은 사람들 주목\n\t* 개인 내적 요소\n    \t* 신체적 요인\n        * 성격적 요인\n        * 개인이 지니 비현실적인 동기\n        * 비합리적인 믿음, 비합리적인 인지전략 등\n* 인간-환경 상호작용으로서의 스트레스\n\t* 라자루스와 포크만\n    \t* 개인이 가진 자원의 한계를 초과하여 안녕을 위협하는 것으로 개인에게 평가되는 것\n        * 인지적 평가\n        \t* 1차적 평가\n            * 2차적 평가\n            * 재평가의 단계\n\n## 2. 스트레스 측정\n* 스트레스 인식 일지\n* 스트레스 취약성 검사\n\t* 스트레스에 저항할 수 있는 개인의 능력을 평가\n\n## 3. 스트레스 관리\n* 스트레스 정도를 최소화 할 수 있는 관리 차원에 초점\n* 라자루스와 포크만의 인간-환경 상호교류 모형을 토대\n* 환경 관리 전략\n\t* 생활양식이나 일반적인 환경을 변화\n\t* 과잉 부담을 일으키는 요인 시정하고 대처\n* 자기 관리 전략\n\t* 인지의 변화\n    * 인지행동이론\n    \t* 효과적인 새로운 전략과 행동 학습, 인지적 재구성을 통해 역기능적인 가치, 신념, 가정 등 변화\n        * 스트레스 상황 재평가\n\t* 자존감 증진\n    \t* 자신이 스스로에게 부여하는 가치\n        * 자신의 강점, 긍정적 특성 집중\n        * 긍정적인 말로 자신을 표현\n\t\t* 자기주장 훈련\n\t* 생각의 중단\n    \t* 강박적인 한가지 생각에 몰두하는 강박적 사고과정에 대한 효과적인 처리 방법\n\t* 비합리적인 신념 논박\n    * 세상(대상)을 보는 관점\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 10강. 스트레스의 이해와 관리","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-30T08:26:35.399Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"소프트웨어공학 - 7강. 소프트웨어 설계":{"id":92,"title":"소프트웨어공학 - 7강. 소프트웨어 설계","content":"# 소프트웨어공학 - 7강. 소프트웨어 설계\n\n## 설계\n* 물건을 만들기 위한 계획 또는 제작을 위해 물건을 의미있게 표현\n\n\n## 설계 프로세스\n* 설계 작업의 입력\n    * 요구사항과 분석 모델\n    * 환경적 제약 사항\n* 설계 작업의 결과물\n* 반복 수행하면서 점점 정형화\n\n## 설계 프로세스\n* 요구사항 명세\n* 데이터베이스 설계\n* 서브 시스템 설계\n* 컴포넌트 설계\n* 자료구조 / 알고리즘 설계\n\n## 설계 원리\n* 분할 후 정복\n\t* 문제를 작은 것들로 나누고 각각을 독립적으로 정복\n    * 수평 분할\n    * 수직 분할\n* 추상화\n\t* 내부의 상세한 내용을 생략\n    * 외부 행위만을 기술하는 것\n    * 추상화의 적용\n    \t* 시스템 설계에서 구성 모듈들을 추상화하여 표현\n\t* 기능 추상화\n    * 데이터 추상화\n* 하향식과 상향식 설계\n\t* 하향식 설계\n    \t* 낮은 수준의 컴포넌트들로 분해하는 것\n        * 단계적 정제\n\t* 상향식 설계\n    \t* 가장 기본적인 컴포넌트 설계\n        * 상위 수준의 컴포넌트 설계\n\t* 고려사항\n    \t* 새로 개발하는 작업에는 하향시이 적합\n        * 기존 컴포넌트 조합하여 개발하는 경우에는 상향식이 적합\n\n## 아키텍쳐 설계와 중요성\n* 아키텍쳐 설계\n\t* 시스템 품질 특성과 제약사항을 반영해야 함\n    * 아키텍쳐의 중요성\n    \t* 개발이 진행된 후에는 시스템 구조 수정하기 어려움\n* 아키텍쳐 스타일\n\t* 유사한 애플리케이션들에서 사용되는 공통적인 아키텍쳐 패턴\n    * 아키텍쳐 설계의 초안이 됨\n* 데이터 중심 아키텍쳐\n\t* 저장소 모델\n* 데이터 흐름 아키텍쳐\n\t* 파이프 필터 구조\n    * 데이터 요소들에 대한 개별 변환 작업들을 연결하여 시스템을 구성\n* 클라이언트 - 서버 아키텍쳐\n\t* 분산 시스템의 아키텍쳐\n    * 서버와 클라이언트는 네트워크로 연결됨\n    * 데이터 처리가 분산됨\n    * 새로운 서버 추가하기 쉬움\n    * 모든 서버가 각각 데이터 관리 책임을 가짐\n    * 공유 데이터 모델이 없으므로 데이터 교환이 비효율적\n* 계층형 아키텍쳐\n\t* 추상 기계 모델\n    * 시스템을 계층별로 구성\n    * 하위 계층이 제공하는 서비스를 상위 계층이 이용\n    * OSI 7 계층\n    * 각 계층은 특정 서비스를 제공\n    * 서브 시스템 간의 점증적 개발이 가능\n* MVC 아키텍쳐\n\t* 모델 (M), 뷰 (V), 컨트롤러 (C)로 분리\n\n## 아키텍쳐와 비기능적 속성\n* 소프트웨어 아키텍쳐는 비기능적 요구사항에 영향을 줌\n* 비기능적 속성을 고려하여 설계해야 함\n\t* 성능: 서브시스템들 간의 통신을 최소화\n    * 보안: 계층형 아키텍쳐를 사용하고 보안이 중요한 시스템을 내부 계층에 위치시킴\n    * 안전성: 안전성이 요구되는 요소들을 하나의 서브시스템에 집중시킴\n    * 가용성: 동일 기능의 컴포넌트를 중복시킴\n    * 유지보수성: 자료의 공유를 피하고 모듈화 시켜야 함\n\n## 구조적 설계\n* 구조적 분석(SA)의 결과물을 이용해 아키텍쳐를 설계하고 모듈을 개발하는 방법\n* 구조도\n\t* 모듈들의 계층 구조, 모듈의 매개변수, 모듈들 간의 상호 연결 관계를 보여줌\n    * 모듈들은 블랙박스로 표현되며 계층적으로 배열됨\n* 변환 분석에 의한 구조적 설계\n\t* 데이터 흐름의 유형이 변환 흐름인 경우 사용\n    * 변환 흐름은 데이터를 입력받고, 변환 가공하고 결과를 출력하는 유형\n    * 변환 분석\n    \t* 데이터흐름도에서 입력 흐름과 출력 흐름의 경계를 표시\n        * 구조도에 입력, 변환, 출력 모듈을 제어하는 모듈을 추가로 만듦\n\n## 트랜잭션 분석에 의한 구조적 설계\n* 트랜잭션 흐름은 한 프로세스에서 입력을 여러 경로의 데이터 흐름으로 유출하는 유형\n* 트랜잭션 분석\n* 상세 설계\n* 모듈화\n\t* 구성 요소들이 기능적으로 독립적이어서 이해하기 쉬움\n    * 테스트 디버깅 유지보수 작업이 쉬움\n    * 재사용하기 용이함\n* 모듈의 독립성\n\t* 다른 모듈과의 결합도가 느슨해야 함\n    * 하나의 모듈은 높은 응집력을 가져야 함\n* 결합도\n\t* 두 모듈 사이의 상호 의존성 정도를 의미\n    * 두 모듈을 연결하는 인터페이스의 복잡도에 좌우됨\n* 결합도의 수준\n\t* 데이터 결합\n    * 스탬프 결합\n    * 제어 결합\n    * 공통 결합\n    * 내용 결합\n* 응집력\n\t* 하나의 모듈이 가지는 기능적 집중성에 관한 척도\n    \t* 모듈을 구성하는 요소들이 기능적으로 얼마나 관련성이 있는가\n\t* 응집력의 수준\n    \t* 기능적 응집력\n        * 순차적 응집력\n        * 통신 응집력\n        * 절차적 응집력\n        * 시간적 응집력\n        * 논리적 응집력\n        * 우연적 응집력\n        \n## SOLID 원칙\n* 단일 책임 원칙\n\t* 모든 클래스는 하나의 책임만 가져야 한다\n    \t* 유일한 이유로만 변경 될 수 있다\n* 개방 폐쇄의 원칙\n\t* 클래스가 확장에는 열려 있고, 수정에는 닫혀 있어야 한다\n    * 새로운 기능을 추가하면서도 기존 코드를 수정하지 않아도 된다\n* 리스코프 교체의 원칙 (LSP)\n\t* 프로그램에 존재하는 부모 유형(T)의 객체를 자식 유형(S)의 객체로 교체할 수 있어야 함\n    * T와 S간 상속관계가 적절해야 한다는 의미\n    * LSP가 만족되면 새로운 자식 클래스를 추가할 때 기존 코드의 수정이 필요 없음\n    * 자식 클래스에서 부모 클래스의 메소드를 재정의 하지 않으면 LSP의 문제가 없음\n* 인터페이스 분리의 원칙 (ISP)\n\t* 하나의 큰 범용 인터페이스가 아닌 작고 특화된 여러 인터페이스로 나누어 설계 할 것\n    * ISP를 만족하지 못한다면 사용하지 않는 인터페이스가 바뀔 때도 클라이언트에게 소프트웨어를 재배포 해야 함\n    * 복합기 인터페이스 대신에 프린팅, 복사, 스캔 인터페이스로 나눌 것\n* 의존 관계 역전의 원칙 (DIP)\n\t* 구체적 저수준 사물(구체 클래스)이 아닌 추상적 고수준 개념(인터페이스)에 의존해야 함\n    * 실제 작업을 수행하는 저수준 구체 클래스는 변경되기 쉬움\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"소프트웨어공학 - 7강. 소프트웨어 설계","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-28T07:33:38.965Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"생활과건강 - 11강. 우울증의 이해와 관리":{"id":93,"title":"생활과건강 - 11강. 우울증의 이해와 관리","content":"# 생활과건강 - 11강. 우울증의 이해와 관리\n\n## 1. 우울증의 이해\n* 전반적인 정신기능이 저하된 상태\n* DSM-5의 우울장애 (depressive disorders)에 해당\n\t* 주요 우울장애\n    * 지속성 우울장애\n    * 파괴적 기분조절부전장애\n    * 월경전불쾌감장애\n* 지속성 우울장애\n* 파괴적 기분조절부전장애\n\t* 만성적으로 고도의 지속적인 과민성\n    * 아동이나 청소년에게 흔히 발생\n* 월결전 불쾌감장애\n\t* 반복적으로 월경주기 전에 시작 & 월경 시작 or 직후에 사라짐\n    * 현저한 고통, 심각한 일상생활 기능 저해\n* 우울증의 특징적 양상\n\t* 울병 (melancholia)\n    * 갱년기 우울증 (involutional depression)\n    * 산후우울\n    * 산후우울증\n    * 계절성 우울증\n* 연령에 따른 우울증의 특징적 양상\n\t* 아동 및 청소년\n    * 중년\n    * 노인\n\n## 2. 우울증의 원인\n* 정신사회적 요인\n\t* 상시에 대한 애도과정이 지연 또는 왜곡\n    * 대상의 상실 경험\n    * 분노나 공격성이 자기 자신에게 향함으로써 발생\n    * 학습된 무기력\n* 우울증이 발생하기 쉬운 성격유형\n* 상실로 인한 스트레스\n* 여성의 역할변화로 인한 역할 갈등\n* 우울증의 평생 유병률: 여성 > 남성 (약 2~3배 높음)\n* 생물학적 요인\n\t* 유전적 영향\n    * 신경해부학적 이상\n    * 생화학적 영향\n* 약물 및 신체질환\n\n## 3. 우울증의 관리\n* 급성기, 지속기, 유지기의 각 치료단계에 따른 목표\n* 급성치료 단계\n\t* 약 6-12 주\n* 지속치료 단계\n\t* 증상 완화 후 처음 4-6개월 간은 재발 위험성이 높아 증상 재발 예방 및 회복촉진이 치료 목표\n* 유지치료 단계\n\t* 재발 및 새로운 에피소드로 인한 질병의 순환 예방이 치료 목표\n    * 약 1-5년 지속적인 약물 치료 필요\n* 약물치료\n\t* 급성 증상 완화 제거\n    * 충분한 용량을 충분한 기간 동안 사용\n* 심리, 사회, 신체적 치료\n\t* 우울증 환자의 억압된 분노 표현\n    * 무의식을 이해\n    * 자아를 지지\n    * 왜곡된 인지나 대인관계 등 교정\n\t* 심리적 정서적 지지\n\t* 신체적 건강과 안전\n    \t* 영양, 위생, 수면, 안전\n\t* 자존감 강화\n    * 감정 표현하기\n    * 환경적 관리\n    * 안녕감 회복 및 증진하기\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 11강. 우울증의 이해와 관리","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-06-01T05:17:44.461Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"생활과건강 - 8강. 건강한 생활습관(2)":{"id":94,"title":"생활과건강 - 8강. 건강한 생활습관(2)","content":"# 생활과건강 - 8강. 건강한 생활습관(2)\n\n## 1. 건강한 생활습관의 실천\n* 만성질환의 예방과 관리문제\n* 보건 의료 비용의 부담과 사망률 증가\n* 건강한 생활습관 실천이 매우 중요\n* 당뇨, 만성 신부전, 고혈압, 뇌졸중, 협심증, 심근경색\n* 만성 질환의 예방과 관리\n\t* 고혈압, 고혈당 \n    * 복부비만, 고중성 지방혈증, 저HDL콜레스테롤\n\t* 성별차이가 뚜렷이 드러남\n    * 대사 증후군을 예방하고 관리하려면 개인의 적극적인 실천의지가 있어야 함\n* 생활습관 개선\n\t* 대사증후군의 원인\n    \t* 비만, 인슐린 저항성\n        * 체중 감소\n* 식사와 영양\n\t* 지방섭취량 조절\n    * 전체 지방 섭취량 중 포화 지방산은 10% 이하\n    * 콜레스테롤은 하루 300mg 이하로 제한\n    * 염분 섭취 제한하기 위해 소금은 하루 6g 이하, 나트륨은 하루 2.4g 미만을 섭취\n* 흡연시 발생하는 일산화 탄소가 호흡을 통해 몸으로 들어오면 헤모글로빈과 결합\n* 그 결합력이 산소에 비해 400배가 크기 때문에 혈액내에 산소가 매우 부족\n* 이로인해 혈관 수축, 혈관 내벽의 세포 손상, 동맥경화 등과 더불어 혈액순환 장애를 초래\n* 칼로리 섭취 억제\n* 체중감량\n\t* 대사 증후군에서 인슐린 저항성 개선을 위해 가장 중요\n* 체중 감소\n\t* 인슐린 저항성, 이상지질혈증, 고요산 혈증 등 완화\n* 혈당지수가 높은 음식 자제\n\t* 혈당 지수: 당분이 흡수되는 속도에 따른 혈당 수치\n    * 혈당지수가 높은 음식은 혈당을 빨리 증가시켜 인슐린 분비와 저항성을 높이고\n    * 대사 증후군을 일으킴\n* 포만감이 높은 음식을 먹는다\n* 비타민 미네랄 단백질 섭취\n\t* 영양소기 장에서 흡수되어 이용되는 대사과정에는 반드시 비타민, 미네랄 필요\n    * 칼륨, 마그네슘: 혈압을 낮추어 고혈압 예방\n    * 칼슘: 체중 감량, 인슐린 저항성 개선에 도움\n    * 비타민 B, E, 엽산 등: 심혈관 질환 감소에 도움\n    * 단백질\n* 채소와 섬유소 많이 섭취\n* 가능한 한 싱겁게 먹는다\n* 고지혈증 환자는 식사에 주의\n* 운동 요법\n\t* 체중감소, 복부비만 감소, 인슐린 저항성 개선에 매우 중요\n    * 열량 소모를 통해서 나타나는데 큰 근육 사용, 장기간 유지하는 것이 효과적\n    * 일주일에 700칼로리를 소모할수 있는 운동\n    * 주당 2000칼로리를 사용하는 운동이 도움됨\n\n## 2. 지역사회 건강증진 프로그램\n* 치료중심에서 예방중심으로 전환\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 8강. 건강한 생활습관(2)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-30T02:23:15.764Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"match 에서 duplicate profiles 오류가 뜰 때에 해결법":{"id":95,"title":"Fastlane iOS - match 에서 duplicate profiles 오류가 뜰 때에 해결법","content":"# Fastlane iOS - match 에서 duplicate profiles 오류가 뜰 때에 해결법\n\n회사에서 fastlane 으로 iOS 빌드 자동화를 할 일이 생겨서 전체적으로 쭉 들여다 보는 와중에 해결하기 참 애매한 상황을 맞닥뜨렸다.\n\n`match`를 이용하여 codesign에 필요한 certificate 및 profile들을 관리하는 레포와 연동을 해야 하는데, 다음과 같은 에러가 뜬 것 이다.\n\n\n![에러사진.png](/uploads/1659405247751.png)\n\n\n```bash\nmultiple profiles found with the name match 'match AppStore xxx.xxx.xxx'. Please remove the duplicate profiles and try again\n```\n\n말 그대로 `match AppStore xxx.xxx.xxx`이라는 name을 가진 profile이 존재 하고 있다는 것이다.\n정확히는 모르겠지만, profile name이 하나의 unique key가 되어 profile을 구분하는 구분자로 사용되는 것 같았다.\n\n따라서 이 오류를 해결 하기 위해선, 다음과 같은 두가지 방안이 떠올랐다.\n\n1. 이미 만들어져 있는 동일한 이름의 프로필을 `match nuke`를 사용하여 없애거나 직접 developer portal에 들어가서 삭제한다\n2. 1번의 방법이 안되면, cert와 sigh를 사용하여 우회한다\n\n결론부터 말하자면 위 방법 모두 해결책이 되진 못했다.\n\n이유는 다음과 같다.\n1번의 경우 회사의 apple developer 계정으로 apple developer portal에 접속해도, `match AppStore xxx.xxx.xxx`와 같은 이름의 profile은 찾아 볼 수 없었다.\n오리무중 이었다. 도저히 아무리 찾아봐도 우리가 관리하는 프로필에는 저런 이름을 가진 것이 없었다.\n\n2번으로 어떻게 해보려고 했지만, github action에서 돌려야 해서 현실적인 부분에 부딪혔던 것 같다.\n\n이렇게 삽질을 하던 도중, match를 사용하여 custom profile name을 주어서 굳이 `match AppStore xxx.xxx.xxx`와 같은 이름의 profile을 만들지 않아도 되는 방식을 알아냈다.\n\n이 방식을 소개하려고 한다.\n나는 fastlane cli 명령어를 사용하진 않았고, Fastfile에 custom 한 lane을 만들어서 실행했다.\n\n## 1. 먼저 필요하다면 기존 profile을 삭제하는 match nuke를 실행한다\n\n```ruby\nmatch_nuke(\n\ttype: \"appstore\",\n\tapi_key: app_store_connect_api_key, # fastlane action 중 app_store_connect_api_key를 사용하여 받아온다.\n\tusername: \"apple developer account email\", # 이쪽에서는 apple developer account email을 입력\n\tapp_identifier: \"bundle id\", # app bundle id 입력\n\tprofile_name: \"match AppStore xxx.xxx.xxx\" # optional (nuke할 profile의 name을 입력)\n)\n```\n\n## 2. 실제 apple developer portal 에 profile을 만든다\n```ruby\nget_provisioning_profile(\n\tdevelopment: false,\n\tforce: true,\n\tteam_id: \"apple developer team id\", # apple developer team의 id를 입력\n\tfilename: \"xxxxxx.mobileprovision\", # .mobileprovision이라는 확장자로 끝나는 파일 이름을 입력\n\tprovisioning_name: \"custom AppStore xxx.xxx.xxx\" # 커스텀하게 만들 provisioning의 이름을 입력\n)\n```\n만약 developer portal에 들어가서 profiles 탭에서 만들어진 profile의 상세를 눌러서 edit을 눌러보았을때, 하단의 certificates 옵션이 ios distribution으로 잡혀있다면 xcode와 모두 연동이 가능한 distribution으로 바꾸어준다.\n\n## 3. match (readonly false)를 통해서 provisioning을 GitHub repo 에 연동시켜준다\n```ruby\nmatch(\n\tgit_url: \"https://github.com/user-name/repo-name\", # certificate을 관리하는 github repo의 url을 입력\n\tstorage_mode: \"git\",\n\ttype: 'appstore',\n\tapp_identifier: \"xxx.xxx.xxx\", # app bundle id 입력\n\treadonly: false, # readonly 를 false로 해줌으로써 repo와 연동할수 있게 함\n\tverbose: true,\n\tapi_key: app_store_connect_api_key, # app store connect api key\n\tprofile_name: \"custom AppStore xxx.xxx.xxx\" # 특정 커스텀하게 만든 프로필의 이름을 입력, 이 provisioning이 repo와 연동되게 됨\n)\n```\n\n이렇게 하면 실제 repo와 연동하여 굳이 match가 정해준 이름이 아니더라도 커스텀한 이름을 사용할 수 있다.\n\n","thumbnail":"fastlane.png","excerpt":"match 에서 duplicate profiles 오류가 뜰 때에 해결법","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-07-31T04:52:15.831Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"일상이 바뀌었다":{"id":96,"title":"새로운 삶으로의 적응기","content":"# 새로운 삶으로의 적응기\n\n새로운 곳으로 직장을 옮겼다.\n출근을 안하다 다시 하려니 뭔가 피곤하기도 하다.\n\n요즘, 즉 5월 한달을 돌아보면 생산적이기 보다는 소비적이었다.\n점점 나를 잃어가는 기분이 들긴 했지만, 피곤해서 나 자체에 크게 신경을 못 쓴 것 같다.\n\n나에게 좀 더 시간을 투자 하기는 힘들었지만 그래도 별일 없이 지나간 것에 만족을 하련다.\n앞으로는 조금 더 생산적일 필요가 있다.\n\n무튼 그래도 나빴으면 경험이고 좋았으면 추억이라는 말이 있듯이,\n5월 한달 간 새로운 것을 느끼고 경험하고 많은 것을 배운 시간이었다.\n\n일상이란 것은 참 중요하다.\n조금의 일상만 달라져도 나에게는 큰 변화로 느껴진다.\n비단 나 뿐만이 아니라 다른 모든 사람들도 비슷하리라고 믿는다.\n\n5월 한달은 나에게 `일상의 변화`였다고 표현 할 수 있겠다.\n새로이 변화된 일상에 적응 하면서 좀 부딪히기도 하고 완벽하진 못했지만,\n새로운 것을 배우는 마음으로 살았 던 것 같다.\n\n그래도 5월을 큰 문제 없이 마무리 지어서 다행이라고 생각한다.\n앞으로는 조금더 생산적이고 조심스러운 삶을 추구해야 할 것 같다.\n삶에서도 너무 많은 과소비는 좋지 않다.\n\n많은 것을 느끼고 깨달은 한 달 이었다.\n큰 탈 없이 넘어가는 것에 감사의 마음을 갖는다.\n\n모두 고맙습니다. 나에게도 내 주변의 사람들에게도.","thumbnail":"ocean.png","excerpt":"일상이 바뀌었다","blogArticleCategoryId":5,"isPublic":true,"createdAt":"2022-05-28T09:02:08.898Z","deletedAt":null,"blogArticleCategory":{"name":"life"},"blogArticleTags":[]},"생활과건강 - 6강. 신체건강 문제와 관리(5)":{"id":97,"title":"생활과건강 - 6강. 신체건강 문제와 관리(5)","content":"# 생활과건강 - 6강. 신체건강 문제와 관리(5)\n## 비뇨기계 해부 생리\n* 신장\n\t* 후복벽의 복막 뒤에 좌우 1개씩 위치, 강낭콩 모양과 유사한 기관\n    * 신장의 기능 단위\n    \t* 네프론, 한쪽 신장에는 100만 ~ 125만개의 네프론이 있음\n* 신장의 기능\n\t* 이온농도 조절\n    * 독성물질을 체외로 배출\n    * 적혈구 생성 관여(조혈기능)\n    * 여러 호르몬 대사에 관여\n* 요관, 방광 및 요도\n\t* 요관: 신장에서 생성된 소변은 요관을 통해 방광으로 운반\n    * 방광\n    \t* 주머니 모양의 근육으로 된 기관, 소변을 저장했다가 주기적으로 체외로 배출시키는 역할\n        * 성인의 경우 방광에 소변이 250 ~ 450 cc 가 찼을때 느낌\n\t* 요도\n    \t* 수의적으로 외괄약근을 이완시키면 배뇨가 이루어짐\n* 요로 결석\n\t* 신장, 요관, 방광, 요도 등 요로에 결석이 생겨서 배뇨장애 초래\n    * 격심한 통증이 발생하거나 요로 감염, 신부전 등이 나타나는 질환\n\t* 원인\n    \t* 수분섭취 감소: 요석결정이 소변에 머무르는 시간이 길어져 요석 형성 증가\n        * 유전적 요인\n        * 남성이 3배이상 발생위험이 높다\n        * 온도와 계절은 요로결석 발생에 중요한 요인으로 작용\n\t* 증상\n    \t* 갑작스럽고 극심한 옆구리 통증 유발 (응급치료를 요하는 경우 많음)\n        * 통증이 심한 경우 오심, 구토, 복부 팽만, 혈뇨 등 유발\n\t* 진단\n    \t* 방사선 검사\n\t* 관리\n    \t* 대기 요법\n        \t* 요로결석의 자연 배출을 기다리는 방법\n            * 검사결과 크기가 작고 하부요관에 위치한 경우에는 자연배출을 기대할수 있음\n\t\t* 체외 충격파 쇄석술\n        \t* 수술없이 몸밖에서 충격파를 발사하여 결석을 잘게 분쇄하여 자연배출이 되도록 유도하는 치료법\n\t\t* 요관경하배석술\n        \t* 요관을 통해 내시경을 통과시켜 결석을 분쇄 혹은 제거하는 시술 방법\n* 전립성 비대증\n\t* 전립선이 비대해져 전립선을 통과하는 요도를 압박하여 소변이 시원하게 나오지 않고 소변의 속도가 감소하는 증상\n   \t* 증상\n    \t* 빈뇨, 지연뇨\n\t* 예방 및 관리\n    \t* 약물요법\n        * 규칙적인 생활, 충분한 휴식      \n\n## 암환자 건강 문제\n  * 종양\n      * 양성 종양: 성장속도가 느리고 전이 되지 않아 생명에 큰 위험은 없음\n      * 악성 종양(암): 유전적 변이에 의해 세포가 비정상적으로 변하면서 세포의 성장조절 신호와 무관하게 과다한 증식을 하는 것\n  * 발병기전 및 발암 요인\n      * 1단계 (암유발 개시 단계)\n          * 발암원이 DNA를 공격하여 돌연변이를 유발하는 비가역적 반응\n      * 2단계 (암유발 촉진 단계)\n          * 발암 개시 된 세포에 세포분열을 촉진시키는 암 촉진인자가 작용하는 단계\n      * 3단계 (암진행 단계)\n          * 양성종양에서 악성종양으로 전환하여 악성 종양의 특성이 증가하는 과정으로, 이 단계에서는 암유전자와 암억제 유전자의 돌연변이가 점차 증가하며 염색체 이상이 분명하게 나타남\n      * 가족력\n      * 발암물질을 장기간 섭취할 경우 암발생률이 증가\n      * 호르몬이 불균형하거나 호르몬 요법을 받을 경우 -> 암유발 가능성 있음\n  * 증상\n      * 조기발견이 매우 어려움\n      * 암 초기: 국소적 증상\n      * 암이 전이 되면서 증상이 나타남\n  * 예방\n      * 의학적인 관점에서 암 발생 인구의 1/3은 예방 가능\n      * 생활 습관 변화, 발암물질에 노출을 피하며 조기발견을 위해 건강검진 실시\n* 관리\n\t* 항암화학 요법\n    \t* 수술이 적합하지 않을 때\n\t* 면역요법, 유전자 치료 요법이 새롭게 시도되고 있음\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 6강. 신체건강 문제와 관리(5)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-24T07:32:03.903Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"컴퓨터보안 - 7강. 보안 시스템 I":{"id":98,"title":"컴퓨터보안 - 7강. 보안 시스템 I","content":"# 컴퓨터보안 - 7강. 보안 시스템 I\n\n## 보안 시스템의 개요\n* 침입의 종류와 대응 방식에 따른 분류\n\t* 침입 차단 시스템 (Firewall)\n    * 침입 탐지 시스템 (IDS)\n    * 침입 방지 시스템 (IPS)\n    * 가상 사설망 (VPN)\n* 최근 동향\n\t* 네트워크 접근 제어 (NAC) 기술\n\t* 통합된 형태의 보안 위협 관리 기술 (UTM)\n    * 새로운 서비스에 대한 위협대응 기술\n* 침입 차단 시스템 (방화벽, Firewall)\n\t* 내부 네트워크의 컴퓨터들을 외부로부터 보호하기 위한 보안 정책과 이를 수행 하는 하드웨어 및 소프트 웨어 등\n    * 외부의 공격자나 인증되지 않은 사용자, 혹은 유해한 정보가 내부 네트워크로 진입하지 못하도록 차단해주는 보호정책과 보호장치\n    * 기능\n    \t* 내부 네트워크와 외부 네트워크의 중간 지점에 위치시켜 두 네트워크 사이를 오가는 트래픽의 종류와 양을 제어\n\t* 구성 방식\n    \t* 패킷 필터링 (Packet Filtering)\n        \t* OSI 7 계층 중 3, 4 계층인 네트워크 계층과 전송 계층의 패킷을 필터링하여 내부 네트워크 보안을 설정하는 것\n\t\t\t* 패킷 필터링 라우터에 의해 TCP 포트와 IP 주소 패킷 중 전부 또는 일부를 필터링 할 수 있음\n            * OSI 7 계층의 하위 3, 4계층을 이용하므로 네트워크 제어에 대한 반응 속도가 매우 빠름\n            * 사용자에게 투명한 서비스를 제공\n            * 기존 프로그램과의 연동 유연성\n            * 비용이 적음\n            * TCP/IP 헤더는 구조적인 문제로 조작이 쉬움\n            * 모든 트래픽이 내부 / 외부 네트워크에 직접 연결되어 변형된 정보가 직접적으로 영향을 미침\n            * 패킷 헤더에 있는 목적지 주소, 포트, 소스 등의 정보는 해석하지 않으므로 이런 정보의 조작은 알 수 없음\n            * 로그인과 인증 방식이 강력하지 않음\n            * 트래픽의 접속 제어 방식과 접속량에 따라 방화벽 성능에 큰 영향을 줌\n\t\t* 서킷 게이트웨이 (Circuit Gateway)\n        \t* OSI 7 계층의 5계층에서 7계층까지의 기능을 수행\n            * 내부 네트워크에서 외부 네트워크의 접근을 제어하는 기능을 담당\n\t\t* 애플리케이션 게이트웨이 (Application Gateway)\n        \t* OSI 7계층중 7계층인 애플맄케이션 계층에서 방화벽 기능 수행\n            * 서비스 요청 및 요구된 데이터는 애플리케이션 게이트웨이를 통해서만 전달하는 방식\n            \t* 이러한 과정에서 로그인 정보가 애플리케이션 게이트웨이에 기록되고 제어됨\n\t\t\t* 각 서비스 별로 프록시 서버가 존재할수 있으므로 프록시 게이트웨이 라고도 함\n            * 외부네트워크와 내부네트워크가 직접 연결되지 않고 프록시 서버를 통해서만 연결되므로 패킷 필터링 방식보다 보안설정이 우수\n            * 강력한 로그인, 감시 기능을 가진 인증 시스템\n            * 프록시 서버를 활용하여 확장성이 우수\n            * 응용계층에서 처리하므로 속도가 떨어질 수 있음\n            * 일부 서비스의 투명도가 떨어짐\n            * 프록시의 사용으로 새로운 서비스에 대한 유연성이 부족\n\t\t* 하이브리드 (Hybrid) 방식\n        \t* 패킷 필터링 방식과 애플리케이션 게이트웨이를 혼합한 방식\n            * 빠르고 투명\n            * 보안 설정 수준이 높고 변경이 용이\n            * 보안 설정과 방식을 복합적으로 사용하므로 관리가 어렵고 복잡\n* 침입 차단 시스템 (방화벽)의 구축 형태\n\t* 스크리닝 라우터 (Screening Router)\n    \t* 라우터는 외부 네트워크로 나가는 패킷을 허용하거나 거부할 수 있으며, 내부 네트워크로 들어오는 패킷을 통과시키거나 거부할 수 있음\n    * 베스천 호스트 (Bastion Host)\n    \t* 외부 네트워크와 내부 네트워크를 연결해 주는 통로가 되는 방화벽 호스트\n        * 프록시 서버의 설치, 인증, 로그 등을 담당\n        * 해커 및 불법 침입자의 베스천 호스트의 악용을 철저하게 차단하여야 함\n    * 듀얼 홈 호스트 (Dual-Homed Host)\n    \t* 외부 네트워크와 내부 네트워크가 존재하는 형태로 두 네트워크 간의 유일한 통로를 구축하여 두 인터페이스에 필터링 실시\n    * 스크린 호스트 게이트웨이 (Screened Host Gateway)\n    \t* 스크리닝 라우터와 베스천 호스트 혹은 듀얼 홈 호스트가 결합된 시스템\n        * 스크리닝 라우터를 통해 내부 네트워크로 들어가는 모든 트래픽을 전부 베스천 호스트 혹은 듀얼 홈 호스트에서 보안 적용을 받도록 하는 것\n        * 트래픽을 2단계로 방어하여 안전성이 우수\n        * 라우팅 테이블이 변경되면 방어 할 수 없음\n    * 스크린 서브넷 게이트웨이 (Screened Subnet Gateway)\n    \t* 두개의 라우터와 베스천 호스트를 이용하여 중립적인 네트워크 비무장 지대 (DMZ, DeMilitarized Zone)를 외부 네트워크와 내부 네트워크 사이에 구축하여 오고 가는 신호의 완충 지역 개념의 서브넷을 운영하는 것\n        * 기관에서 외부로 공개할 정보 서버, 즉 익명 FTP 서버, WWW 서버 등을 DMZ 에서 운영\n* 침입 차단 시스템 (방화벽) 구축의 유의사항\n\t* 내부 사용자들이 요구하는 봉나과 서비스를 적절히 구성\n    \t* 방화벽 형태에 따른 보안 능력 결정\n        * 구축 비용\n        * 방화벽의 서비스\n        * 방화벽의 운용\n        * 방화벽의 사양\n* 침입 차단 시스템 (방화벽) 의 취약점\n\t* 터널링 공격\n    \t* 네트워크 프로토콜이 가지는 특성에 의해서 발생될 수 있는 공격\n        * 차단되어야 할 패킷이 다른 네트워크 프로토콜에 의해 캡슐화 되어 공격에 사용될 때에는 침입차단 시스템이 이를 차단시킬 수 없게 됨\n\t* 응용 기반 공격\n    \t* 80 포트는 통과되도록 설정 된 경우 버퍼 오버플로우 등을 발생시키는 HTTP 명령어가 웹 응용 모듈에 전송되면 이를 포함한 패킷은 차단시킬수 없게 됨\n        \n        \n        \n        \n        \n        ","thumbnail":"univ.jpg","excerpt":"컴퓨터보안 - 7강. 보안 시스템 I","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-16T01:11:32.009Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"patterns.dev 렌더링 패턴 소개 글 번역":{"id":99,"title":"patterns.dev 렌더링 패턴 소개","content":"> 이 글은 https://patterns.dev 에서 제공하는 글인 https://www.patterns.dev/posts/rendering-introduction/ 글을 번역한 글 입니다.\n\n# 들어가면서\n\n## 들어가면서\n\n새로운 웹 앱을 만들기 시작할때에, 가장 기본적으로 드는 질문은 이것일 것입니다.\n\"어떻게 그리고 어디에 내가 보여줄 컨텐츠를 보여주고 싶은가?\"\n웹 서버가 되어야 하는가? 아니면 빌드 서버? 아니면 엣지? 아니면 클라이언트에 직접적으로?\n한번에 보여줘야 하는가? 부분적으로? 점진적으로?\n\n이 중요한 결정의 답은 실제 사용되는 케이스에 의해 결정 됩니다. 가장 최적화된 렌더링 패턴을 선택하는 것은 엔지니어링 팀을 위한 개발자 경험(DX)과 당신이 엔드 유저를 위해 디자인한 유저 경험(UX)에 새로운 세계를 만들것 입니다.\n\n올바른 패턴을 선택하는 것은 더 빠른 빌드와 작은 프로세싱 비용으로 훌륭한 로딩 성능으로 이끌것 입니다. 반대로, 잘못된 패턴의 선택은 좋은 비즈니스 적인 아이디어를 실현 할 수 있는 앱을 죽이게 될것입니다. 따라서 당신이 가진 모든 혁신적인 아이디어들은 적절한 렌더링 패턴과 함께 개발단으로 실현되어야 합니다.\n\n![Introduction](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/4.1.png)\n출처: https://www.patterns.dev/posts/rendering-introduction/\n\n## 렌더링 패턴의 중요성\n\n훌륭한 UX를 만들기 위해서는, [Core Web Vitals (CWV)](https://web.dev/vitals/)와 같이 유저 기반의 수치에 최적화를 하려고 대개 노력합니다. CWV 수치 값들은 가장 유저 경험과 밀접한 값들을 측정합니다. CWV를 최적화 하는것은 우리 앱의 훌륭한 UX와 최적화된 SEO를 가져다 줄 수 있습니다.\n\n![Web Vitals](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1660456914/patterns.dev/web-vitals.png)\n출처: https://www.patterns.dev/posts/rendering-introduction/\n\n엔지니어링 팀을 위한 훌륭한 DX를 만들기 위해서는, 더 빠른 빌드 시간, 쉬운 롤백, 증축 가능한 인프라, 그리고 그 밖에 개발자들이 목표에 도달 할수 있게 하는 많은 다른 기능들을 포함한 개발 환경들을 최적화 해야 합니다.\n\n![Developer Experience](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/5.png)\n출처: https://www.patterns.dev/posts/rendering-introduction/\n\n이러한 규율에 맞추어 개발환경을 셋업 하는 것은 우리 개발팀에게 훌륭한 제품 효율성을 가져다 줄것입니다.\n\n우리의 기대를 요약하면서, 꽤나 긴 리스트를 구축해 왔습니다. 하지만, 올바른 렌더링 패턴을 선택한다면, 대부분의 이러한 이점들을 실제로 이용할 수 있습니다.\n\n![Performance](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/6.png)\n출처: https://www.patterns.dev/posts/rendering-introduction/\n\n## 패턴 고르기\n\n서버사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)에서부터 여러 다른 커뮤니티들에서 논의되고 실험되고 있는 고도로 발전된 패턴들을 다루어오면서, 렌더링 패턴은 긴 역사를 가지고 있습니다. 이러한 것들이 조금 과할 수 있지만, 우리는 모든 패턴들은 특정한 사용 케이스들에 맞추어 디자인 되었다는 것을 기억해야 합니다. 하나의 사용 케이스를 위한 특유의 이점은 다른 사용케이스들에서는 단점이 될수 있습니다. 또한 하나의 웹사이트만 하더라도 다른 여러 종류의 페이지들을 갖고 있어서 다른 렌더링 패턴들을 적용해야 하기도 합니다.\n\n크롬 팀은 개발자들에게 full rehydration 방법론을 말미암아 정적 혹은 서버사이드 렌더링을 [추천해 왔습니다.](https://developers.google.com/web/updates/2019/02/rendering-on-the-web) 시간이 가면 갈수록, 점진적인 로딩과 렌더링 기술들이 당연하게 성능의 좋은 밸런스를 잡아주는데 도움이 되었고 모던 프레임워크의 새로운 기능들로 전달되어 왔습니다.\n\n다음으로 이어질 챕터들에서는 다른 패턴들을 알아봅니다 - 옛 방식과 요즘 방식을 자세히 말이지요. 하지만 그전에, 어디에서 제일 잘 쓰일수 있는지 당신을 이해시키기 위해 그중 몇몇을 간단히 소개하겠습니다.\n\n### Static Rendering (정적 렌더링)\n정적 렌더링은 간단하지만 파워풀한 패턴입니다. 거의 즉시적으로 페이지를 로드하는 빠른 웹사이트를 구축하기 위해 이 패턴을 쓸수 있습니다.\n\n정적 렌더링에서는, 전체적인 페이지를 위한 HTML이 빌드 타임에 생성되며 다음 빌드 전까지는 변화하지 않습니다. HTML 컨텐츠들은 정적이며 CDN이나 Edge Network를 통해서 쉽게 캐싱될수 있습니다. CDN들은 빠르게 캐싱된 pre-rendered된 HTML을 클라이언트에게 가져다 줄수 있습니다. 그들이 특정한 페이지를 요청할때 말이지요. 이러한 방법은 서버사이드 렌더링에서 이루어지는 특정 요청, 요청에서 받아온 HTML 컨텐츠를 보여주기 까지의 시간들을 굉장히 단축시킬수 있습니다.\n\n위에서 설명된 프로세스는 자주 변하지 않고 그 누구가 요청을해도 같은 데이터를 보여주는 페이지들에게 굉장히 최적화 되어있습니다. 요즘에는 웹사이트에서 굉장히 동적이며 커스터마이징 된 데이터를 보여주기 때문에 정적 렌더링에서도 다른 사용케이스들을 쓸 수 있습니다.\n\n![Static Rendering](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/img1.png)\n출처: https://www.patterns.dev/posts/rendering-introduction/\n\n### Basic/Plain Static Rendering (기본적이며 간단한 정적 렌더링)\n정적 렌더링에도 많은 종류의 변형들이 있으므로, 좀전에 다룬 주된 기술을 Plain Static Rendering 이라고 부릅시다. 동적인 컨텐츠가 없는 페이지에서 사용할수 있습니다.\n\n따라서 나올 부동산 관련 웹사이트 데모 페이지는 언제나 같은 컨텐츠를 똑같이 누구에게나 보여줍니다. 아무런 동적인 데이터도 없으며 개인화된 데이터도 없습니다.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_10.10.58_AM_umtlyl.webm)\n\n사이트가 배포되고 빌드 될때 (예를들어, Vercel) 연관된 HTML이 생성되고 서버에 정적인 스토리지에 보관됩니다.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_10.18.37_AM_bhybvb.webm)\n\n유저가 페이지를 요청하면, 서버는 이미 생성된 HTML을 클라이언트에 전송합니다. 이런 응답은 또한 사용자와 가장 가까운 엣지 로케이션에 캐싱됩니다. 브라우저는 HTML을 보여주고 페이지를 동작하게 하기 위해 자바스크립트 번들을 실행합니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/7.png)\n\n플레인 정적 렌더링은 성능에 좋습니다. 굉장히 빠른 TTFB를 가져다 주기 때문이지요. HTML이 이미 서버에서 준비되어있기 때문에 브라우저는 더 빠른 응답을 받을 수 있으며 빠르게 보여줄 수 있습니다. 빠른 FCP와 LCP를 가져다 주면서 말이지요. 컨텐츠가 정저기익 때문에 그리는 동안 레이아웃 쉬프팅도 없습니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/8.png)\n\n그러므로, 플레인 정적 렌더링은 캐싱을 사용하는 CDN에 특히나 사용되며, 훌륭한 Core Web Vitals를 이루도록 도와줍니다. 그러나, 대부분의 웹사이트들은 최소한 몇개라도 동적인 컨텐츠들을 갖고 있으며 유저 인터랙션도 필요합니다.\n\n### 클라이언트 사이드의 fetch를 이용한 정적 렌더링\n우리의 부동산 데모 사이트를 개선하고 싶다고 해봅시다. 가장 최근에 리스팅된 것을 보여주기 위해서죠. 우리는 이러한 리스팅들을 만들기 위해서 데이터 프로바이더를 이용해야 합니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/9.png)\n\n우리는 이 케이스에서 클라이언트 사이드의 fetch를 이용한 정적 렌더링을 이용할 수 있습니다. 이 패턴은 매 request마다 데이터를 업데이트 하고 싶을때 쓰면 좋습니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/10.png)\n\n여전히 정적 렌더링을 쓸수 있으며 Skeleton Component와 같은 UI를 렌더 할 수 있습니다. 동적인 리스트 데이터를 위치하고 싶은곳에 말이지요. 그리고, 페이지가 로드되면 데이터를 fetch 할수 있습니다.(예시에선 SWR을 사용)\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/11.png)\n\n커스텀 API route가 CMS로부터 데이터를 fetch하고 이 데이터를 반환하기 위해 사용되었습니다.\n\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_2.55.30_PM_r0jvez.webm)\n\n미리 생성된 HTML파일은 유저가 페이지를 요청할때에 클라이언트로 전송됩니다. 유저는 처음으로는 Skeleton UI를 데이터 없이 마주하게 됩니다. 클라이언트는 데이터를 API route를 통해서 요청하게 되고, 응답을 받고 리스팅을 보여줍니다. (예시에서는 hydration call은 포함되어 있지 않습니다)\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/12.png)\n\n클라이언트 사이드의 fetch를 이용한 정적 렌더링이 우리에게 좋은 TTFB와 FCP를 주는 동안, FCP는 살짝 덜 최적화 되었죠. 왜냐하면 \"largest content\"가 우리가 리스팅 데이터를 API route를 통해 가져와야만 보여지기 때문이죠.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/13.png)\n\n또한 높은 가능성으로 레이아웃 쉬프팅이 일어날수 있습니다. 만약 스켈레톤 UI의 크기가 결국 보여질 컨텐츠들의 크기와 맞지 않다면 말이죠.\n\n또 다른 단점은 이러한 방법론은 더 높은 서버 비용이 들게 할수 있습니다. 우리가 API route를 매 페이지 요청마다 부르기 때문이지요.\n\nNext.js는 몇가지 해결책을 제시합니다. 다음에 이어질 몇가지 섹션들에서 앱이 다이나믹한 데이터를 다룰때에 성능을 향상 시킬수 있는 방법을 논의할겁니다.\n\n### getStaticProps를 사용한 정적 방법\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/14.png)\n\n이 방법론은 당신을 데이터 프로바이더에게 접근할수 있게 하고 빌드 타임에 서버에서 데이터를 페치할수 있게 합니다. 이것은 빌드타임에 언제나 당신이 원하는 동적인 데이터가 존재 할때에 좋은 방법입니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/15.png)\n\n`getStaticProps` 메서드를 통해서 우리는 HTML을 데이터와 함께 서버에서 제공할수 있습니다. 그러므로, 클라이언트에서 API 를 페치하는 route를 만들지 않아도 됩니다. 비슷하게, 스켈레톤 컴포넌트는 데이터가 로드되기 전에 필수가 아닙니다. 왜냐면 페이지 자체가 데이터와 함께 바로 제공될 것이기 때문이지요.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.02.04_PM_avmzuy.webm)\n\n프로젝트를 빌드 할때에, 데이터 프로바이더가 콜 되며, 반환된 데이터는 생성된 HTML을 통하게 됩니다.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.06.26_PM_djvt57.webm)\n\n유저가 페이지를 요청할때에, 프로세스는 플레인 정적 렌더링과 비슷합니다. 응답이 캐싱되며 스크린에 보여집니다. 그리고 브라우저는 자바스크립트 번들을 fetch하게 되고 페이지를 hydration 시킵니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/16.png)\n\n클라이언트의 관점에서 네트워크와 메인쓰레드가 플레인 정적 렌더링과 동일합니다. 그래서 우리는 비슷한 굉장한 성능을 얻게됩니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/17.png)\n\n사이트가 커가면서, 우리가 이러한 방법을 쓸때에 DX가 좋진 않습니다.\n\n수백개의 페이지를 가진 사이트들에서 (블로그 사이트와 같이) 정적으로 빌드된다면 getStaticProps 메서드는 반복적으로 불릴 것이며 긴 빌드타임을 반환하게 됩니다. 외부의 API를 사용한다면, 리퀘스트 리밋을 넘어서거나 엄청난 비용을 지불하게 될거에요.\n\n이 방법은 또한 빌드타임에서 비교적 자주 데이터를 새롭게 하지 않아도 될때에만 좋습니다. 잦은 데이터의 업데이트는 우리가 사이트를 자주 재 빌드 하고 재 배포해야 한다는 것을 의미하니까요.\n\n## Incremental Static Regeneration (점진적인 정적 재 생성)\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/18.png)\n\n우리는 이러한 빌드타임 이슈와 동적 데이터 이슈를 해결하기 위해서 점진적인 정적 재 생성을 사용합니다.\n\nISR은 유저가 요청하면 동적 페이지를 렌더링 하기도 하고 정적 페이지만을 렌더링 하기도 하는 하이브리드입니다. 이것은 더 적은 빌드 횟수와 자동화된 캐시 invalidation과 특정 인터벌 뒤의 페이지 재생성을 가져다 줍니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/19.png)\n\n우리의 이전의 데모를 이제는 각각의 디테일한 정보를 보여주기 위해서 개발한다고 칩시다. 우리는 이러한 새로운 페이지들을 pre-render할수 있습니다. 유저가 리스트들을 클리했을때 빨리 로드하기 위해서죠.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/20.png)\n\nNext.js는 getStaticProps를 사용하여 동적인 path들을 만들도록 달성하게 도와줍니다. 쿼리 파라미터를 통해 우리는 Next.js에게 어떤 페이지들을 먼저 생성할지 알려줄수 있습니다.\n\n우리의 데모에서 모든 리스트들을 fetch하고 각각의 페이지들을 먼저 생성한다고 해봅시다. 이것은 수천개의 리스트가 있다면 굉장히 오래걸리는 일입니다. 그러한 케이스에서 Next에게 모든 페이지의 부분만 먼저 생성하라고 하고 남은 리스팅 페이지들이 요청에 의해서 생성될때에 fallback을 보여주게 할수있습니다. (유저가 요청할때에만)\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/21.png)\n\n미리 렌더링되고 생성된 온디맨드 페이지들은 비슷하게 전달됩니다. 유저가 미리 생성되지 않은 페이지를 요청한다면, 요청이 왔을때에만 생성이 되고 Edge에 의해서 캐싱됩니다. 그러므로 처음으로 요청한 유저만이 조금 느린 속도를 경험할 것입니다. 다른 모든 사람들은 이점을 갖게 될것입니다. 캐싱으로 말이지요.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.49.59_PM_deygni.webm)\n\n긴 빌드타임 이슈는 해결이 된듯 합니다. 하지만 우리는 아직도 우리가 새로운 리스트를 추가할때마다 재배포를 해야하는 랜딩페이지가 남아있네요.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/22.png)\n\n랜딩페이지를 리프레시 하기 위해서는, 캐시를 자동적으로 invalidate 할수 있습니다. 그리고 특정 간격에 따라서 백그라운드에서 페이지를 다시 생성할수 있지요. 우리는 이것을 revalidate 필드를 통해서 사용할수 있습니다.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/updated_jvhqnv.webm)\n\n만약 유저가 특정시간보다 더 오래 캐싱된 페이지를 요청했다면, 유저는 처음으로는 stale page를 보게됩니다. 페이지 재 생성은 즉시 실행됩니다. 페이지가 백그라운드에서 재생성되었다면, 캐시는 사라지고 최근에 재생성된 페이지로 업데이트 됩니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/23.png)\n\nISR로 인해서 우리는 다이나믹한 컨텐츠들을 자동적으로 새로 만들어주는 이점을 볼수 있습니다.\n\n비록 이 방법이 이전에 다루었던 방법보다 이미 굉장한 성능 향상임에도, 몇가지 살펴봐야 할것이 남아있습니다. 우리의 컨텐츠들은 사실 우리가 설정한 시간간격보다는 훨씬 적게 업데이트 됩니다. 이것은 불필요한 페이지 재생성과 캐싱 invalidation을 유발 할것이에요. 이러한 현상이 나올때마다, 우리는 우리의 serverless function들을 다시 부르게 되고 높은 서버 비용이 나오게 하죠.\n\n### On-demand Incremental Static Regeneration (온디맨드 ISR)\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/24.png)\n\n우리가 마지막으로 언급한 문제점을 해결하기 위해서 우리는 ISR를 사용한 온디맨드 ISR이 있습니다. ISR이지만 재생성이 고정된 인터벌이 아닌 특정 이벤트에서만 작동합니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/25.png)\n\nrevalidate 필드를 쓰는 대신, API route에 기반한 새로운 데이터에 기반해서 revalidate을 합니다.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.24.13_PM_xeumhu.webm)\n\n예를들면 우리는 incoming webhook을 구독하여 언제 새로운 데이터가 추가되었는지 알수 있습니다. 우리가 revalidate method를 요청하면, 특정 path를 갖는 페이지는 자동적으로 재생성됩니다.\n\n일반적인 ISR에서는 업데이트된 페이지가 유저가 요청한 페이지를 위해서만 edge node에서 캐싱됩니다. 온디맨드 ISR은 stale content를 보게하지 않고 전세계의 모든 엣지 네트워크를 통해서 페이지를 재생성하고 재전달 합니다. 따라서  자동적으로 대부분이 가장 최신의 페이지를 볼수있게 말이지요. 또한 불필요한 재생성과 불필요한 서버리스 함수 요청들을 방지합니다. 일반적인 ISR에 비하면 말이지요.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/26.png)\n\n따라서 온디맨드 ISR은 우리에게 퍼포먼스 향상과 좋은 DX를 제공합니다.\n\n전반적으로 정적 생성은 좋은 패턴입니다. 특히나 ISR과 같은 정적 패턴은 상당수의 실사용 케이스를 커버할수있습니다.\n\n언제나 합리적인 가격으로 올라와 있어야하는 빠르고 동적인 웹사이트들을 가질수 있게합니다. 그러나 어떤 실사용 케이스들에서는 static이 최선이 아닐때가 있습니다. 예를들면, 엄청나게 dynamic하고 개인화된 페이지라면 말이죠. 그런 페이지들은 유저마다 다릅니다. 이러한 케이스에서는 어떤 패턴이 최고인지 알아보죠.\n\n## Server-Side Rendering (서버사이드 렌더링)\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/27.png)\n\n서버사이드 렌더링에서는 HTML을 매 요청마다 생성합니다. 이러한 방법은 고도로 개인화된 데이터를 갖는 페이지들에서 유용합니다. 예를들면 유저 쿠키 기반의 데이터라던지 유저의 요청에 기반한 포괄적인 어떠한 데이터들에서 말이지요. 또한 인증 상태에 따라서 렌더블라킹을 유발해야하는 페이지들에서도 좋습니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/28.png)\n\n개인화된 대시보드에서는 고도로 다이나믹한 컨텐츠를 갖는 것의 좋은 예시 입니다. 컨텐츠의 대부분이 유저의 식별이나 인증레벨에 따라 결정됩니다. 유저의 쿠키에 기반하거나 해서 말이죠. 이런 대시보드는 유저가 인증되었을때에만 보여지고 유저 특유의 중요한 데이터를 보여줄수도 있습니다. 다른 유저에게는 보여주어서는 안되는 데이터들이죠.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/29.png)\n\nNext.js에서는 `getServerSideProps` 메서드를 통해서 서버를 통한 페이지 렌더링을 제공합니다. 이 메서드는 매 요청마다 서버에서 이루어지며 결국 반환된 데이터를 페이지에게 HTML을 만들기 위해서 전달합니다.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.31.41_PM_oxsq12.webm)\n\n유저가 페이지를 요청할때, `getServerSideProps`는 실행되고 페이지를 만들기 위해서 데이터를 반환합니다. 그리고 이 응답을 클라이언트에게 전송합니다. 클라이언트는 HTML을 렌더링하고 다른 요청을 하기 위해서 Javascript bundle을 페치합니다. HTML 요소들을 hydrate하는 자바스크립트 번들이지요.\n\n생성된 HTML컨텐츠들은 매 요청마다 다르고 CDN에 캐싱되면 안됩니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/31.png)\n\n클라이언트를 위한 네트워크와 메인쓰레드가 굉장히 static과 서버사이드 렌더링이 비슷합니다. FCP는 거의 LCP와 비슷하며 초기 페이지로드 후에 레이아웃 쉬프팅을 피할수 있습니다. 동적인 데이터 로딩이 없다면 말이죠.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.36.49_PM_kkuxv3.webm)\n\n그러나 서버렌더링된 TTFB는 static rendering에 비해서 굉장히 깁니다. 매 요청마다 처음부터 다시 만들어지기 때문이지요.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/32.png)\n\n서버사이드 렌더링이 고도화된 개인적인 데이터를 렌더링하기에는 좋은 선택지이지만 더 나은 UX와 서버 비용을 줄이기위해서 고려해야할 사항들이 몇개가 있습니다. 이러한 비용들은 높을 것 입니다. 매 요청마다 serverless function을 호출하기 때문이지요.\n\n1. `getServerSideProps`의 실행 시간\n페이지 생성은 `getServerSideProps`로부터 데이터가 올때까지 시작되지 않습니다. 나아가서 우리는 `getServerSideProps`메서드가 너무 오래걸리지 않는다는 것을 전제로 해야합니다.\n2. serverless function과 똑같은 위치의 데이터베이스를 배포하기\n만약 데이터가 데이터베이스를 통해서 온다면, 데이터베이스 조회에 걸리는 시간을 줄여야 합니다. 쿼리 최적화에 더해서, 데이터베이스의 위치도 고려해야 합니다.\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.38.55_PM_uwecig.webm)\n만약 당신의 serverless function이 San Francisco에 위치해 있고 데이터베이스가 도쿄에 있다면 커넥션을 구축하고 데이터를 가져오는데에 많은 시간이 들 것 입니다. 대신, 데이터베이스를 serverless function과 같은 리젼으로 옮기세요. 더 빠른 데이터베이스의 조회 시간을 위해서 말이지요.\n3. 응답 헤더에 `Cache-Control`을 추가하기\nSSR 성능을 향상시키는 다른 방법은 응답시간에 Cache-Control 헤더를 붙이는 것입니다.\n4. 서버 하드웨어 향상\n서버 하드웨어를 업그레이드 하는 것은 각각의 요청과 응답을 더 빠르게 할수 있습니다.\n\nVercel은 serverless function 들을 server-render하기 위해서 사용합니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/34.png)\n\n당신이 이용한 만큼만 지불하는 것 처럼 serverless function이 많은 이점을 가지고 있음에도, 몇가지 제한들이 존재합니다. long cold boot로 알려진 람다를 시작하는 시간은 serverless function들의 보편적인 이슈입니다. 또한 데이터베이스 연결이 느릴수 있습니다. 또한 지구반대편에 위치한 서버리스 함수를 콜하게 되면 안됩니다.\n\n## Edge SSR + HTTP Streaming (에지 SSR + HTTP 스트리밍)\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/35.png)\n\nVercel은 현재 **Edge Server-Side Rendering**을 탐험중입니다. 이것은 유저들이 **어떠한 region**에서도 서버렌더를 할수 있게 하며 거의 **0에 가까운 cold boot**를 경험하게 합니다. Edge SSR의 또 다른 이점은 edge runtime이 **HTTP Streaming**을 가능케 한다는 것입니다.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.47.07_PM_usqexj.webm)\n\nServerless function을 통해서 페이지 전체를 서버사이드에서 생성하고 모든 번들이 로딩되기를 기다리며 hydration이 시작할수 있기 전에 파싱합니다.\n\n![](https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.48.20_PM_auurip.webm)\n\nEdge SSR을 통해서 다큐먼트가 각각이 준비가 되고 hydrate할수 있을때에 알갱이별로 스트림 할수 있습니다. 대기시간을 줄이게 합니다. 먼저 볼수 있는 컴포넌트들을 하나하나 볼수있기 때문이지요.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/40.png)\n\nStreaming SSR은 React Server Components를 가능하게 합니다. React Server Components를 사용한 Edge SSR은 static과 server 렌더링의 아름다운 하이브리드를 제공합니다.\n\nReact Server Component는 부분적으로 리액트 컴포넌트를 서버에서 렌더할수 있게 합니다. 클라이언트로 다운로드 될 필요없는 큰 의존성을 요구하는 컴포넌트들을 위해서 유용합니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/41.png)\n\n부동산 데모 웹사이트로 돌아가서, 우리가 랜딩페이지를 보여주는것과 동시에 유저의 위치 기반으로된 리스트들을 보여주고 싶다고 해봅시다. 페이지의 대다수가 static data만을 필요로 합니다. 요청 기반의 데이터를 필요로하는 리스트들이죠.\n\n전체적인 페이지를 서버렌더하는 것 보다, 우리는 이제 리스트 컴포넌트들만을 서버사이드에서, 나머지는 클라이언트사이드에서 렌더링 할수 있습니다. 서버렌더에서 모든 것을 서버사이드에서 렌더링 하는 반면, 우리는 이제 서버사이드 렌더링의 동적 이점을 가진 Static Rendering으로 훌륭한 성능을 보여줄수 있습니다.\n\n![](https://res.cloudinary.com/ddxwdqwkr/image/upload/v1658990025/patterns.dev/42.png)\n\n우리는 서버에서 컨텐츠를 렌더하는 많은 패턴들을 알아보았습니다. 완벽한 rehydration을 가진 [클라이언트 사이드 렌더링(CSR)](https://www.patterns.dev/posts/client-side-rendering/) 은 다이나믹한 웹사이트를 위해서 아직도 추천됩니다. 유저인터랙션 기반으로 모든 컴포넌트들이 바뀌는 것이죠.\n\n어플리케이션의 타입이나 페이지 타입에 기반하면, 몇몇의 패턴들은 다른 것들모다 더 많이 유용할것입니다. 아래의 차트는 서로 다른 패턴들의 요약을 비교하며 각각의 실사용 케이스를 알려줍니다.\n\n![](https://www.patterns.dev/img/remote/Z1mbJpL.svg)\n\n[Patterns for Building JavaScript Websites in 2022](https://dev.to/this-is-learning/patterns-for-building-javascript-websites-in-2022-5a93) 에서 제공하는 이어지는 테이블에서는 주된 어플리케이션 성향의 키포인트에 따른 다른 시각을 제공합니다. 보편적인 [application holotypes](https://jasonformat.com/application-holotypes/)를 찾고있는 사람들이라면 유용할 것입니다.\n\n\n\n\n\n\n\n\n\n","thumbnail":"js.png","excerpt":"patterns.dev 렌더링 패턴 소개 글 번역","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-11-26T07:23:53.458Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[{"blogArticleTag":{"name":"patterns.dev"}},{"blogArticleTag":{"name":"render pattern"}},{"blogArticleTag":{"name":"rendering pattern"}},{"blogArticleTag":{"name":"client side rendering"}},{"blogArticleTag":{"name":"static rendering"}},{"blogArticleTag":{"name":"server side rendering"}},{"blogArticleTag":{"name":"ssr"}}]},"모바일앱프로그래밍- 7강. 레이아웃의 중첩":{"id":100,"title":"모바일앱프로그래밍- 7강. 레이아웃의 중첩","content":"# 모바일앱프로그래밍- 7강. 레이아웃의 중첩\n\n## 1. TableLayout\n* 표의 속성\n\t* TableRow\n    * View\n    * TableRow의 개수가 행의 개수\n    * TableRow 안에 배치되는 자식 View의 개수가 열의 개수\n* 자식 View\n\t* TableRow의 높이 (layout_height)의 기본 속성값은 wrap_content으로 지정되어 있음\n* shrinkColumns, stretchColumns\n\t* setShrinkAllColumns\n    * setStretchAllColumns\n    \n## 2. 레이아웃 중첩 (1)\n* 레이아웃은 View의 컨테이너 (ViewGroup)\n* View로 부터 파생된 모든 ViewGroup과 위젯을 레이아웃 안에 중첩하여 배치할 수 있음\n* 레이아웃 자체도 View의 파생 클래스이므로 레이아웃끼리 중첩하여 배치하는 것이 가능\n\n## 3. 레이아웃 중첩 (2)\n\n## 4. 실행 중에 속성 바꾸기\n* 동적 속성 변경\n\t* FrameLayout에 속한 레이아웃의 visibility 속성을 실행 시간에 바꾸는 예제\n    * 속성을 변경 할 때에는 JAVA 코드가 관련 메소드를 호출함\n    * LinearLayout 방향 바꾸기 -> setOrientation 메서드 호출\n* 속성 변경 방법 - gravity\n* 속성 변경 방법 - TextView\n","thumbnail":"univ.jpg","excerpt":"모바일앱프로그래밍- 7강. 레이아웃의 중첩","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-08T13:38:10.506Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"소프트웨어공학 6강. 사용자 요구 분석":{"id":101,"title":"소프트웨어공학 6강. 사용자 요구 분석","content":"# 소프트웨어공학 6강. 사용자 요구 분석\n\n목차\n1. 요구사항\n2. 요구공학 프로세스\n3. 요구사항 모델링\n\n## 1. 요구사항\n* 시스템이 갖추고 있어야 하는 조건이나 능력\n* `요구 분석과 명세`\n\n> 기능적 요구사항 / 비 기능적 요구사항\n\n> FURPS+\n* HP 에서 개발한 요구사항 분류 모델\n* Functionality: 기능적 요구사항\n* URPS와 +는 비기능적 요구사항\n* Usability Reliability Performance Supportablity\n* 사용성 신뢰성 성능 지원성을 의미하는 품질 요구사항\n* `+` 는 설계, 구현, 인터페이스 및 물리적 제약 사항에 관한 것\n\n###  요구 공학 \n* 시스템의 목표와 기능 및 제약사항을 결정하는 과정으로 시스템 요구사항을 만들고 유지하기 위한 반복적 프로세스를 말함.\n\n\n## 2. 요구공학 프로세스\n* 시스템의 목표와 기능 및 제약사항을 결정하는 과정\n\n>  타당성 조사 -> 요구사항 수집과 분석 -> 요구사항의 문서화 -> 요구사항 검토\n\n### JAD\n* 애플리케이션 설계와 개발 과정에 고객과 사용자를 참여시키는 방법. 고객과 개발자 간의 협력과 합의를 위해 워크숍을 진행.\n\n\n\n## 3. 요구사항 모델링\n* 자연언어 이용한 명세의 문제점\n\t* 모호성, 요구사항의 혼합, 과도한 유연성, 모듈화의 어려움\n* 시스템을 이해하거나 명세화 하기위해 `모델`사용\n* 구조화된 언어, 설계 기술 언어\n\n### 시스템 모델\n### 객체 지향 분석\n* 요구사항의 정형화 과정\n* 분석 모델\n\t* 객체지향 분석의 결과물로 시스템을 사용자 관점에서 표현\n\n### 구조적 분석\n* 추상화의 원리\n* 형식화의 원리\n* 분할과 정복: 큰 문제를 작고 독립적인 문제들로 나누어 푸는 것\n* 계층화\n\n### DFD (Data Flow Diagram)\n* 구조적 분석에서 사용되는 기능 관점의 시스템 모델\n* 데이터 흐름과 변환을 보여주는 네트워크 형태의 다이어그램\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"소프트웨어공학 6강. 사용자 요구 분석","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-18T14:30:15.098Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"생활과건강 - 12강. 응급처치(1)":{"id":102,"title":"생활과건강 - 12강. 응급처치(1)","content":"# 생활과건강 - 12강. 응급처치(1)\n\n## 1. 응급의료 체계의 이해\n* 응급의료 체계\n\t* 신속한 응급 처치 및 병원 진료\n    * 인력 장비 자원 등 모든 요소를 효율적으로 운영하기 위한 체계\n    * 현장에서 적절한 처치\n* 병원 전 단계\n\t* 환자 발생의 신고와 구급차 출동\n    \t* 처음 발견한 일반인과 신고 접수자\n        * 최초로 응급처리 수행하는 사람의 역할이 매우 중요\n\t* 응급 상황이 발생한 위치, 사고의 종류, 환자의 수, 상태, 처치 내용 등을 알림\n\t* 구급대에 의한 현장 응급 처치\n    \t* 제세동\n        * 전문심장소생술\n* 병원 단계\n\t* 현장 처치의 검토 및 연속적인 응급 처치\n    * 진단을 위한 적절한 검사\n    * 입원치료 혹은 응급수술 결정\n* 응급 의료 관련 법규\n\t* 응급 의료에 관한 국민의 권리와 의무\n    * 국가 지방자치 단체의 책임\n    * 응급의료 제공자의 책임과 권리\n\t* 응급의료 체계의 확립\n    * 응급진료체계 정비\n    * 응급구조사의 법제화\n\n## 2. 기도폐쇄\n* 기도가 부분 혹은 전체적으로 폐쇄되는 것\n* 기도\n\t* 공기가 인후두부, 기관, 기관지 등의 통로를 거쳐 폐에 도달하는 통로\n* 혀가 뒤로 말려들어가 숨을 쉬는 길인 기도와 목안을 막기 때문\n* 원인\n\t* 성인: 주로 음식물에 의해 발생\n    * 어린아이: 땅콩, 장난감, 동전 등이 기도로 넘어가 기도를 막을 수 있음\n    * 외상이나 사고를 당한 경우 입안이 손상되어 치아나 출혈등에 의해 기도가 막히기도 함\n    * 의식이 없는 환자는 혀가 뒤로 말려 들어가는 경우가 있음\n* 증상\n\t* 호흡과 맥박이 빨라짐\n    * 호흡보조근을 사용하므로 매우 힘들어 보임\n    * 의식 수준의 변화\n    * 피부색이 창백하거나 검푸른 빛으로 변함\n* 처치\n\t* 기도의 일부분이 막히는 경우\n    * 완전히 막히는 경우\n    * 의식이 없는 환자는 심폐소생술을 시행\n    * 힘있게 기침을 해서 이물을 뱉어 내도록 유도\n    * 하임리히법\n    \t* 복부 밀쳐 올리기\n\n## 3. 심폐소생술\n* 심정지\n\t* 심장 기능이 멈춘 상태\n    * 심장박동이 없다\n* 기본 소생술\n\t* 1차 소생술\n* 전문 소생술\n\t* 2차 소생술\n\t* 심정지의 신속한 인지\n    * 응급의료체계의 활성화\n    * 신속한 심폐소생술\n* 심폐소생술의 필요성\n\t* 환자의 뇌손상을 최소화하는 것\n    * 심정지 발생 후 4~5분 경과하기 전에 소생술을 실시해야 함\n* 생존사슬 (chain of survival)\n\t* 심정지의 예방과 조기 발견\n    * 신속한 신고\n    * 신속한 심폐소생술\n    * 신속한 제세동\n    * 효과적 전문 소생술과 심정지 후 치료\n* 심페소생술의 절차와 방법\n\t* 자동심장충격기 -> 심폐소생술 시작\n    * 기본소생술 가이드라인 기준에 근거한 기본소생술 순서\n    * 환자의 반응 확인\n    * 119 신고\n    * 호흡 확인\n    * 가슴 압박\n    * 가슴압박소생술 (CPR)\n    * 인공호흡\n    \t* 기도 유지-열기\n        \t* 머리 기울임-턱 들어올리기 방법\n\t\t* 입-입 인공호흡\n        \t* 코를 막은 다음\n\t* 자동심장충격기 (AED)\n* 선의의 응급의료에 대한 면책 (선한 사마리아인 조항)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 12강. 응급처치(1)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-06-01T06:06:27.598Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"생활과건강 - 7강. 건강한 생활습관(1)":{"id":103,"title":"생활과건강 - 7강. 건강한 생활습관(1)","content":"# 생활과건강 - 7강. 건강한 생활습관(1)\n\n## 생활습관병\n* 산업화, 기계화가 삶을 풍요롭게 변화\n* 영양과잉이 보편화\n* 동물성 식품 위주의 식생활 변화 초래\n* 질병 양상에도 큰 영향\n\t* 비만 증가\n    * 암, 당뇨, 순환기계 질환 등\n    * 만성 질환자 수가 늘어나기 시작\n* 만성\n\t* 급성과 대비되는 것\n    * 시간적 요소를 내포하는 특성\n* 만성 질환\n\t* 30일 이상의 중환자 관리를 받거나 3개월 이상 병원이나 요양기관에서 의학적 관리 혹은 재활교육 필요로 하는 지속적인 질환이나 영구적인 장애 상태\n* 미국\n\t* 만성퇴행성 질환\n    * 만성 질환\n* 영국\n\t* 생활습관 관련병\n* 스웨덴\n\t* 생활이 유복한 사람이 잘 걸린다는 의미에서 유복병이라고 함\n* 독일\n\t* 문명병\n* 프랑스\n\t* 생활 습관병\n* 대한민국\n\t* 만성질환의 대부분이 성인에서 발생하므로 성인병이라고 함\n\t* 성인병\n    \t* 일본에서 시작된 용어\n        * 2003년부터 성인병을 생활 습관병으로 개칭 함\n* 잘못된 생활 습관에서 비롯 된 병\n* 불균형한 식생활, 운동 부족 등 활동량 감소, 과로, 스트레스와 같은 잘못된 생활 방식을 오래 유지하는 동안 건강의 균형이 무너지면서 생기는 생활 습관과 관련된 만성 질환을 의미\n\n## 생활 습관병의 특징\n* 대부분 여러 요인이 복합적으로 관여하여 합병증을 수반\n* 서서히 발병하고 대부분 자각증상이 없어 위험한 질병\n* 어려서부터 시작하고 평소 생활 습관과 관련성이 크다는 점에서 예방이 가능\n* 조기에 발견하여 치료하면 그 피해를 최소로 줄일 수 있음\n\n## 대사 증후군\n* 개개인 다 다른 형태의 생활 양식을 가지고 살아감\n* 운동, 흡연, 음주, 수면, 휴식, 스트레스, 대인관계의 형태가 다름\n* 체중 증가로 인한 비만, 혈압 상승 등\n* 여러가지 질환이 한 개인에게서 한꺼번에 나타나는 것을 대사증후군 이라고 함\n* 대사증후군의 진단 기준\n\t* 복부비만\n    * 높은혈압\n    * 높은 혈당\n    * 높은 중성지방혈증\n    * 낮은 HDL 콜레스테롤 혈증\n    * 다섯가지 위험 요인 중 세가지 이상에 해당하는 경우 대사증후군으로 진단\n* 발병원인\n\t* 일반적으로 인슐린 저항성이 근본적인 원인으로 작용한다고 추정\n    * 인슐린 저항성이 생기는 이유로 가장 흔한 것\n    \t* 과음, 과식, 운동부족에 따른 복부 비만과 지방간, 스트레스, 노화, 유전적 이유 등\n* 인슐린 저항성\n\t* 인슐린에 대한 반응이 정상적인 기준보다 감소된 것\n* 인슐린\n\t* 세포가 포도당을 에너지원으로 쓸 수 있게 세포의 문을 열어주는 역할\n* 발병 원인\n\t* 인슐린 저항성 증가\n    * 고 인슐린 혈증 유발\n    * 포도당을 더 만들어 내기 위해 인슐린을 더 분비 시켜 고인슐린 혈증 유발\n    * 각종 건강 문제 유발\n\t* 혈중 염분, 수분증가로 인한 혈압 상승\n    * 지방의 체내 축적 유도로 비만 발생률 증가\n\t* 저체중 출산\n    * 대사 증후군은 인슐린의 저항성을 개선해야 근본적인 치료가 가능\n    * 고칼로리 음식의 섭취 제한\n    * 꾸준한 운동\n* 복부비만\n\t* 복부에 지방이 과도하게 축적된 상태를 일컫는 용어\n\t* 우리나라에서는 허리둘레 남자 90cm이상, 여자 85cm이상인 경우를 복부비만으로 분류\n    * 복부비만이 심해지면 대사증후군 증가\n    * 복부의 지방\n    \t* 분포하는 위치에 따라 내장지방과 피하지방으로 구분\n        * 장기 주변에 지방이 끼면 장기가 압박을 받아 활동이 위축\n        * 장기의 기능이 떨어짐\n        * 체내 장기를 둘러싸고 있는 부위에 축적된 내장지방\n\t* 내장지방은 혈액 속으로 지방을 흘려보낸다\n    * 심뇌혈관질환의 위험을 높이고 내장지방세포의 지방산이 과다하게 유리된다\n    * 인슐린 저항성을 증가시킴\n    * 과식, 운동부족도 내장지방 축적의 주요원인으로 작용\n    * 식사량, 균형잡힌 영양섭취하는 식습관을 조절, 운동량을 늘리려는 노력이 필요\n* 고혈압\n\t* 일차성 고혈압\n    \t* 전체 고혈압의 90% 정도를 차지\n        * 그 원인이 명확히 밝혀지지 않았음\n\t* 이차성 고혈압\n\t* 고혈압 전단계\n    \t* 수축기 혈압이 130 ~ 139mmHg 이거나\n        * 이완기 혈압이 80 ~ 89mmHg 인 경우를 고혈압 전 단계로 분류\n        * 수축기 혈압이 130mmHg 이상이거나 이완기 혈압이 85mmHg 이상일때\n        * 혹은 혈압약 복용 여부\n        * 대사 증후군 진단 기준이 되고 있음\n        * 고혈압은 인슐린 저항성과 관련이 있으므로 운동량 늘리거나 체중 조절\n* 당뇨병\n\t* 포도당\n    * 췌장에서 인슐린을 너무 소량 분비하거나 전혀 만들어 내지 못하면\n    * 혈액 속에 당이 과다 해져 당뇨병이 생기게 됨\n    * 비만\n    \t* 체내 인슐린 저항성이 높아짐\n\t* 간이 혈당 측정기\n    * 평소 혈당 수치를 적정 수준으로 유지\n    * 장기간의 혈당 조절 상태를 파악하는 것이 필요\n* 이상지질혈증\n\t* 동맥경화 발생과 밀접하게 관련된 중성지방, 저밀도지단백 콜레스테롤 (LDL 콜레스테롤)\n    * 고밀도지단백 콜레스테롤 (HDL 콜레스테롤)의 수치가 적정 수준을 벗어나는 경우\n    * 콜레스테롤\n\t    * 세포막과 지단백의 구성성분\n    \t* 호르몬 담즙산의 원료\n        * LDL 콜레스테롤: 동맥경화 위험 증가\n        * HDL 콜레스테롤: 말초혈관의 콜레스테롤 제거\n\t* 고 콜레스테롤 혈증 관리의 목표\n    * 대사증후군 진단 기준\n    \t* HDL 콜레스테롤: 남성 40mg 미만, 여성 50mg 미만인 경우\n\t* 중성지방\n    \t* 죽상경화증 유발하거나 LDL 콜레스테롤의 증가에 영향을 미치기도 함\n* 문제점\n\t* 신체적, 심리사회적 측면에서 다양한 문제를 동반\n    * 복부비만\n    \t* 심혈관계 질환\n        * 호흡기계 질환\n        * 내분비계 이상 및 당뇨\n        * 암\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 7강. 건강한 생활습관(1)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-29T12:03:57.398Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"컴퓨터보안 6강. 네트워크 보안":{"id":104,"title":"컴퓨터보안 6강. 네트워크 보안","content":"# 컴퓨터보안 6강. 네트워크 보안\n\n## 1. 네트워크 보안의 개요\n* 컴퓨터 네트워크\n\t* 시스템 간의 상호 접속 및 정보교환의 편리한 창구 역할\n    * 시스템에 대한 불특정 다수의 접근을 가능하게 함\n    \t* 시스템 침입자에 의한 보안 사고의 위험을 내포\n* 네트워크 보안의 목적\n\t* 모든 통신회선상의 정보는 항상 획득 가능\n    * 통신 회선상의 정보를 보호할 수 있는 방법을 찾는 것\n* 보안 위협 요소\n\t* 물리적인 위협\n    \t* 네트워크 시스템에 대한 직접적인 파괴나 손상을 입히는 행위 또는 도난 등\n    * 기술적인 위협\n    \t* 수동적 공격\n        \t* 통신 회선상의 정보를 무단으로 취득하는 행위\n        * 능동적 공격\n        \t* 통신 회선상의 정보를 변조, 위조하는 행위\n* 수동적 공격과 능동적 공격에 대한 대응을 총칭\n* 수동적 공격에 대한 방어\n\t* 통신 회선에 대한 제 3자의 접속 시도를 방지\n    * 통신 회선상의 데이터를 암호화 (기밀성 보장)\n* 능동적 공격에 대한 방어\n\t* 암호화\n    * 수신 측에서 데이터에 대한 무결성 확인\n\n\n## 2. 네트워크 보안의 목표\n* 기밀성, 무결성, 가용성, 부인방지, 사용자의 신분확인 및 인증, 데이터 발신처 확인, 접근 제어\n\n## 3. 네트워크 보안 모델\n* 네트워크 보안 서비스\n\t* 보안공격을 방어하기 위한 것\n* 네트워크 보안 메커니즘\n\t* 보안 공격을 예방, 탐지 및 복구하기 위한 제반 기법\n    * 보안서비스를 구성하는 기술\n* OSI 7 계층에서의 보안 프로토콜 구조\n\t1. 물리 계층: 전송되는 모든 비트를 전부 암호화\n    2. 데이터링크 계층: 보안 서비스는 규정됨\n    3. 네트워크 계층: SP3\n    4. 트랜스포트 계층: SP4\n    5. 세션 계층: 보안서비스 제공 안됨\n    6. 프레젠테이션 계층: 암호에 기초한 데이터의 구문적인 부호화\n    7. 애플리케이션 계층: MHS, FTAM, 디렉토리 보안 등\n\n## 4. 네트워크 보안 서비스\n* 인증\n\t* 수신된 데이터의 실체가 원하는 실체라는 것을 확인하는 서비스\n    * 대등 실체 인증\n    \t* 통신 당사자간의 신분 확인과 자격 유무의 점검\n        * 대등한 개체간의 신뢰성 있는 연결 확립 또는 데이터의 전송 과정에 적용\n        * 일반적으로 패스워드 및 암호화 기법이 사용됨\n        * 일방향 대등 실체 인증과 양방향 대등 실체 인증으로 구분\n    * 데이터 발신처 인증\n    \t* 데이터를 발신한 발신처를 확인한 후 해당 발신처의 자격 유무를 제공\n        * 송신자와 수신자 상호간의 통신 없이 정보를 제공하는 네트워크 (전자우편)\n        * 데이터 수정 등에 대한 보안은 제공하지 못함\n* 접근 제어\n\t* 비인가된 사용자의 위협으로부터 정보 자원을 보호\n    * 사용자의 신분이 확인된 이후 해당 사용자가 정보 자원에 대하여 어느 수준의 접근 권한을 갖고 있는지 결정\n    * 보호하여야 할 정보 자원에 대한 불법적인 접근이 이루어지지 못하도록 함\n* 기밀성\n\t* 네트워크를 통하여 전달되는 정보가 인가되지 않은 사용자나 주체가 행하는 여러가지의 불법 행위 및 처리 등으로 인하여 노출되는 것을 방지하는 서비스\n    * 접속 기밀성\n    * 비접속 기밀성\n    * 선택 영역 기밀성\n    * 트래픽 흐름 기밀성\n* 데이터 무결성\n\t* 데이터의 내용이 인가되지 않은 방식에 의하여 변경 또는 삭제 되는 것을 방지하는 서비스\n    * 다섯가지 형태로 구분\n    \t* 복구 기능을 갖는 접속 무결성\n        * 복구 기능이 없는 접속 무결성\n        * 선택영역 접속 무결성\n        * 비접속 무결성\n        * 선택영역 비접속 무결성\n* 부인방지\n\t* 데이터의 발신자 혹은 수신자의 사실을 부인하지 못하도록 방지하는 서비스\n    * 발신 부인방지\n    * 수신 부인방지\n\n## 5. 네트워크 보안 메커니즘\n* 암호화\n\t* 프라이버시, 인증, 무결성 및 데이터에 대한 제한적 접근을 제공하는 강력한 수단\n    * 두 호스트 간 혹은 두 응용 시스템 간에 적용\n* 링크 암호화 메시지\n* 단대단 암호화 메시지\n* 전자서명\n\t* 서명: 서명자의 비밀정보인 공개키 암호 알고리즘의 개인키를 사용\n    * 검증: 서명자의 공개키를 사용하여 저옵를 보낸 사람이 누구인지 알아냄\n* 접근제어\n\t* 사용자의 접근 권한을 결정, 사용자에게 접근권한을 부여하기 위하여 사용자의 고유성, 정보 자격등을 이용\n    * 접근제어 정보, 패스워드, 자격, 보안 레이블, 접근 시도 시간 등\n* 데이터 무결성\n\t* 네트워크상에서 데이터의 정확성을 점검하는 메커니즘\n    * 송신자\n    \t* 메시지 인증 코드 (MAC)와 조작 점검 코드 (MDC) 등 사용\n\t* 수신자\n    \t* 수신한 데이터를 이용하여 무결성 정보 생성\n        * 수신한 무결성 정보와 비교하여 데이터의 변경여부 결정\n\t* 데이터 재사용을 막기 위해 타임스탬프 사용\n* 인증 교환\n\t* 패스워드 같은 단순한 신분 확인 정보부터 암호 기술까지 다양\n    * 대개 타임스탬프, 동기 클록, 2-방향 혹은 3-방향 핸드 셰이크, 부인방지 선택\n* 트래픽 패딩\n\t* 트래픽 흐름의 해석을 방지하기 위하여 다양한 수준의 보안을 제공\n* 라우팅 제어\n\t* 데이터에 대한 보안요구 충족시키기 위하여 물리적 논리적 전송 경로를 선택하는 메커니즘\n    * 서브네트워크, 릴레이 시스템, 링크 등을 사용\n    * 특정한 보안수준을 갖는 데이터는 보안 방침에 따라 서브네트워크\n* 공증\n\t* 통신중인 데이터의 무결성, 발신지, 목적지 등과 같은 특성을 보증하는 것\n    * 통신 실체들이 신뢰할수 있는 제3자에 의하여 이루어짐\n* 기타 보안 메커니즘\n\t* 신뢰기능\n    * 보안 레이블\n    * 이벤트 감지\n    * 보안감사 추적\n    * 보안 복구\n\n## 6. LAN 보안\n* LAN을 통하여 분산된 시스템을 효율적으로 이용\n* 정보의 내용변경, 불법유출, 순서변경, 바이러스 감염 등 위협\n* 물리계층, 데이터링크 계층과 연관\n* LLC 계층에서 전송되는 프로콜 데이터 단위(PDU)\n* SILS\n\t* LAN 환경에서의 정보보안 필요성이 증가함에 따라 IEEE에서 LAN의 정보보안을 위한 표준화 작업 수행\n   \t* 제공 서비스\n    \t* 데이터 발신처 인증, 기밀성, 비접속 무결성, 접속 제어\n\n## 7. TCP/IP 보안\n* TCP/IP, UDP, ICMP는 인터넷의 핵심적인 프로토콜\n* 애플리케이션, 트랜스포트/세션, 인터넷, 네트워크 액세스\n* IP를 위한 보안 메커니즘 제시\n\t* 두가지 프로토콜\n    \t* IP 인증 헤더: 송신자 인증\n        * IP 캡슐화 보안 페이로드: 송신자 인증 + 데이터 암호화\n* AH 프로토콜\n\t* 인증을 통해 IP 데이터그램의 무결성과 출처 보장\n    * 인증 데이터를 데이터그램 내의 헤더에 포함시킴\n* ESP 프로토콜\n\t* 암호화를 통해 기밀성도 보장\n    * ESP 헤더는 일반적으로 암호 데이터의 앞에 위치\n    * 불투명 전송 데이터는 암호 알고리즘의 처리에 관련된 추가적인 매개변수를 포함하는 보호 필드\n* SSL/TLS\n\t* 인터넷상의 TEXT기반 정보가 전송 중간단계에서 제3자에게 유출될 위험 존재\n    * SSL (Secure Socket Layer)\n    \t* 서버와 브라우저간의 통신을 위해 Netscape사에서 개발\n        * 애플리케이션 계층과 TCP 사이에 위치\n        * 애플리케이션 계층의 Telnet, FTP, HTTP 등의 프로토콜의 안정성 보장\n        * 서버 인증, 클라이언트 인증, 기밀성 보장\n\t* TLS (Transport Layer Security)\n    \t* SSL 3.0을 기반으로 한 업그레이드 프로토콜\n        \n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"컴퓨터보안 6강. 네트워크 보안","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-18T02:17:57.922Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"Rust로 작성된 언어를 wasm-pack으로 js로 빌드하기":{"id":105,"title":"Rust로 작성된 언어를 wasm-pack으로 js로 빌드하기","content":"# Rust로 작성된 언어를 wasm-pack으로 js로 빌드하기\n\n## 1. rust 및 wasm-pack 설치\n\n* 만약 아직 rust가 기기에 설치되어 있지 않다면, https://rustup.rs/ 에서 rustup을 사용하여 rust를 설치해준다.\n* https://rustwasm.github.io/wasm-pack/installer/ 링크를 참조하여 `wasm-pack` 을 기기에 설치해 준다.\n\n## 2. cargo를 사용하여 rust 템플릿 생성\n\n```bash\ncargo new --lib my-lib\n```\n\n위와같이 명령어를 실행하게 되면, my-lib이라는 이름의 rust 템플릿 디렉터리가 생성된다.\n\n## 3. Cargo.toml 작성\n\n```toml\n[package]\nname = \"<name>\"\nversion = \"<version>\"\nauthors = [<author>]\nedition = \"<year>\"\ndescription = \"<description>\"\n\n[lib]\ncrate-type = [\"cdylib\", \"rlib\"]\n\n[dependencies]\nwasm-bindgen = \"0.2.63\"\n```\n\nCargo.toml에 대한 자세한 정보는 https://rustwasm.github.io/docs/wasm-pack/tutorials/npm-browser-packages/template-deep-dive/cargo-toml.html 이쪽 링크를 참조하면 자세히 설명되어 있다.\n\n\n## 4. Javascript로 export 할 Rust 코드 작성\n\n`lib.rs`\n```rust\nextern crate wasm_bindgen;\n\n#[wasm_bindgen]\npub fn add(x: i32, y: i32) -> i32 {\n\tx + y\n}\n```\n\n위와 같이 wasm_bindgen을 이용하여 js로 export할 rust 함수를 만든다.\n\n```bash\nwasm-pack build\n```\n\nwasm-pack 을 사용하여 Build를 하게 되면 pkg 디렉터리가 생긴다.\n이곳에는 wasm_bindgen을 사용하여 작성한 코드들이 js 및 ts 파일로 생성된다.\n\n이것을 다음과 같이 js파일에서 import 할 수 있다.\n\n`package.json`\n```json\n...\n\"dependencies\": {\n  \"rust-wasm\": \"file:../pkg\",\n  ...\n},\n...\n```\n\n```js\nimport * as wasm from \"rust-wasm/rust_wasm\";\n\nalert(wasm.add(1, 2));\n\n```\n\n> 참고 자료\n[utilForever님의 rust-wasm-ts-template](https://github.com/utilForever/rust-wasm-ts-template)\n[wasm-pack 공식 문서 - 매뉴얼 셋업](https://rustwasm.github.io/docs/wasm-pack/tutorials/npm-browser-packages/getting-started/manual-setup.html)\n\n\n\n\n\n","thumbnail":"rust-logo-blk.png","excerpt":"Rust로 작성된 언어를 wasm-pack으로 js로 빌드하기","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-04-19T03:38:21.084Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[{"blogArticleTag":{"name":"rust"}},{"blogArticleTag":{"name":"web assembly"}},{"blogArticleTag":{"name":"wasm"}}]},"컴퓨터그래픽스 - 7강. 기하변환":{"id":106,"title":"컴퓨터그래픽스 - 7강. 기하변환","content":"# 컴퓨터그래픽스 - 7강. 기하변환 (1)\n\n## 기본 2차원 변환\n* 2차원 이동변환\n\t* x` = x + tx\n    * y` = y + ty\n    * 변환식: P` = P + T\n* 2차원 크기변환\n\t * x` = sx * x\n     * y` = sy * y\n     * 변환식: x` = sx*x + 0y\n     * 변환식: y` = 0x + sy*y\n* 원점을 기준으로 한 2차원 크기변환 \n* 임의 고정점을 기준으로 한 크기변환\n* 원점을 기준으로 한 회전변환\n\t* x = r * cosa\n    * y = r * sina\n    * x` = r * cos(a + pie) = r * cosa * cospie - r * sina * sinpie = x * cospie - y * sinpie\n    * y` = rsin(a + pie) = r * cosa * sinpie + r * sina * cospie = x * sinpie + y * cospie\n* 임의 고정점을 기준으로 한 회전 변환\n\n## 기본 2차원 기하변환 식\n* 이동변환\n* 크기변환 (원점 기준)\n* 회전변환 (원점 기준)\n\n## 동차 좌표계와 기본 2차원 변환 행렬\n* 동차좌표와 기하변환\n\t* 동차좌표\n    \t* n차원 투영공간을 n + 1개의 좌표로 나타내는 좌표계\n        * 2차원 동차좌표: (xh, yh, h), h != 0\n        * 0이 아닌 모든 h에 대해 (hx, hy, h)는 데카르트 좌표계상에서 하나의 좌표 (x, y)를 나타냄\n\t* 동차좌표계에서 기본 기하변환의 행렬 표현\n    \t* 기본 기하변환을 변환행렬과 좌표 벡터의 곱으로 표현할 수 있음\n        * 2차원 변환행렬은 3x3 행렬로 표현됨\n* 2차원 이동변환 행렬\n\t* 데카르트 좌표 표현 -> 동차 좌표 표현\n* 2차원 크기변환 행렬\n\t* 데카르트 좌표 표현 -> 동차 좌표 표현\n* 2차원 회전변환 행렬\n\t* 데카르트 좌표 표현 -> 동차 좌표 표현\n\n## 기본 2차원 기하변환의 동차좌표 변환식\n* 이동변환\n* 크기변환 (원점 기준)\n* 회전변환 (원점 기준)\n\n## 기본 3차원 변환\n* 3차원 이동변환 행렬\n\t* P = (x, y, z)\n    * P' = (x', y', z')\n    * T(tx, ty, tz)\n    * P' = T(tx, ty, tz)P\n* 3차원 크기변환 행렬\n* 회전축과 양의 회전 방향\n* z축 중심 회전변환\n\t* P' = Rz(pie)P\n* x축 중심 회전변환\n\t* P' = Rx(pie)P\n* y축 중심 회전변환\n\t* P' = Ry(pie)P\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"컴퓨터그래픽스 - 7강. 기하변환","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-07T11:51:05.029Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"모바일앱프로그래밍 - 6강. RelativeLayout":{"id":107,"title":"모바일앱프로그래밍 - 6강. RelativeLayout","content":"# 모바일앱프로그래밍 - 6강. RelativeLayout\n\n\n## 1. RelativeLayout의 속성\n* 위치 관계를 서로간의 상대적 속성으로 지정\n* 위젯에 대한 `id`를 지정\n* 상대적 위치가 지정되지 않으면, 자식 View의 기본위치는 좌측 상단\n* 리소스와 컴파일러의 관계\n\t* 특정 View가 다른 View의 위치에 종속적일때, 기준이 되는 View를 먼저 정의\n    * 화면상의 순서와 레이아웃상의 순서가 달라지기도 함\n* 배치상의 어려움\n\t* 여러 View사이의 관계를 정의하다 보면 대체되는 배치를 찾기 어렵거나 비효율적인 경우가 있다\n    * 화면상의 순서와 일치시키기 어려움\n    \n## 2. AbsoluteLayout\n* 좌표를 layout_x, layout_y로 지정\n\n## 3. FrameLayout\n* 자식 View를 배치하는 규칙이 따로 없다.\n* View는 FrameLayout의 좌측 상단에 나타남\n* 자식 View가 두개 이상 일 때에는 추가된 순서대로 겹쳐서 표시\n* ViewGroup의 서브클래스\n* foreground\n* foregroundGravity\n* measureAllChildren\n","thumbnail":"univ.jpg","excerpt":"모바일앱프로그래밍 - 6강. RelativeLayout","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-16T13:12:13.619Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"생활과건강 - 9강. 정신건강의 이해와 관리":{"id":108,"title":"생활과건강 - 9강. 정신건강의 이해와 관리","content":"# 생활과건강 - 9강. 정신건강의 이해와 관리\n\n## 1. 정신 건강의 의미\n* 인간은 하나의 유기체\n\t* 신체와 정신이 분리되어 있지 않고 긴밀한 연관성\n* 정상과 비정상\n\t* 정신질환으로 진단받지 않은 상태 또는 '평균'개념 적용\n    * 그 사회의 대다수 사람의 행동 양상에 걸맞은 행동을 할때 '정상'으로 규정\n* 정신건강\n\t* 단순히 정신질환이 없는 상태만을 의미하지 않으며\n    * 평균이나 다수를 표준으로 하거나 사회적응 능력만 가지고 판단할 수도 없음\n* 학자들의 정신건강 개념\n\t* 프로이트\n    \t* 정신 내적 생활에 초점\n        * 무의식적인 동기\n\t* 설리번\n    \t* 인간으로서의 효율성, 만족감\n\t* 프롬\n    \t* 인간과 사회적 환경의 관계에 초점\n\t* 메닝거\n    \t* 가장 효율적이고 행복\n\t* 매슬로\n    \t* 자아실현을 이룩한 사람\n* 보편적인 정신건강의 개념\t\n\t* 신체적 건강, 사회적환경의 영향, 정신적 성숙 포함\n    * 원활한 정신 활동\n    * 성숙한 인격\n    * 성숙한 감정\n    * 성숙한 마음을 포괄하는 의미\n* 인간 행위\n\t* 생각 감정 행동\n\n## 2. 정신 건강 평가 기준\n* 통합된 존재 (인간)\n* 삶의 전체적인 맥락에서 평가하는 것이 바람직\n* 단일기준으로 보지 않아야 함\n* 최소에서 최적 상태 까지 연속적\n* 측정하는 도구가 만들어져 이용되어야 함\n* 건강이나 병적 경향의 지침으로 생각되어야 함\n* 비교적 지속적인 속성을 평가하는 것이어야 함\n* 최소의 기준, 변경될 수 있어야 함\n* 마리 야호다의 정신건강 평가기준\n\t* 자신에 대한 태도\n    \t* 자신에 대한 긍정적 태도\n        * 현실적 객관적으로 평가\n        * 있는그대로의 나 적극적 수용\n\t* 성장 발달 그리고 자아실현\n    \t* 자신에 대한 수용 토대로 잠재력 개발 실현, 새로운 성장과 발달, 도전 할 수 있어야 함\n\t* 통합\n    \t* 내 외적 갈등, 억압과 표현, 충동이나 기분과 조절 간 균형\n        * 정서적 반응과 정서조절 및 통합된 삶의 철학 포함\n        * 통합 능력의 일부는 개인이 스트레스를 견디고 불안에 대처하는 능력으로 측정\n        * 강하고 융통성 있는 자아: 변화에 잘 대처하고 변화를 통해 성장\n\t* 자율성\n    \t* 스스로 판단하고 결정하며 조절하는 능력\n        * 자기결정, 독립과 의존 간 균형, 자기 행위로 인한 결과 수용\n        \t* 자신의 의사 결정, 행동, 사고, 감정에 대해 스스로 책임\n            * 다른 사람 삶의 자율성과 자유도 존중하게 됨\n\t* 현실 지각\n    \t* 현실 지각하는 능력\n        * 내 외적인 자극이 들어오면 이것을 어떻게 해석판단하고 어떤 의미로 받아들이는가\n        * 공감, 사회적 민감성, 타인의 감정과 태도에 대한 존중 포함\n\t* 환경에 대한 지배\n    \t* 사회에서 요구하는 역할에 성공적으로 기능\n\n## 3. 정신건강과 적응\n* 적응\n\t* 심리적 평형상태 유지하려는 과정\n    * 변화하는 환경에 자기를 맞추는 것, 혹은 적절치 못한 환경 개선 위해 노력하는 과정\n    * 자신의 신체와 정신상태에 대한 적응도 포함\n    * 자기를 맞추어 가면서 자기속도를 유지하는 것\n* 매슬로의 욕구계층 이론\n\t* 생리적 욕구\n    * 안전 욕구\n    * 존중과 인정의 욕구\n    * 사랑과 소속감의 욕구\n    * 자아실현 욕구\n    \t* 인간이 생활한 모든 면에서 어느 정도 만족한 상태에서\n        * 성취된 결과 수준, 성취 능력 등 포함\n\t* 생존적 경향, 실현적 경향\n* 신체적 변화, 환경의 변화, 내면의 변화 등 삶의 다양한 변화와 정신 건강\n\n## 4. 정신건강과 인간 관계\n* 인간\n\t* 복합적인 관계망 속에서 다양한 역할과 기능을 하며 살아감\n* 인간관계\n\t* 두 사람 혹은 그 이상의 사람들에게 일어나는 관계\n    * 다양, 역동적, 계속적인 상호작용의 복합적인 양상\n    * 전반적인 삶의 질을 좌우\n* 조직적 측면\n\t* 공식적 인간관계\n    \t* 직급, 직책 등 직업상 맺어지는 관계\n\t* 비공식적 인간관계\n* 본질적 측면\n\t* 만남의 관계\n    \t* 상호작용하는 참 만남의 관계\n    * 스침의 관계\n    \t* 피상적인 관계\n* 사회적 관계\n* 친밀한 관계\n* 치료적 관계\n* 사회 교환 이론\n\t* 보상, 대가\n    * 보상 > 대가: 관계에 대한 만족 커짐\n    * 보상: 곤계를 통해 얻는 이득\n    * 대가: 시간, 노력, 갈등, 불안, 불쾌한 기분 등\n    * 관계에서 얻은 결과를 평가\n    \t* 과거 경험\n        * 더 좋은 다른 대안\n        * 관계를 통제 가능한가 비교\n\t* 긍정적 평가: 관계가 지속\n    * 부정적 평가: 보다 긍정적을 모색\n* 역할 이론\n\t* 주어진 역할\n    * 서로에 대한 역할 기대가 다를 수 있음\n    * 서로에게 기대하는 역할이 무엇인지 분명히 인식하면 불협화음이 많이 해결될 수 있음\n* 상호교류분석 이론; E. Berne\n\t* 아동, 부모, 성인 세 가지 자아상태로 파악, 분석\n    * 특징적인 각 자아 상태가 특정 시간에 특정 방법으로 상호 교류\n\t* 아동 자아상태\n    \t* 직관적, 창의적, 호기심, 적대적, 비 협조적\n\t* 부모 자아상태\n    \t* 옳고 그름을 판단, 충고, 비판, 부드럽고 따뜻한 언어적 비언어적 행동\n\t* 성인 자아상태\n    \t* 성숙하고 현실지향적, 신중, 분석적, 이성적, 사무적\n\t* 성인 자아상태가 인격의 가장 많은 부분 차지\n    * 세가지 상태가 상황에 따라 적절히 기능할 수 있을 때 가장 건강한 형태\n* 성숙한 사람들의 인간관계의 특성\n\t* 인간관계에 대한 현실적인 욕구와 동기\n    * 인간 본성에 대한 깊은 이해와 관심, 인간관계의 다양성, 가변성에 대한 유연한 신념\n    * 상대방을 객관적이고 정확하게 지각, 판단하는 능력\n    * 대인관계에서 안정된 감정상태 유지\n* 효과적인 의사소통 기법\n\t* 관심 기울이기\n\t* 확인하기\n    * 공감하기\n    * 질문하기\n* 갈등 해결을 위한 기법\n\t* 갈등의 불가피성 인정\n    * 인정하는 태도\n    * 존중하는 태도\n    * 타협을 시도할 문제인지 아닌지 분별\n    * 문제와 감정을 분리, 기대를 명료하게 표현\n    * 시행착오와 실패의 가능성 인정, 포기하지 않기\n\t* 적극적 경청\n    * 나 전달법\n\n## 5. 정신 건강 관리\n* 정신건강을 지키기 위한 10대 수칙 (보건복지부)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 9강. 정신건강의 이해와 관리","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-30T03:51:07.169Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"정보통신망 - 7강. 데이터 통신의 기능(III)":{"id":109,"title":"정보통신망 - 7강. 데이터 통신의 기능(III)","content":"# 정보통신망 - 7강. 데이터 통신의 기능(III)\n\n## 흐름제어\n* 목적\n\t* 부 네트워크의 내부 환경에 관계없이 통신망의 성능을 유지\n    \t* 성능 향상\n        * 혼잡 방지\n* 관련이 깊은 통신 기능\n\t* 흐름 제어\n    * 혼잡 제어\n    * 오류 제어\n    * 경로 선택\n    * 접근 제어\n* 부 네트워크의 참조 모델\n\n### 목적별 통신 기능의 구분\n* 성능 향상\n* 혼잡 방지\n\n### 흐름제어 (flow control)\n* 송신 블록 수, 수신 블록 수, 통신 매체의 조절\n* 흐름 제어의 목적\n\t* 통신망 성능 최적화\n    * 혼잡 방지\n* 흐름제어의 네 가지 원칙\n\t* 속도 조절\n    \t* 블록 간의 도착 간격 변경\n        * ex) 감속 방법 (choke packet 이용)\n\t* 거부 (rejection)\n    \t* 송신 측에 대한 거부 상태 통지\n        * ex) 무시 방법 (송신측에 대한 거부), stop-and-go 방법 (송신 이전의 수신 거부)\n\t* 단일 승낙 (single permission)\n    \t* 매번 송신 허락을 받아야 함\n        * ex) ask-and-wait 방법, wait-before-go 방법\n\t* 다중 승낙 (multiple permission)\n    \t* 정해진 개수의 블록만 송신 가능\n        * ex) sliding window 방법\n\n### 혼잡 제어\n* 혼잡 현상\n\t* 전송 데이터의 급격한 증가로 인하여 통신망에 과부하\n    * 데이터 전송속도가 급감\n    * 전송 불가한 상태가 되는 경우\n* 단계적 발생 (과입력 전송 지역 -> 전체 부네트워크)\n\t* 버퍼 혼잡: 여러 버퍼들의 오버 플로우\n    * 노드 혼잡: 한 노드\n    * 국부 혼잡: 특정 노드들\n    * 전체 혼잡: 전체 부네트워크\n* 혼잡 제어 방법\n\t* 전송량의 제한\n    \t* 허가증을 이용하여 전송량을 일정 수준이하로 유지\n        * ex) Isarithmic 흐름제어 방법\n\t* 부네트워크 내의 부하 감소\n    \t* 어떤 패킷을 버림\n        * 흐름제어(거부원칙) 방법 이용\n\t* 국부적 전송량의 재분배\n    \t* 국부적인 체증 방지 및 국부적 과다 교통량 해소\n        * 경로 선택 방법 이용\n\n## 라우팅\n* 정의\n\t* 데이터 블록이 목적 노드로 전달되도록 출발 노드에서 목적 노드까지의 경로를 결정하는 기능\n* 목적\n\t* 네트워크 성능 최적화\n    * 임계값(경계조건)의 유지\n    \t* 평균 패킷 전송 시간의 최소화\n        * 네트워크 자원 활용도의 최대화\n\t* 네트워크 전부 또는 일부의 혼잡 방지\n    * 네트워크의 전송 신뢰도 증대\n\n### 라우팅 테이블 구조\n* 결정 노드\n* 목적 노드\n\n### 라우팅 방법의 분류\n* 비 적응적 라우팅\n\t* 랜덤 라우팅\n    \t* 다음 노드를 임의로 결정함\n        * 모든 경로는 동일한 확률로 선택 가능\n        * 루프(loop)는 허용되지 않음\n    * 플러딩 라우팅\n    \t* 블록이 들어온 노드만 제외한 모든 노드에 전송\n        * 매우 큰 트래픽 형성 가능\n    * 고정 라우팅\n    \t* 다음 노드가 일단 정해지면 환경이 변해도 유지\n        * 대표적 비적응적 경로 선택\n        * 고정 단일 경로 선택\n        \t* 다음 노드가 오직 하나 고정된 경우\n            * 범람 경로선택과 정반대\n            * 노드나 선로 고장의 경우 경로가 완전 차단\n\t\t* 고정 이중(다중) 경로 선택: by-pass link 첨가\n    \t* 단일 경로\n        * 이중 경로\n        \t* 두가지 경로\n            * 양자택일 경로\n        * 다중 경로\n        \t* 여러가지 선택 할 수 있는 경로\n* 적응적 라우팅\n\t* 국부적 경로 선택\n    \t* 라우팅 정보를 한 노드에서만 활용\n        * 다음 노드의 결정은 해당 노드에서 수행\n\t\t* hot potato 경로 선택\n        \t* 가장 짧은 큐를 가진 출력 선로를 선택하여 데이터 전송\n\t\t* 국부지연평가(local delay estimate)에 의한 경로 선택\n\t* 분산형 경로 선택\n    \t* 라우팅 정보를 인접 노드사이에서만 교환\n        * 각 노드에서는 제한된 크기의 전송지연표를 이용\n        * 목적 노드까지 전송지연이 최소가 되는 다음 노드를 결정\n        * 최소 지연 벡터는 주기적으로 갱신되며 인접 노드끼리 공유\n        * 변형\n        \t* 1차 인접 노드\n            * 1차, 2차 인접 노드\n            * 모든 다른 노드\n\t* 중앙 집중형 경로 선택\n    \t* Network Routing Center(NRC)\n        \t* 모든 노드는 경로선택에 관련 정보를 NRC에 제공\n            * NRC는 라우팅 벡터를 갱신하여 각 노드에게 제공\n\t\t* 분산형 경로 선택과 정반대\n        * 각 노드는 편리하나, NRC는 복잡함\n\t* 델타 경로 선택 (delta routing)\n    \t* 분산형 경로선택과 중앙집중형 경로 선택의 결합\n        \t* 인접 노드사이의 경로 선택 -> 분산형 경로선택\n            * 통신망 전체의 경로선택 -> 중앙 집중형 경로 선택\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"정보통신망 - 7강. 데이터 통신의 기능(III)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-05-28T08:54:15.268Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"정보통신망 - 6강. 데이터 통신의 기능(II)":{"id":110,"title":"정보통신망 - 6강. 데이터 통신의 기능(II)","content":"# 정보통신망 - 6강. 데이터 통신의 기능(II)\n\n## 1. 주소지정\n* 주소지정 (addressing)\n\t* 명명(naming), 식별(identification)\n    * 컴퓨터 통신망에서 사용자(컴퓨터, 파일 등)를 식별하는 방법\n    * 문자 또는 수를 이용\n* 주소 지정 방식의 분류\n\t* 계층의 수\n    \t* 단일 계층, 복수 계층\n\t* 부 네트워크가 제공하는 주소 서비스\n    \t* 물리 주소 및 논리 주소\n\t* 같은 주소를 갖는 지국의 수\n    \t* 단일 지국\n        * 복수 지국\n        \t* 복수 목적지 주소, 그룹 주소\n            * broadcasting 주소, flooding 주소\n\t* 주소할당 모드\n    \t* 정적 주소, 동적 주소\n* 물리주소\n\t* 데이터링크 계층에서 사용하는 MAC 주소\n    * 48 비트로 구성\n    * 콜론(:)으로 8비트씩 구분하여 6개의 16진수로 표현\n* 논리주소\n\t* 네트워크 계층에서 사용하는 IP주소\n    * 32 비트로 구성\n    * 점(.)으로 8비트씩 구분하여 4개의 10진수로 표현함\n\n\n## 2. 오류제어\n* 오류 (error)\n\t* 송신 데이터 != 수신 데이터\n    * 송신 데이터가 주어진 시간안에 수신츠겡 도착하지 못한 경우\n    * 오류 발생의 이유: 열, 자기장, 간섭, 고장 등\n* 잔류 오류율 (RER: Residual Error Rate)\n\t* 오류가 있는 비트(문자, 블록) 수 / 전송된 총 비트(문자, 블록) 수\n* 오류 제어\n\t* 잡음, 고장 등의 영향에 대비하여 잔류오류율(RER)을 주어진 한계 이내로 유지하는 통신 기능\n* 오류 제어 방식\n\t* 후진 오류 제어 (backward error control)\n    \t* 오류 검출 후 재전송 요청\n\t* 전진 오류 정정 (forward error correction)\n    \t* 오류 검출 및 수정\n* 오류 검출 방식\n\t* 패리티 검사\n    * 패리티 전략\n    \t* 홀수 패리티 전략 (odd parity)\n        * 짝수 패리티 전략 (even parity)\n\t* 단순 패리티 검사 (홀수 패리티 이용)\n\t\t* 동시에 짝수개의 비트오류가 있는 경우 오류 검출을 못함\n\t* 2차원 패리티 검사 (짝수 패리티 이용)\n    * 검사 합 (Check Sum)\n    \t* 검사합 생성 -> 검사합 검사\n\t* 검사합 생성기\n    \t* 데이터를 세그먼트로 분할\n        * 세그먼트들을 2진수로 간주하고 합함\n        * carry bit도 합함\n        * 합한 결과를 1의 보수로 만듦 (==> checksum)\n\t* 검사합 검사기\n    \t* 비트열을 수신하여 세그먼트로 분할\n        * 0010 + 0110 = 1000 -> 1의보수 -> 0111\n        * 0010 + 0110 + 0111 = 1111 -> 1의보수 -> 0000 (0이 아니면 오류가 있다)\n\t* 순환 잉여 검사 (CRC: Cyclic Redundancy Check)\n    \t* 패리티 검사: 문자 단위의 검사\n        * BCC 생성 과정\n        \t* 비트의 다항식 표현 ==> M(X)\n            * 생성 다항식 (G(X)) 에 의한 부호화\n\t\t\t\t* 모듈로 -2연산을 사용\n\t* 오류 검사 과정\n    \t* 수신된 BCC (F(X))를 이용한 오류 검사\n        \t* BCC를 동일한 생성다항식(G(X))로 나누어\n            \t* 나머지가 없으면 -> 오류 없음\n                * 나머지가 있으면 -> 오류 있음\n\t\t\t* 전송 데이터: 00001011\n            * M(X) = x^3 + x + 1\n            * 생성 다항식에 의한 부호화\n            \t* G(X) = X + 1\n                * m = 1\n\n## 3. 귀환 오류 제어\n* 오류제어\n\t* 전진 오류 정정\n    * 귀환 오류 제어\n* 귀환 오류 제어\n\t* 지국 사이의 역방향 채널을 이용하는 오류제어 방법\n    * 귀환오류제어의 분류 (오류검출 위치)\n* 결정 귀환\n\t* 오류 검출의 위치가 수신측에 있는 경우\n    * ARQ (Automatic Repetition reQuest)\n* 정보 귀환\n\t* 오류 검출의 위치가 송신측에 있는 경우\n* 복합 귀환\n\t* 오류율을 줄이기 위해 오류제어방법을 복합적으로 사용\n* ARQ\n\t* 정지대기 (Stop and Waiting) ARQ\n      * 1개의 데이터 프레임을 송신하고 기다림\n      * ACK를 수신하면 다음 프레임을 송신 후 기다림\n      * REJ를 수신하면 처음 프레임을 재송신후 기다림\n      * 대기시간을 초과하면 처음 프레임을 재송신후 기다림\n      * 특징\n          * 구현이 단순, 비용(버퍼)이 저렴\n          * 전송효율 떨어짐 (기다리는 시간)\n\t* 연속적 ARQ\n    \t* 여러개의 데이터 프레임을 송신하고 기다림\n        * Go-Back-N ARQ\n        \t* sliding window\n\t\t* Selective-Repeat ARQ\n        \t* REJ가 수신된 프레임만 재전송\n            * 전송 효율이 Go-Back-N ARQ보다 높음\n            * 프레임의 송수신 순서가 달라 재배열이 필요한 문제 등 복잡\n\t* 적응적(Adaptive) ARQ\n    \t* 프레임의 길이를 동적으로 변경시키는 방법\n        \t* 수신측은 통신오류 발생률을 송신측에 통보\n            * 송신측은 그에 적합한 프레임 길이로 전송함\n* 전진 오류 정정 (Forward Error Correction)\n\t* 수신측에서 오류 검출 및 정정까지 할수 있는 방식\n    * 연속적인 데이터 흐름이 필요하고 역방향 채널의 제공이 어려울 때 많이 사용\n    * 오류 정정 코드 전송\n    \t* 데이터 프레임에 잉여 비트를 추가하여 만듦\n        * 해밍(Hamming) 코드\n        * 리드-뮬러(Reed-Muller) 코드\n        * 리드-솔로몬(Reed-Solomon) 코드 등\n\t* 잉여 비트의 크기만큼 전송 효율이 떨어지는 단점\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"정보통신망 - 6강. 데이터 통신의 기능(II)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-24T07:01:18.383Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"타팀과의 면접에서 가장 많이 보는 것":{"id":111,"title":"개발자 2차 면접 후기 (타팀과의 면접)","content":"# 개발자 2차 면접 후기 (타팀과의 면접)\n\n2차면접은 두가지 종류가 있는 것으로 나는 경험했다.\n1. CTO 혹은 해당 회사의 개발직군의 \"장\"급과의 면접\n2. 타팀원과의 면접 (개발 직군이 아닌 다른 팀원들과의 면접)\n\n아무래도 타 팀과의 면접에서 가장 많이 보는 점은 다음과 같을 것 이다.\n1. \"협업\"을 우리와 잘 할 수 있는지\n2. fit의 적합성 (우리와 오래 함께 할 수 있는지)\n\n## 협업\n개발자도 물론이고, 스타트업에서 일하는 모든 직군은 대부분 혼자 일하지 않는다.\n한 회사의 목표점을 향해서 서로가 협업을 하면서 일하기 때문이다.\n물론 기업의 규모가 커지면 커질수록 자신의 분야에 전문성을 더 요구하게 되고, 자신의 직군에 속한 사람들과 많이 일을 하게 되긴 하지만 타팀과의 협업이 아예 없어지는 것은 아니다.\n\n개개인의 실력이 충분해도 이러한 협업 과정에서 어려움이 보인다면, 지원자를 최종 합격시키는 데에는 많은 의문사항이 들게 될 것이다.\n\n협업은 결국 서로 다른 시점을 가진 사람들이 자신의 의견을 제시하며 서로가 fit을 맞추며 일하는 과정이라고 생각 한다.\n한 사람만의 의견으로 모든 일을 진행해 나갈 수는 없는 법.\n서로의 도움과 협력이 밑받침 되어야 좋은 프로덕트가 나온다고 생각한다.\n\n협업을 잘한다는 것은 정답은 없는 것 같다.\n사람마다 일하는 방식이 맞을 수도, 다를 수도 있기 때문이다.\n하지만 가장 가까운 정답은 `서로 다른 사람들끼리 하나의 목표로 의견을 합치시키는 문화를 만드는 것` 이라고 생각한다.\n\n의견만 맞으면 사실 개개인의 능력이 출중하다면 남은 것은 개인의 분야에서 결과물을 내는 것 뿐이다.\n혼자서 일하는 것은 쉽다. 여럿이서 합을 맞춰 일하는 것은 정답이 없기 때문에 어렵다.\n\n협업에서 제일 중요한 점은 서로 다른 사람들끼리 의견을 존중하며, 하나의 목적을 향해서 합리적인 방향으로 의견을 합치시키는 것이 제일 중요할 것 같다.\n\n`따라서 너무 자신의 세계에 갖혀있어선 안된다.`\n\n## fit의 적합성\n\n사적으로도 fit이 맞는 사람들을 찾기란 힘들다.\n하지만 회사에서는 어느정도 프로세스라는 것이 존재하기 때문에, 그 프로세스에 fit을 맞춘다고 생각하면 쉬울 것 같다.\n\n내가 이 회사의 프로세스와 맞지 않다면, 나는 이 회사와 오래 함께하기 힘들 것이다.\n개인의 의견만으로 이미 잡혀진 프로세스나 문화가 바뀌긴 힘들다.\n\n하지만 직접 일을 해보기 전까지는 실제 프로세스를 경험해보기는 힘들다.\n따라서 나는 면접에서 프로세스를 설명해달라고 하지는 않는 편이다.\n대신 나와 같은 자리에서 면접관으로 참석하고 있는 사람들의 언어 습관이나 행동적인 면을 더 유심히 관찰하는 편이다.\n\n회사의 프로세스는 여러사람들이 일하는 가장 효율적인 방식대로 형성되기 마련이다.\n그 프로세스가 형성되는 주체는 결국 일하는 사람들이다.\n일하는 사람들이 어떤 생각을 가지고 있고, 어떤식으로 말을하고 어떤 언행과 행동을 하는지, 이런 사소한 부분이 사실 프로세스를 만드는 가장 기초적인 면이라고 생각한다.\n\n`프로세스는 결국 사람이 만든다. 그 사람의 인격과 행동을 유심히 관찰해보자.`\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"unsplash-programming.jpg","excerpt":"타팀과의 면접에서 가장 많이 보는 것","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-04-16T12:37:53.940Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"컴퓨터그래픽스 - 6강. 그래픽스 기본요소의 속성":{"id":112,"title":"컴퓨터그래픽스 - 6강. 그래픽스 기본요소의 속성","content":"# 컴퓨터그래픽스 - 6강. 그래픽스 기본요소의 속성\n\n## 1. 영역 채우기\n* 채우기 속성\n\t* 균일한 색\n    * 색 보간\n    * 패턴\n    * 텍스쳐\n* 영역의 정의\n\t* 다각형 경계\n    * 불규칙한 곡선 경계\n* 패턴 채우기\n  * 타일 붙이기\n      * 직사각형 배열 형태의 마스크로 패턴 정의\n      * 대상영역을 모두 채울 때 까지 수평 및 수직 방향으로 패턴을 반복적으로 복제\n  * 타일 붙이기의  기준  위치\n      * 윈도 원점 기준\n      * 도형의 경계상자 모서리 기준\n    \n## 2. 영역 채우기 알고리즘\n* 주사선 다각형 채우기\n\t* 홀-짝 규칙\n    * 픽셀 좌표와 픽셀 면적\n* 다각형 선분 테이블\n\t* 버킷\n    * 각각의 버킷에는 해당 주사선에 시작하는 선분들의 리스트가 연결됨\n\t* 선분의 항목에 저장되는 내용\n* 활동 선분 목록\n* 불규칙한 경계로 정의되는 영역 채우기\n\t* 영역 채우기 알고리즘의 종류\n\t\t* 시작점\n        * 빨간 경계 영역 채우기\n        \t* 경계선 채우기 알고리즘\n        * 백색 영역 채우기\n        \t* 범람 채우기 알고리즘\n* 연결된 이웃의 정의\n\t* 4방향 연결\n    * 8방향 연결\n* 경계선 채우기 알고리즘\n\n```c\nvoid boundary4Fill(int x, int y, int fCol, int bCol) {\n  int intCol;\n  intCol = getPixel(x, y); // x , y 위치의 픽셀 색을 읽음\n  // 경계선 색이나 채우기 색이 아닌 경우\n  if (intCol != bCol && intCol != fCol) {\n    setPixel(x, y, fCol); // 현재 위치를 채우기 색으로 그림\n\t// 4방향 연결성에 따라 이웃 픽셀에 경계선 채우기를 적용\n    boundary4Fill(x + 1, y, fCol, bCol);\n    boundary4Fill(x - 1, y, fCol, bCol);\n    boundary4Fill(x, y + 1, fCol, bCol);\n    boundary4Fill(x, y - 1, fCol, bCol);\n  }\n}\n```\n* 범람 채우기 알고리즘\n\t* 동일한 색 영역을 지정된 채우기 속성에 따라 채움\n\n```c\n// x, y 픽셀 좌표, fCol: 채우기 색, bCol: 내부 색\nvoid flood4Fill(int x, int y, int fCol, int intCol) {\n  int currCol;\n  currCol = getPixel(x, y);\n  if (currCol == intCol) {\n    setPixel(x, y, fCol);\n    flood4Fill(x + 1, y, fCol, intCol);\n    flood4Fill(x - 1, y, fCol, intCol);\n    flood4Fill(x, y + 1, fCol, intCol);\n    flood4Fill(x, y - 1, fCol, intCol);\n  }\n}\n```\n\n## 3. 안티 에일리어싱\n* 에일리어싱의 개념\n\t* 낮은 해상도로 인한 정보의 왜곡\n    * 표본화 (sampling)\n* 안티 에일리어싱 기법\n\t* 전 필터링 (prefiltering)\n    \t* 물체가 차지하는 픽셀 면적을 기준으로 픽셀 밝기를 조절하는 방법\n        * 영역 샘플링 (area sampling) 이라고 함\n\t* 슈퍼 샘플링\n\t\t* 하나의 픽셀을 여러 개의 작은 픽셀로 분할\n        * 물체 영역이 차지하는 서브픽셀의 수에 따라 픽셀 색 결정\n\t* 후 필터링 (postfiltering)\n    \t* 이웃 샘플들의 가중치 평균으로 픽셀 값을 결정\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"컴퓨터그래픽스 - 6강. 그래픽스 기본요소의 속성","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-16T12:06:41.567Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"생활과건강 - 5강. 신체건강 문제와 관리(4)":{"id":113,"title":"생활과건강 - 5강. 신체건강 문제와 관리(4)","content":"# 생활과건강 - 5강. 신체건강 문제와 관리(4)\n\n## 내분비계\n* 호르몬을 직접 혈액내로 분비하는 조직\n* 내분비선\n* 호르몬\n\n## 내분비계 건강문제\n###  1. 당뇨병\n* 가장 흔한 내분비계 질환\n* 인슐린 결핌에 의해 혈당을 상승시키고 지방 및 단백질 대사에 이상을 동반하는 당질 대사장애\n* 인슐린 부족 -> 혈중 포도당 농도 상승 -> 신장에서 포당 재흡수 하지 못함\n* 판정 기준\n    * 혈당 검사\n    * 표준 포도당 부하 검사\n    * 당화혈색소\n* 유형과 원인\n    * 제 1형 당뇨\n        * 전체 당뇨 황자의 10%이내를 차지\n        * 30세 이전에 발병하는 특징 (소아당뇨)\n        * 인슐린을  분비하는 췌장의 베타세포가 파괴되어 발생함\n    * 제 2형 당뇨\n        * 다른 질환에 의해 2차적으로 당뇨병이 생기는 경우\n        * 인슐린 저항성 때문 (혈당을 낮추는 인슐린 기능이 떨어져 세포가 포도당을 효과적으로 연소하지 못하는 것)\n    * 기타 임신 당뇨병 등\n* 증상\n    * 다음, 다뇨, 다식\n    * 전신 피로감, 종기, 상처치유장애, 피부건조, 시력장애, 식곤증, 체중감소, 손발 감각변화 등\n* 합병증\n    * 급성\n        * 저혈당\n            * 인슐린이나 먹는 당뇨약을 쓰는 사람이 너무 많이 약을 쓰는 경우\n            * 소량의 식사, 무리한운동\n        * 당뇨병성 혼수\n            * 고혈당 상태가 지속되면 세포는 연료부족을 해결하기 위해 체내에 축적되어 있는 지방 분해\n            * 그 과정에서 케톤체가 생성되면서 당뇨성 케톤산증을 초래하기도 함\n        * 감염\n    * 만성\n        * 대혈관 합병증\n            * 심장과 뇌에 혈액을 공급하는 동맥의 경화로 인해 협심증, 심근경색증, 뇌졸중이 나타나고 고혈압도 초래됨\n        * 당뇨병성 망막증\n            * 카메라의 필름에 해당하는 눈의 망막이 손상되어 심한 경우 눈이 멀게 됨\n        * 당뇨병성 신증\n        * 당뇨병성 신경병증\n        * 발의 괴저\n* 예방\n    * 유산소운동, 복부비만 관리, 가족려 확인\n\n### 2. 비만\n* 원인\n\t* 유전적 요인\n    * 환경적 요인\n    * 심리적 요인\n* 유형\n\t* 지방세포 증식형\n    \t* 소아비만\n\t* 지방세포 비대형\n    \t* 성인기  이에 비만하게 된 것\n* 비만도 판정\n\t* 체중-신장수\n    * 체질량 지수 (BMI)\n\n### 3. 근 골격계 건강 문제\n* 근골격계\n\t* 뼈, 근육, 연골, 인대, 관절\n    * 골격근\n    \t* 뼈와 연결된 근육\n* 골다공증\n\t* 골 소실이 골 형성보다 증가하여 골량이 전체적으로 감소, 뼈에 구멍이 생기고 쉽게 골절을 일으키는 질환\n    * 원인\n    \t* 퇴행성 골소실\n        * 여성의 경우 폐경이 되면 여성호르몬(에스트로겐)의 감소로 골소실 속도가 급격히 빨라짐\n\t* 증상\n    \t* 골절이 발생할 때까지 증상이 없는 경우가 많음\n    \t* 키의 감소\n        * 척추의 국소적 압통\n        * 복부돌출 등\n\t* 예방\n    \t* 체내에 최대 골량을 증가\n        * 골소실 시작 지연\n        * 고칼슘 음식을 충분히 섭취\n\t* 치료\n    \t* 약물 투여 및 칼슘의 섭취 증가\n        * 칼시토닌\n        * 알란드로네이트\n* 퇴행성 관절염\n\t* 관절을 보호하고있는 연골이 서서히 손상되거나, 퇴행성 변화로 관절 주위의 뼈와 인대가 손상되어 염증과 통증이 생기는 질환. 염증성 관절 질환 중 가장 많이 발생\n\t* 원인\n    \t* 일차성 관절염\n        * 이차성 관절염\n* 통풍\n\t* 관절염의 일종으로 바람만 스쳐도 아플정도로 통증이 심한 질환\n\t* 남자가 여자보다 약 20배 정도 발병률이 높음\n    * 단백질인 퓨린의 신진대사 장애 -> 요상이 과잉공급\n    * 배설장애 -> 혈중 요산농도가 높아짐\n    * 약물로써는 콜키신을 투여\n    * 식이요법: 퓨린이 적은 음식 섭취\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 5강. 신체건강 문제와 관리(4)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-14T02:16:39.220Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"소프트웨어공학 - 5강. 소프트웨어 테스트":{"id":114,"title":"소프트웨어공학 - 5강. 소프트웨어 테스트","content":"# 소프트웨어공학 - 5강. 소프트웨어 테스트\n* 소프트웨어 테스트: 소프트웨어 품질 보증을 위한 활동\n\t* V&V 활동의 하나\n* 요구사항의 만족을 보이거나 결함을 찾기 위한 활동\n* 오류를 찾기 위한 것, 오류가 없음을 증명하는 것이 아님\n* 결함 테스트\n\t* 소규모 코드에서 결함을 찾고자 하는 것\n* 검증 테스트\n\t* 주요 시스템의 기능을 검증하기 위한 것\n    * 인수테스트와 같은 고수준 테스트\n\n\n## 테스트 작업의 원칙\n* 입력 값 외에 결과 값을 포함해야 함\n* 프로그래밍 조직 자체적 테스트 하지 말 것\n* 자신이 작성한 프로그램을 스스로 테스트 하지 말 것\n* 테스트케이스를 버리지 말고 재사용할 것\n\n## 테스트 프로세스\n* 테스트 케이스의 설계\n* 테스트 데이터의 준비\n* 테스트 데이터를 가지고 실행\n* 결과와 테스트 케이스 비교\n* 고려 사항\n\t* 전체 시스템 테스트 > 모듈 하나 보다 중요\n\n## 단위 테스트\n* 시스템을 구성하는 기본 단위를 테스트\n\t* 결함 발견을 위해 개별적 모듈을 독립적으로 확인하는 작업\n* 드라이버와 스텁을 사용\n\t* 드라이버: 테스트되는 모듈 호출, 결과를 출력해주는 프로그램\n    * 스텁: 테스트되는 모듈에 의해 호출되는 모듈\n\n## 통합 테스트\n* 개별 모듈들을 통합하여 상호작용으로 인한 문제가 있는지 테스트\n* 모듈 간의 인터페이스를 검사할 목적으로 개발됨\n* 프로그램을 구축해 가는 기술 / 최종적으로 시스템이 구축됨\n* 주로 블랙박스 테스트 기법을 사용\n\n## 시스템 통합 방식\n* 빅뱅 통합\n\t* 모듈들을 모두 개발한 후 한꺼번에 통합\n* 점증적 통합\n\t* 모듈을 하나씩 추가하여 통합한후 테스트함\n* 하향식 통합\n\t* 점증적 통합방식\n    * 최상위 모듈부터 시작하여 아래 모듈들을 차례로 통합시킴\n    * 하위모듈에 대해 스텁이 필요\n    * 깊이 우선 방식과 너비 우선 방식\n* 장단점\n\t* 초기에 소프트웨어 구조가 갖추어지고 개발자에게 심리적으로 안정감을 줌\n    * 병행작업이 어렵고 입출력 모듈이 하위에 위치, 테스트작업이 어려움\n* 하향식 통합 (깊이 우선) 과 상향식 통합 (오른쪽)\n* 상향식 통합\n\t* 최하위 -> 상위 통합과 테스트\n    * 클러스터: 하위 모듈 통합\n    * 드라이버: 통합되는 모듈 제어\n    \n## 테스트 방식\n* 샌드위치 테스트\n\t* 상향식과 하향식을 조합한 방식\n    * 회귀 테스트\n    \t* 프로그램 수정시 수정으로 인한 오류의 발생 여부를 밝히기 위한 테스트 방법\n* 시스템 테스트\n\t* 완전한 시스템이 구축되었는지 검증하기 위한 테스트\n    * 블랙박스 테스트 작업 수행\n    * 성능이나 신뢰도를 테스트 할 수 있음\n    * 릴리즈 테스트라고도 하며, 테스트 작업에 고객이 포함되면 인수 테스트가 됨\n* 화이트박스 테스트\n\t* 논리구조에 바탕을 둔 테스트\n    * 구조 테스트\n    * 프로그램 구현 사항을 알아야 함\n    * 제어흐름 그래프에서 경로를 분석하여 테스트 케이스 개발\n    * 소규모의 프로그램에 적용\n    * 자동화된 테스트 도구를 사용할 수 있음\n\t* 코드 커버리지\n    \t* 화이트박스 테스트에서 효과적인 테스트 케이스의 집합을 구하는 기준\n        * 모든 가능한 실행 경로를 테스트할 수 없으므로, 적정 수의 테스트 경로를 실행해야 함\n        * 문장 검증 기준 (SC)\n        * 분기 검증 기준 (DC)\n\t\t* 조건 검증 기준 (CC)\n        * 조건 분기 검증 기준 (CDC)\n    \t* 수정된 조건 분기 검증 기준 (MCDC)\n        * 복수 조건 검증 기준 (MCC)\n* 경로 검증 기준\n\t* 프로그램에 존재하는 모든 실행 가능한 경로를 한번 이상 테스트\n    * 반복 문장이 있다면 실행 가능한 경로의 수는 무한대 이므로 사실상 불가능\n* 기본 경로 테스트\n\t* 시작 노드에서 종료 노드까지의 선형 독립적인 경로 (기본경로)를 모두 테스트\n    * 매케이브의 사이클로매틱 수는 기본 경로의 개수와 일치함\n* 블랙박스 테스트\n\t* 명세서에 기초하여 기능을 검사하기 위한 테스트 데이터를 개발\n    * 기능적요구사항 검사 가능, 오류를 일으킬 가능성이 높은 입력 조건을 파악해야 함\n    * 완전 테스트\n    * 랜덤 테스트\n    * 동치 분할\n    * 경계값 분석\n    \t* 동치 분할 방법의 변형, 동치클래스 정의 후 경계값과 경계값 직전/직후 값을 가지고 테스트\n\t* 원인 결과 그래프\n\n## 비기능성 테스트와 성능 테스트\n* 비 기능성 테스트\n\t* 기능적 요구사항 이외의 것을 테스트\n* 성능 테스트\n\t* 평균 응답 시간, 시간당 처리율, 피크시간의 성능 검사\n\t* 부하테스트\n    \t* 비 정상적인 높은 부하를 주고, 관찰하여 잘못된 점을 발견 (스트레스 테스트)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ","thumbnail":"univ.jpg","excerpt":"소프트웨어공학 - 5강. 소프트웨어 테스트","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-13T01:46:25.613Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"정보통신망 - 5강. 데이터 통신의 기능(I)":{"id":115,"title":"정보통신망 - 5강. 데이터 통신의 기능(I)","content":"# 정보통신망 - 5강. 데이터 통신의 기능(I)\n\n## 데이터 교환 방식\n* 회선교환\n\t* 회선 (circuit): 설정된 통신 경로의 집합\n    * 연결 지향형 데이터 전송 (connection-oriented transmission)\n    \t1. 연결 설정\n        2. 데이터 전송\n        3. 연결 해제\n\t* 비 연결형 전송 (connectionless)\n    * 연결 설정 후 회선을 전용선처럼 사용하므로, 대량의 실시간 데이터 전송에 적합\n* 메시지교환\n\t* 전송 데이터 크기 그대로 전송\n    * 전용선 불필요하지만 헤더(`목적지 주소`)가 필요\n    * 목적지 주소 (Header)\n    \t* 발신 주소\n        * 수신 주소\n\t* Store-and-forward 방식 (**저장후 전송**)\n    \t* 각 노드는 기억장치를 갖춘 컴퓨터\n        * 각 노드에서는 데이터를 수신 후 잠시 저장하면서 적절한 선로를 찾아 전송함\n        * 대용량 데이터 전송에 적합\n        * 전송 지연이 길어서 실시간 서비스에는 부적절함\n\t* 장점\n    \t* 메시지를 분할하고 재조립 과정이 불필요\n        * 메시지 교환은 메시지의 분할 없이 전송하므로 헤더 오버헤드가 패킷 교환보다 훨씬 적다\n\t* 단점\n    \t* 보조기억장치까지 사용하게 되어 패킷교환에 비해 더 많은 전송 시간이 소요됨\n        * 전송시 오류 발생시 전체 메시지를 폐기하고 재전송해야 하므로 대역폭의 낭비가 발생\n* 패킷교환\n\t* 전송 데이터를 일정의 크기로 분할하여 전송\n    * Packet: 보통 128 바이트\n    * PDU (protocol data unit)\n    \t* bit / symbol\n        * frame\n        * packet / datagram\n        * segment\n\t * 주기억장치만 활용, 전송지연 줄일수 있다.\n     * vs 메시지교환방식 (보조기억장치 사용경우 발생, 전송지연이 크다)\n     * 패킷마다 헤더 필요 (오버헤드 발생)\n     * 데이터그램(datagram) 방식\n     \t* 비연결형 (connectionless) 전송: 연결 없이 전송\n        \t* 시간이 빠르다\n            * 나중에 재조립 해야한다\n\t* 가상회선 (virtual circuit) 방식\n    \t* 연결지향형 전송 (회선교환과 유사)\n* 교환방식의 비교 \n\t* 연결지향형\n    \t* 회선교환\n        * 가상회선 패킷 교환\n\t* 비연결형\n    \t* 메시지 교환\n        * 데이터그램 패킷 교환\n\t* 대용량 데이터 전송\n\t\t* 회선교환\n        * 메시지교환\n\t* 실시간 소용량 데이터 전송\n    \t* 데이터그램 패킷 교환\n        * 가상회선 패킷 교환\n\n## 다중화\n* 정의(multiplexing [muxing]) 의 정의\n\t* 원격 통신 및 컴퓨터 통신망에서 복수개의 신호를 하나의 매체에서 사용할수 있도록 하나의 신호로 결합하는 방법\n* 목적\n\t* 정보통신 자원인 전송 매체의 공유\n* 사례\n\t* 전화망, TV, 라디오 방송망\n* 종류\n\t* 시분할 다중화 (TDM: Time Division Multiplexing)\n    \t* 매체 사용권을 `분할된 시간 (Time Slot)`으로 제공\n    * 주파수 분할 다중화 (FDM: Frequency Division Multiplexing)\n    \t* 매체 사용권을 `분할된 주파수 대역`으로 제공\n        * 여러개의 낮은 속도의 데이터를 각각 다른 반송파 주파수에 변조하여 통신선로에 보내는 방식\n\t\t* 라디오 방송\n\t* 파장분할 다중화 방식 (WDM: Wavelength Division Multiplexing)\n    \t* 광통신에서의 다중화로써 FDM과 개념적으로 같음\n        * 즉 서로다른 wavelength를 사용하여 다중화 함 (color)\n\n## 동기화의 정의 및 목적\n* 동기화\n\t* 송수신자가 서로 동일한 속도로 데이터를 송수신하도록 해주는 데이터 통신 기능\n    * 비트 펄스에 대해 정확한 표본화 위치를 찾는 기술\n    * 송수신자 사이에 데이터를 송수신하는 시점을 일치시킴\n* 동기화 기능의 필요성\n\t* 작은 회로망 내부\n    \t* 발진된 하나의 주파수로 회로 전체의 소자들이 동기화되기 용이함\n\t* 정보통신망\n    \t* 원격의 송수신기 사이의 동기가 어려움\n        * 동기화 기술이 필요\n* 동기화 방법\n\t* 비트동기 (bit synchronization)\n    \t* 두 지국이 독립된 각자의 클록을 가지고 있는 경우\n        * 한지국만 클록을 가지고 있는 경우\n        * 두지국이 각자 클록을 가지고 있으나, 종속지국이 초기 몇비트 동안만 제어지국의 클록을 사용하여 동기화 시키고 그 이후에는 자신의 클록을 사용\n    * 문자동기 (character synchronization)\n    * 프로세스 동기\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"정보통신망 - 5강. 데이터 통신의 기능(I)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-13T03:42:48.003Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"모바일앱프로그래밍 5강. LinearLayout":{"id":116,"title":"모바일앱프로그래밍 5강. LinearLayout","content":"# 모바일앱프로그래밍 5강. LinearLayout\n\n## LinearyLayout의 속성 (1)\n* 자식 View를 일렬로 배치하는 부모 View (레이아웃)\n* XML 문서에 나타내는 순서대로 View가 배치됨\n* 자식 View를 일렬로 배열하는 방법은 수평 정렬과 수직 정렬이 있음\n* orientation 속성\n\t* vertical 값은 자식 뷰를 위에서 아래로 수직으로 배열\n    * horizontal 값은 자식 뷰를 왼쪽에서 오른쪽으로 수평 배열\n    * `setOrientation(int)` 메서드\n    \t* horizontal: 0\n        * vertical: 1\n\n```xml\n<LinearLayout\n\tandroid:orientation=\"horizontal | vertical\"\n>\n  ...\n</LinearLayout>\n```\n* baselineAligned 속성\n\t* 높이가 다른 자식 뷰를 수평으로 나란히 배치할 때\n    * `setBaselineAligned(Boolean)`\n    * 수직 레이아웃에 대해서는 의미가 없음\n    \n```xml\n<LinearLayout\n\tandroid:baselineAligned=\"true | false\"\n>\n  ...\n</LinearLayout>\n```\n\n## TextView의 속성\n* gravity 속성\n\t* 뷰의 안쪽에 배치되는 내용물을 배치하는 방식을 결정하는 속성\n    * 수평 / 수직 방향에 대해 정렬방식을 지정 할 수 있다.\n    * `|` 연산자로 두 속성을 묶어서 지정할 수 있음\n\t* center = center_horizontal | center_vertical\n\n\n## LinearLayout의 속성 (2)\n* layout_gravity\n\t* gravity: 뷰안의 내용물의 배치장소 지정\n    * layout_gravity: 뷰를 부모 뷰의 어디에 배치할 것인가를 결정\n    * 속성값의 종류는 gravity와 동일\n\n## LinearLayout의 속성 (3)\n* layout_weight 속성\n\t* 부모 뷰의 영역을 자식 뷰들이 얼마나 차지할 것인가를 결정하는 비율값\n    * 속성값이 0 이면 자신의 고유한 크기만큼 차지\n    * 속성값이 1 이면 형제뷰와의 비율에 따라 부모 뷰의 영역이 배분됨","thumbnail":"univ.jpg","excerpt":"모바일앱프로그래밍 5강. LinearLayout","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-12T12:47:56.914Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"컴퓨터보안 - 5강. 서버 보안":{"id":117,"title":"컴퓨터보안 - 5강. 서버 보안","content":"# 컴퓨터보안 - 5강. 서버 보안\n\n## 서버 보안의 개요\n* 서버: 서비스를 제공하는 컴퓨터\n* 클라이언트: 서버에 접근하여 서비스를 제공받는 컴퓨터\n* 통신 채널: 인터넷\n* 서버 / 클라이언트 구조\n\t* 클라이언트\n    \t* 응용 프로그램\n        * 운영체제\n        * 트래픽 제어, 암호화\n\t* 서버\n    \t* 응용 프로그램\n        * 운영체제\n        * 트래픽 제어, 암호화\n\t* 인터넷을 통해 클라이언트와 서버가 통신\n* 인터넷 공격에 대한 방어 지점\n\t* 응용 프로그램 계층\n    \t* 서버 응용 프로그램의 백도어, 버그 (취약성)\n        * 취약성을 이용하여 운영체제에 대한 접근 권한 획득\n    * 운영체제 계층\n    \t* 보안의 가장 근본적 레벨\n        * 대부분의 공격 목적은 운영체제의 제어권 확보하는 것\n    * 네트워크 제어\n    \t* 시스템의 In / Out 트래픽을 제어\n        * 운영체제 내에서 수행 가능. 별도 독립된 장비에서도 수행 가능.\n    * 전송 데이터 제어\n    \t* 인터넷을 통하여 전송되는 정보는 누구나 열람 가능\n        * 데이터 절도를 방지하려면 전송자는 암호화하여 정보를 전송한 뒤 수신자 쪽에서 복호화 하여 확인하는것이 바람직\n\n\n## 서버의 침임 및 정보 유출 단계\n* 정보 획득 단계\n\t* 공격대상 시스템 설정\n* 권한 획득 단계\n\t* 일반 사용자 권한 획득 후\n    * 관리자 권한 획득 (!): 궁극적인 목적 (Root 권한 취득)\n* 공격 단계\n\t* 침입 흔적 지움\n    * 백도어 설치\n* 재 침임 단계\n\t* 다른 시스템 공격\n    * 정보 변경 또는 유출\n    * 다른 비권한 행위 수행\n\n## 서버 공격 유형\n* 결함을 통해서 보안 허점 활용\n* 서버 공격 유형\n\t* 계정 크랙 공격\n    * 네트워크 공격\n    * 시스템 취약점 이용 공격\n    * 사회 공학적인 공격\n    * 응용 프로그램 취약적을 이용한 공격\n    * 웹 서버 취약점을 이용한 공격\n* 계정 크랙 공격\n\t* 무차별 공격 (Brute Force Attack)\n    \t* 시스템 또는 서비스의 ID, 패스워드를 자동 조합하여 크랙하는 공격\n\t* 사전 공격 (Dictionary Attack)\n    \t* ID와 패스워드가 될 가능성이 있는 단어를 사전 파일로 만들어 놓고 사전 파일의 단어를 대입하여 크랙하는 공격\n* 시스템의 취약점을 이용한 공격\n\t* 버퍼 오버플로우 공격\n    \t* Buffer Overflow\n        * Buffer의 양을 초과하는 데이터를 입력\n        * 프로그램의 복귀 주소를 조작함으로써 공격자가 원하는 코드를 실행하는 것\n        * Stack Overflow 공격과 Heap Overflow 공격 존재\n    * 레이스 컨디션 공격\n    \t* 프로세스 경쟁을 이용한 공격\n        * 경쟁상태에 이르게 하여 시스템 프로그램이 갖는 권한으로 파일에 접근하게 하는 방법\n    * 기본 설정오류를 이용한 공격\n    \t* 잘못된 시스템 설정에 대한 공격\n\n\n## 서버 보안 대책\n* 계정 관리\n\t* 사용자별 또는 그룹별 접근 권한 부여\n    * 불필요한 사용자 계정 삭제\n    * 루트권한에 대한 사용 제한\n    * 새로운 사용자 추가 시 일관성 있는 정책 유지\n* 패스워드 관리\n\t* 패스워드를 생성할 때에 여러 조합을 사용\n    * 유추가능한 단어를 패스워드로 사용 지양\n\t* Shadow 패스워드 사용\n    \t* UNIX /etc/passwd 는 일반 사용자의 접근이 가능\n        * /etc/shadow 라는 파일에 /etc/passwd의 패스워드 필드를 암호화하여 저장하고 루트만 읽을 수 있는 권한으로 설정\n* 파일 접근 권한 (read/write/execute) 관리\n* 파일 암호화\n* 파일 시스템 백업 및 복구\n* 무결성 점검 도구를 이용한 파일 시스템의 위변조 검사\n* UNIX 계열\n\t* mount 테이블을 이용한 파일시스템 관리\n    * TCP-wrapper, xinetd 등을 이용한 호스트 접근제어 관리\n    * telnet 대신 ssh 사용 등\n* 윈도우\n\t* NTFS에 대한 사용권한 설정\n    * 레지스트리 원격 액세스 권한 제한 및 레지스트리 백업\n* 접근제어 목록 (ACL: Access Control List) 설정\n* 접근제어 정책\n\t* 임의적 접근제어\n    \t* 개별 소유자의 자율적 판단에 따라 접근 권한을 사용자들에게 부여\n\t* 강제적 접근제어\n    \t* 개별객체에는 비밀 등급을, 사용자에게는 허가등급을 부여\n        * 사용자가 객체에 접근할때마다 사전에 정해진 규칙과 비교하여 일치하는 사용자에게만 권한 부여\n\t* 역할기반 접근제어\n    \t* 권한은 역할과 관계\n        * 예: 운영자 역할은 모든 자원에 접근 가능 하나 접근권한을 바꾸지는 못함\n* UNIX 계열의 접근제어 명령어 - chmod, chown\n* 시스템 파티션 분리 (작업용도에 따라)\n* 불필요한 서비스 중지 및 프로그램 제거\n* 자원관리 최적화\n* 최소권한의 프로세스 수행\n* 시스템 로그 설정과 관리\n\t* UNIX - syslog를 통하여 시스템 로그 설정\n\t* 윈도우 - 이벤트 뷰어를 통해 시스템 로그 관리\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"컴퓨터보안 - 5강. 서버 보안","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-12T14:34:02.405Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"컴퓨터그래픽스 - 5강. 그래픽스 기본요소의 속성 (1)":{"id":118,"title":"컴퓨터그래픽스 - 5강. 그래픽스 기본요소의 속성 (1)","content":"# 컴퓨터그래픽스 - 5강. 그래픽스 기본요소의 속성 (1)\n\n## 색 모델\n* 가시광선\n\t* 사람의 눈으로 볼수 있는 일정 주파수 범위의 전자기파\n* 색의 성질\n\t* 색의 3요소\n    \t* 색조: 빛의 색을 결정하는 요소\n        \t* 지배 주파수에 해당되는 색 성분\n        * 채도: 색이 순수한 스펙트럼 색에 얼마나 가까운가를 나타내는 요소\n        \t* Ep - Ew가 클수록 채도가 높음\n        * 명도: 빛의 전체적인 에너지 크기에 해당되는 요소\n* 원색 (primary colors)\n\t* 삼원 자극 이론 (tri-stimulus theory)\n    \t* 원추세포: 사람의 시각세포 중 색을 감지하는 역할을 함\n\t\t* 두 빛에 감지되는 r, g, b의 양이 서로 같다면 색을 구성하는 주파수 성분이 다르더라도 같은 색으로 인지될 수 있음\n    * 색 합성을 위한 원색\n\t\t* R, G, B의 세가지 파장의 빛을 혼합하여 색을 표현\n\t* 색 정합 실험\n    * CIE XYZ 색 모델\n    \t* 인간의 시각 특성에 맞게 정의된 X, Y, Z라는 가상 표준의 원색\n\t\t* X, Y, Z는 각각 R, G, B에 해당\n\t\t* Y는 밝기값이 되도록 설계\n        * X, Y, Z는 가상 원색을 혼합하여 평균적인 인간의 눈에 보이는 모든 색 표현 가능\n\t\t* 색 성분 정규화\n        * C 지점: 태양빛에 해당되는 백색광\n\t\t* 가장자리 지점: 스펙트럼 색에 해당되는 순수한 색상\n\t\t* 평균이 C인 지점은 두 색상의 보색관계\n        * 스펙트럼 색은 C 지점과 스펙트럼 색을 잇는 선상의 색에 대한 지배주파수 색\n\n## 색 모델의 종류\n* RGB 색 모델\n\t* 가산색 모델\n    * 스스로 빛을내어 색을 표현하는 출력장치에 적합한 모델\n* CMY 색 모델\n\t* 청록, 자홍, 노랑 (Cyan, Magenta, Yellow)을 삼원색으로 하는 색 모델\n    * C, M, Y는 각각 R, G, B 원색의 색상을 흡수\n    * 감산색 모델\n    * 외부로부터 가해진 빛을 반사하는 형태의 출력에 적용\n* CMYK 색 모델\n\t* K (key) 성분: 회색의 농도를 설정\n    * CMY 모델에 비해 회색의 표현에 용이\n* HSV 색 모델\n\t* 사람이 생각하는 직관적인 개념에 보다 근접한 모델\n    * H (Hue, 색조), S (Saturation, 채도), V (Value, Brightness, 명도)\n\n## 색 속성의 지정\n* 프레임 버퍼에 색을 저장하는 방법\n\t* 각 픽셀의 RGB 색 정보를 프레임 버퍼에 직접 저장하는 방법\n\t* 색 부호를 별도의 테이블에 넣고, 이 테이블의 색 항목을 지정하는 **인덱스**를 프레임 버퍼에 저장하는 방법\n* 색 깊이 (color depth)\n\t* 하나의 픽셀을 표현하는데 사용되는 비트 수\n* OpenGL에서의 색 지정\n\t* 실수 자료형: 0부터 1까지의 값을 사용\n    \t* GLclampf: (1.0f, 0.0f, 0.5f)\n\t* 정수 자료형: 0부터 그 자료형의 최대값까지를 사용\n\n\n## 색 혼합\n* 알파 성분\n\t* 색의 투명도 등을 표현하기 위한 목적으로 사용할 수 있는 보조 데이터\n* OpenGL에서의 색 혼합\n\t* 목적지의 색 성분\n\t* 목적지의 혼합 인수\n\t* 소스 색 성분\n    * 소스 혼합 인수\n\t* 색 혼합기능의 활성화 및 비활성화\n    \t* glEnable(GL_BLEND)\n        * glDisable(GL_BLEND)\n\t* 색 혼합 함수\n    \t* void glBlendFunc(Glenum sFactor, Glenum dFactor);\n        * sFactor, dFactor: 소스 및 목적지 혼합 계수\n\n## 점과 선의 속성\n* 점 크기\n\t* 기본적으로 1개의 픽셀로 표현\n    * 큰 점의 표현\n    \t* 정사각형\n        * 원\n* 점 속성\n\t* 점 크기: void glPointSize(GLFloat size);\n    * 점 안티 에일리어싱 활성화 및 해제\n    \t* glEnable(GL_POINT_SMOOTH);\n        * glDisable(GL_POINT_SMOOTH);\n* 선 속성\n\t* 기울기가 1.0 이하인 경우 직선 경로의 위와 아래로\n\t* 1.0보다 클 경우 좌우로 선의 폭만큼 픽셀을 추가\n* 선 폭 속성\n     * 선분의 굵기가 기울기에 따라 차이가 있음\n     * 선 굵기에 해당되는 직사각형을 그리는 방법\n* 선분캡\n\t* 굵은 선분의 끝 모양을 다듬는 방법에 대한 속성\n\t* 사각캡, 원형캡, 돌출 사각 캡\n* 선분 연결\n\t* 두개의 굵은 선분의 연결 부분을 다듬는 방법에 대한 속성\n\t* 연귀연결, 원형연결, 사선연결\n* 선 스타일\n\t* 실선, 파선, 점선 등\n\t* 일정 구간의 픽셀을 그리거나 건너뛰는 것을 반복하여 그림\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"컴퓨터그래픽스 - 5강. 그래픽스 기본요소의 속성 (1)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-11T07:05:33.264Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"Rust Lang 을 mac에 설치해보기":{"id":119,"title":"mac에 Rust 설치하기","content":"# Rust 설치하기\n\n이 [사이트](https://www.rust-lang.org/tools/install)를 참조하여 Rust Lang을 mac에 설치했던 과정을 나타내보겠다.\n\n## rustup을 사용하여 설치\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n## 환경변수 설정\nohmyzsh을 썼기 때문에 다음과 같이 rust lang의 bin 디렉터리를 환경변수에 등록하였다.\n```shell\nexport RUST_BIN=$HOME/.cargo/bin\nexport PATH=$PATH:$RUST_BIN\n```\n그리고 zshrc 파일을 다시 실행시킨다.\n\n```bash\nsource ~/.zshrc\n```\n\n```bash\nrustc --version\nrustc 1.60.0 (7737e0b5c 2022-04-04)\n```\n\nrust lang이 mac에 설치되고 전역 환경 변수에 등록되었다.","thumbnail":"rust-logo-blk.png","excerpt":"Rust Lang 을 mac에 설치해보기","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-04-11T01:52:22.087Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"정신 질환 (대학교 과제)":{"id":120,"title":"정신 질환 (대학교 과제)","content":"# 정신 질환\n\n## 정신 질환의 개요\n> 신체 질환과 비슷하게 정신 질환도 전적, 생물학적, 환경적 요인들이 복합적으로 작용하여 발생한다. \n\n## 정신 질환의 종류\n* 우울증\n* 조울증\n* 공황장애\n* 조현병 (정신 분열증)\n* 치매\n* 망상장애\n\n> 신경증의 경우 자의 입원이 대부분\n정신증의 경우 타의 입원\n\n## 정신 질환자를 바라보는 사회의 시선\n* 심신이 미약하므로 주변의 도움이 필요하다 (편견)\n\t* 환자가 가진 병의 종류와 증상에 따라 모두 다르다 (객관적 사실)\n    * 가진 병이 신경증이라면 어느정도 자신을 컨트롤이 가능하나, 정신증의 경우 자신의 컨트롤이 안되는 질환도 있다 (이유)\n* 공황장애의 경우 언제 발생할지 모르므로 주변 사람이 불안하다 (객관적 사실)\n\t* 공황장애의 경우 언제 어디서 발생 할지 예측 할 수 없다 (이유)\n* 평생 진취적인 생각을 할 수 없다 (편견)\n\t* 약물 치료 및 상담 치료로 정신 질환도 치료가 가능하다 (객관적 사실)\n    * 따라서 치료를 마친 정신 질환자들은 회복 후에 일반인과 똑같이 진취적인 생각이 가능하다 (이유)\n* 은둔형 외톨이가 많다 (편견)\n\t* 겉으로는 외톨이가 아니고 사람을 많이 만나는 활발해 보이는 정신 질환자들이 존재한다 (객관적 사실)\n    * 하지만 우울증이나 조울증 등은 겉으로만 보아서는 파악 할 수 없다 (이유)\n* 평생 사회 부적응 증상을 가지고 있다 (편견)\n\t* 정신 질환을 가지지 않은 사람이라도 사회에 적응할 수 없는 면들은 존재한다 (객관적 사실)\n    * 정신 질환자들도 치료를 받고 완치가 되면 사회의 일원으로 다시 건강하게 돌아갈 수 있다 (이유)\n    \n## 정신 질환자들의 인식을 개선하기 위한 방안\n* 티비 등 매스컴에서 정신 질환자들에 대한 묘사를 안 좋은쪽으로 미화하지 않는다\n* 공황 장애같은 발작 질환에 대한 이유와 발작이 일어났을 때 주변의 도움 법을 많이 알린다\n* 일반적인 사람도 언제든 정신 질환자가 될 수 있다는 사실을 인지시켜 서로에게 도움이 되는 사회를 만든다\n\n\n\n### 참고 자료\n1. https://kawachicago.org/%EC%A0%95%EC%8B%A0-%EC%A7%88%ED%99%98%EC%9D%98-%EC%9B%90%EC%9D%B8%EA%B3%BC-%EC%A2%85%EB%A5%98-2/\n2. http://www.blesshp.com/psychopathy.html","thumbnail":"univ.jpg","excerpt":"정신 질환 (대학교 과제)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-10T10:03:23.617Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"페어 프로그래밍과 결함, 검증 테스팅":{"id":121,"title":"페어 프로그래밍과 결함 테스팅, 검증 테스팅","content":"# 페어 프로그래밍(Pair Programming)과 결함 테스팅, 검증 테스팅\n\n## 1. 페어 프로그래밍의 정의\n* 페어 프로그래밍은 애자일 개발 방법론 중의 하나로 하나의 개발 가능한 PC 에서 두 명의 개발자가 함께 작업하는 것을 말합니다.\n* 네비게이터(navigator)가 전략을 제시하고 드라이버(driver)가 실제 코드를 작성하며, 이 열할을 각자 번갈아가며 수행합니다.\n* 짝 프로그래밍이라고도 합니다.\n* 장점\n\t* 지식 공유\n    * 업무에 대한 집중도 상승\n    * 코드 리뷰 및 개발 방향의 지속\n    * 팀원을 잘 알게된다\n* 단점\n\t* 생산성 저하\n    * 피로도 상승\n\n## 2. 결함 테스팅(dynamic verification)의 정의\n* 소프트웨어의 실행을 통해 소프트웨어의 결함을 찾는 테스팅\n\n## 3. 검증 테스팅(static verification)의 정의\n* 소프트웨어를 개발하는 모든 과정에 해당한다\n* 요구사항 분석, 코드 리뷰 등 소프트웨어를 실행하지 않는 범위내에서 결함을 찾는 것을 말한다\n\n## 4. 결함 테스팅과 검증 테스팅\n* 둘다 v&v 프로세스에서 사용\n* 소프트웨어의 검증은 요구사항을 만족할 수 있는지 확인은 가능하나, 실제 고객의 요구사항의 만족인지 알기는 어렵다\n\n### 참고 자료\n1. https://blog.mathpresso.com/mathpresso-%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EB%A1%A0-1-%ED%8E%98%EC%96%B4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-pair-programing-f7d07ac323d0\n2. https://hodev.tistory.com/67","thumbnail":"unsplash-programming.jpg","excerpt":"페어 프로그래밍과 결함, 검증 테스팅","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-04-10T06:55:12.138Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"Lean 하게 개발하는 방법을 알아보자":{"id":122,"title":"Lean 개발 방법론","content":"# Lean 프로세스\n\n## 1. Lean의 개요\n### 1 - 1. 린(Lean)의 정의\n* 낭비의 제거를 통해 프로세스를 지속적으로 개선, 수행 속도를 높이고 소프트웨어의 품질을 향상시키는 기법 (단순 개발 프로세스가 아닌 경영 기법 혹은 사상)\n\n### 1 - 2. 린(Lean)의 특징\n* 신속성\n    * Lean은 낭비를 발견하고 제거함으로써 고객에게 가치를 빠르게 제공\n* 생산성 향상\n    * 생산성 향상을 위해 Lean 원칙을 소프트웨어 개발에 적용\n* 결함 제거\n    * 소프트웨어 개발에 있어 가장 큰 낭비는 결함\n    * 결함 제거 개념이 Agile과 유사 (Agile보다 큰 개념)\n    * 프로젝트 초기 고객과 많이 접촉하여 낭비 및 폐기를 줄이는 프로세스\n\n## 2. Lean 개발 방법론\n### 2 - 1. Lean 개발 방법론의 정의\n* TPS(Toyota Production System)를 재정립한 경영방법론인 린 시스템의 품질 기법을 소프트웨어 개발에 적용한 개발 방법론\n\n### 2 - 2. Lean 개발 방법론의 특징\n* 품질기법 : 린 공학 품질 기법을 SW 개발 프로세스에 적용\n* 낭비요소제거 : 낭비요소 제거하고 7가지 개발원칙 준수\n\n## 3. Lean의 개발 원칙 및 낭비 요소\n### 3 - 1. 린의 개발 원칙\n* 낭비제거\n\t* 불필요한 코드/기능, 불분명한 요구사항 등 소프트웨어 가치에 영향이 없는 모든 것을 제거\n* 배움증폭\n\t* 프로세스 진행 중 참여자(기획자, 개발자, 사용자 등) 학습의 필요성 존재\n* 늦은결정\n\t* 주요문제에 대한 의사결정을 최대한 연기함으로써 요구사항 변경에 적극적으로 대응\n* 빠른인도\n\t* 결과물을 가능한 빨리 제공하는 것이 도움\n    * 사용자측면 : 불확실성 감소, 개발자측면 : 결함발견의 기회\n* 팀에 권한위임\n\t* 팀원들의 동기부여 및 자기의사결정권으로 잠재력 극대화\n* 통합성구축\n\t* 개발 초기부터 지속적인 통합으로 품질 향상\n    * 소규모 개발단계마다 오류 발견 및 수정\n* 전체최적화\n\t* 요구사항수집부터 S/W 배포까지 모든 프로세스 최적화\n\n### 3 - 2. 린의 낭비 요소\n* 미완성 작업\n\t* 코드화 하지 않은 문서, 테스트하지 않은 코드 등\n* 여분기능\n\t* 필요하지 않은 기능을 추가\n* 재학습\n\t* 지식보유자가 개발에 참여하지 못해 해당 지식을 학습하는 활동\n* 이관\n\t* 업무 이관 시 상당량의 암묵지가 전수되지 못하는 경우\n* 작업전환\n\t* 작업수행 중 다른 작업으로 전환할 경우 집중력 분산 및 시간소모\n* 지연\n\t* 특정 인력이 가용한 상태가 될 때까지 기다림\n* 결함\n\t* 테스트에 결함 유입을 걸러주는 실수방지테스트 포함\n\n## 4. 린과 애자일 방법론의 비교\n* 공통점\n\t* 요구 사항 변화를 빠르게 수용\n    * 결과물을 사용자에게 빠르게 전달하여 고객가치와 만족도를 높임\n* 차이점\n\t* 애자일: 사용자와의 협업을 통해 빠른 개발을 수행 (사용자와 협업)\n    * 린: 사용자 관점에서 전체 프로세스 상 낭비 제거 (전적으로 사용자 관점)\n\n\n### 참고 자료\n1. https://itproda.tistory.com/90\n2. https://needjarvis.tistory.com/323\n\n","thumbnail":"unsplash-programming.jpg","excerpt":"Lean 하게 개발하는 방법을 알아보자","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-04-10T06:42:27.302Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"원격의료에 대해서 알아보자":{"id":123,"title":"원격의료 (U-Health)","content":"# 원격 의료 (U-Health)\n\n## 1. 정의 및 필요성\n* 정의\n\t* 유헬스는 유·무선 네트워킹이 가능한 정보통신기술을 활용하여 시간과 장소에 상관없이 언제 어디서나 이용 가능한 건강 관리 및 의료 서비스를 지칭한다.\n    * 유헬스의 유(U)는 유비쿼터스에서 첫 글자를 따온 것이다\n\n## 2. 장점과 문제점\n* 장점\n\t* 전통적인 의료 영역에서 벗어나 시간적 공간적인 확대, 소비자 공급자의 확대, 서비스의 다양화 등 도모 가능\n    \t* 원격 진료 예약 및 원격 진료 가능\n        * 집에서도 나의 건강 상태를 손쉽게 체크 가능\n    * 시간적인 손실의 감소\n    \t* 굳이 병원에 매번 가지 않더라도, 원격으로 진료를 받을 수 있는 장점이 있다\n    * 정보처리의 신속성\n    \t* 기술의 발달에 따라서 정보처리를 하는 속도가 빨라져 신속성이 좋아진다\n    * 의료 비용의 감소\n    * 부정확한 의료 제공의 방지\n    \t* 빅데이터 기술과 인공지능 기술의 발전에 따라서 더 정확도 높은 진료가 가능해진다.\n    * 직접 대면하는 의료 서비스의 이용이 어려운 사람들, 혹은 취약 계층들에게 유헬스를 이용하여 적절한 서비스 제공 가능\n    * 실시간 건강 모니터링 가능\n\n* 문제점\n\t* 프라이버시 문제\n    \t* IoT를 사용한 uHealth 기술에 대해서는 개인의 프라이버시가 침해 될 가능성이 있다.\n        * IoT 디바이스가 해킹당할 경우 개인의 의료 정보가 악용될 수 있다.\n    * 불평등 문제\n    \t* uHealth 서비스를 이용할 수 없는 사람들에게는 의료 서비스 불평등 문제가 발생 할 수 있다.\n    * 건강 행태 변화에 대한 책임 문제\n\n## 3. 활용 될 수 있는 정보 통신망 기술\n* 헬스케어 소프트웨어가 장착된 웨어러블 디바이스 기술\n* 병명 진단에 인공지능과 빅데이터를 활용할 수 있다\n* 사물 인터넷 (IoT)를 기반으로 사람이 사용하는 물건에 uHealth 기술을 접목 할 수 있다\n* 병의원 어플리케이션 개발 기술을 바탕으로 원격 진료 예약을 하는 어플리케이션을 개발 할 수있다.\n\n## 4. 결론\n\n헬스케어 클라우드 컴퓨팅 시장이 매년 20% 이상의 성장률이 기대되는 등, 유헬스 분야의 발전이 기대되고 있다.\n인공지능, 빅데이터, IoT와 같은 기술의 대중화와 함께 uHealth의 기술의 발전도 같이 기대되고 있는 추세이다.\n또한 현재 인공지능과 빅데이터 기술을 바탕으로 uHealth 분야의 스타트업도 많이 성장을 하고 있는 추세이다.\n따라서 앞으로 시간이 갈 수록, 전통적인 의료 진료 프로세스에서 벗어나서 조금 더 시간을 절약하고 맞춤형 진료 프로세스가 uHealth와 함께 이루어 질 것이다.\n하지만 이에 따라, uHealth의 비용을 감당하지 못하여 의료 서비스의 불평등을 겪을 수 있다.\n또한 IoT를 사용하기 때문에, 기기가 해킹을 당한 다던지 등의 개인의 프라이버시 문제가 확산 될 수 있다.\n따라서 이러한 새로운 헬스케어 기술이 조금 더 안정적으로 서비스 되려면 상기 문제들을 해결함이 중요하고 윤리적인 면과 의료사고를 예방하기 위해 법적인 제재나 규율이 조금더 자리잡힐 필요성이 있어 보인다.\n하지만 uHealth 분야는 현재 급속도로 성장하고 있는 분야이므로, 시행 착오 과정을 거쳐 결국은 미래의 산업으로 자리매김 할 것으로 예상된다.\n\n### 참고자료\n1. https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%97%AC%EC%8A%A4","thumbnail":"unsplash-programming.jpg","excerpt":"원격의료에 대해서 알아보자","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-04-10T08:20:01.572Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"기술 면접으로 느낀 점":{"id":124,"title":"개발자 1차 (기술) 면접 후기","content":"# 개발자 1차 (기술) 면접 후기\n\n최근 이직을 준비하면서, 3 ~ 4개 정도 회사에 지원을 했다.\n자세한 프로세스나 이직 관련 내용은 회사의 자산에 등록된 경우가 많으므로, 회사의 실명은 거론하지 않겠다.\n\n개인적으로 이직을  준비하면서 또 한번 다시 공부하는 마음을 가졌다.\n경험적으로도  좋은 경험이었다. \n\n이  글에서는  1차 면접 (기술면접)에서만 다룰 예정이고, 가장 면접경험이  좋았던  하나의 회사를 골라서 글을 작성할 것 이다.\n\n## 기술면접에서는 무슨 질문들이 나오는가?\n\n### 1. 자신에 대한 소개\n* 자신을 어떤 개발자라고 한마디로 표현할 수 있을지?\n\n처음  본격적인  인터뷰에 들어가기 앞서 대부분  면접관과  면접자의 어색한 기류를 없애기 위해 아이스브레이킹 타임으로 소개시간을 갖는다.\n이때 면접자는 자신에 대한 소개를 하게  된다.\n\n여기에서  단순하게  나에  대해 소개를  하였다.\nex) `모 회사에서 프런트엔드 개발자로 근무하고 있는 아무개 입니다. 현재 X년차 입니다 등`\n이후에 질문이 들어왔다.\n> 자신을 어떤 개발자라고 한마디로 표현할 수 있을지?\n\n나는 `아이디어를 실현하는 것을 좋아하는 개발자`라고 대답했다.\n너무 횡성 수설하지 않은 간단한 이유를 덧붙이기도 했다.\n\n좋은 질문인 것 같다. 결국 기술면접이란, 축약적으로 다음과 같은 항목을 알아보는 것이 가장 중요한 것 같다.\n* 면접자가 특정 기술에 대해서 이론적으로 혹은 실무적으로 얼만큼 알고 있는지?\n* 이 면접자가 추구하는 기술을 다루는 방향은 무엇인지?\n* 이 면접자가 당황하지 않고 돌발상황에 대처를 어떻게 하는지에 대한 태도\n* 추가적으로 면접자가 경력자라면 자신의 포트폴리오나 회사에서의 경험\n\n### 2. 본격적으로 회사에서 쓰는 특정 기술을 얼마나 알고있는지 알아보는 시간\n\n이제 소개가 끝났으니, 어느정도는 이 면접자가 어떠한 방향으로 성장해왔고 혹은 어떤 방향으로 성장하고 나아가고 싶은지 알게 되었다.\n이제는 실력을 알아볼 차례.\n기술 면접에서 가장 중요한 파트인 것 같은데, 회사에서 쓰는 특정 기술에 대한 깊이를 보는 시간이다.\n\n기본적으로 자신의 파트의 기술의 백그라운드 지식도 중요하지만, 메인 기술에 대한 이론적 요소와 감각은 같이 일할 개발자에게 꼭 알아봐야 하는 과정이다.\n\n나는 프런트엔드 개발자 중에서도, React를 이용하여 주로 개발하는 개발자 이다.\n따라서 면접시간에서는 React의 기본적인 지식을 물어보는 것으로 시작했다.\n* Virtual DOM에 대해서 설명을 부탁드립니다 !\n\n블로그를 시작하길 잘했다는 생각이 여기서 들었다. 블로그를 시작하면서 Virtual DOM에 대해서 알아보고자 글을 썼는데 참 많은 도움이 되었다.\n\n[Virtual DOM에 대한 내 블로그 글](https://blog.coldsurf.io/article/Virtual%20DOM%EC%9D%80%20%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%3F)\n\n가장 중요한 부분은 아무래도 Diffing Algorithm을 사용해서 비교하는 부분이 아닐까 싶다.\n그리고 Virtual DOM을 왜 쓰게 되었는지에 대한 이유까지 알면 훨씬 좋을 것 같다.\n\n이 파트에서 강조하고 싶은 부분은, `기본을 무시하지 말자`이다.\n자신이 쓰는 기술의 기본을 알고 있는지, 얼마나 탄탄하게 알고 있는지에 대해 보는 시간이므로 기술 면접전에 숙지해두고 참석하면 많은 도움이 된다.\n\n### 3. 그렇다면 돌발상황에서는 어떻게 대처할까?\n\n이것을 보는 가장 좋은 방법은 아무래도 `라이브 코딩` 일 것이다.\n내가 보았던 면접에서는 어떻게 보면 까다로울수 있지만, 그렇게 시간이 많이 들지는 않는 알고리즘 라이브코딩을 진행 하였다.\n\n아마 내 생각에 이 시간에서는 라이브 코딩을 하는 모습을 보면서 다음을 평가할 것 같다.\n1. 돌발 상황에서 어떻게 행동하는지?\n2. 문제를 풀어가는 과정이 합리적인지?\n3. 합리적인 판단으로 당황하지 않고 결과를 도출해 내는 능력\n\n따라서, 평소에 시간이 남을때에 꾸준히 알고리즘 공부를 해두면 좋다.\n결국 알고리즘문제 해결능력은 감각이고, 여러번 풀다 보면 감각이 자라나는 것 같다.\n\n[프로그래머스](https://programmers.co.kr/) 사이트를 추천한다!\n\n### 4. 좋다! 이제 라이브코딩까지 했으니, 최신 기술에 대한 관심도를 알아보자. (feat. optimization)\n\n간단한 예로 예전에는 window에 scroll 이벤트리스너를 등록하여 무한 스크롤링을 구현하는 경우가 많았다.\n사람들의 글을 보아 요즘은 IntersectionObserver로 reflow를 최적화하여 무한 스크롤링을 구현하고 있는 태세로 돌아서는 것 같다.\n\n이러한 예시처럼 최신 기술에 대한 관심도를 측정하는 시간이었다.\n또한 단순히 이론적거나 기본적인 기술보다는 조금 더 심도높은 최적화에 대한 이야기도 같이 나누었다.\n\n최적화 부분은 개인적으로 사이드 프로젝트가 많이 도움이 되었다.\n아무래도 회사 프로젝트는 최적화도 조심스럽기 때문에, 조금 더 자유롭게 최신 기술을 써가면서 최적화 까지 할 수 있는 사이드 프로젝트를 경험해보는 것이 큰 도움이 될 것이다.\n\n단순히 런칭만 하고 끝내는 것 보다, 계속 어떻게 하면 조금 더 나은 서비스를 제공할 수 있을지에 대해 심도있게 생각하다보면 최적화 기술도 자연스레 성장하리라 본다.\n\n\n## 마치며\n\n간단하게 4가지의 섹션으로 개발자 기술 면접에 대한 요약 및 정리를 해보았다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"unsplash-programming.jpg","excerpt":"기술 면접으로 느낀 점","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-04-05T05:40:32.964Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"IntersectionObserver를 살짝 훑어보고, react에서 사용법 알아보기":{"id":125,"title":"IntersectionObserver 잠깐 알아보기","content":"# IntersectionObserver 잠깐 알아보기\n\n## IntersectionObserver란?\n\nIntersectionObserver는 web API 이다.\nIntersection Observer API는 타겟 요소와 상위 요소 또는 최상위 document 의 viewport 사이의 intersection 내의 변화를 비동기적으로 관찰하는 방법이다.\n\n[출처](https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API)\n\n\n## IntersectionObserver를 쓰는 이유\n\n전통적으로 예전부터 스크롤을 감지하여 HTML element를 관리할때에 window의 scroll event listener를 사용하여 스크롤을 감지하거나, HTML element의 가시성을 알아볼때에 사용했다.\n\n하지만 이 window의 scroll event listener의 단점이 있었다.\n\n* 이 스크롤 이벤트가 발생할때마다 event listener의 콜백함수가 동작되므로 그것이 단시간에 불필요하게 수백번, 수천번 작동할수 있다. (debounce 혹은 throttle 방식을 적용하여 이 문제를 개선 가능)\n* 그리고 특정 지점을 관찰하기 위해서 `getBoundingClientRect()` 함수를 사용해야 하는데 이 함수를 사용시에는 `리플로우(reflow)` 현상이 발생한다\n\n> Reflow: 브라우저가 웹 페이지의 일부 또는 전체를 다시 그려야 하는 경우 발생\n\n이러한 기존 방법론의 단점을 보완하기 위해서 IntersectionObserver API가 등장했다.\n비 동기적으로 실행되기 때문에, 메인 쓰레드에 영향을 주지 않으면서 변경 사항을 관찰 할 수 있다.\n또한 `IntersectionOberverEntry` 의 속성을 활용하면 `getBoundingClientRect()`를 호출한 것과  같은 결과를 알 수 있기 때문에 따로 `getBoundingClientRect()` 함수를 실행 시킬 필요가 없다.\n따라서 `Reflow`현상이 발생하는 것을 방지 할 수 있다\n\n[출처](http://blog.hyeyoonjung.com/2019/01/09/intersectionobserver-tutorial/)\n\n## IntersectionObserver 간략 사용법\n```js\nconst observer = new IntersectionObserver(callback, options)\n```\n형식으로 생성을 하여 쓴다.\n그렇다면 세세하게 한번 callback, options 그리고 생성자로 받은 생성자 객체에는 어떤 것을 포함하고 있는지 알아보자.\n\n### IntersectionObserver - callback\n\n```js\nlet callback = (entries, observer) => {\n  entries.forEach(entry => {\n    // Each entry describes an intersection change for one observed\n    // target element:\n    //   entry.boundingClientRect\n    //   entry.intersectionRatio\n    //   entry.intersectionRect\n    //   entry.isIntersecting\n    //   entry.rootBounds\n    //   entry.target\n    //   entry.time\n  });\n};\n```\n\n### IntersectionObserver - options\n\n```js\nlet options = {\n  root: document.querySelector('#scrollArea'),\n  rootMargin: '0px',\n  threshold: 1.0\n}\n\nlet observer = new IntersectionObserver(callback, options);\n```\n* threshold: 1.0 은 대상 요소가 root 에 지정된 요소 내에서 100% 보여질 때 콜백이 호출될 것을 의미합니다. 혹은 25% 단위로 요소의 가시성이 변경될 때마다 콜백이 실행되게 하고 싶다면 [0, 0.25, 0.5, 0.75, 1] 과 같은 배열을 설정하세요.\n* root: 대상 객체의 가시성을 확인할 때 사용되는 뷰포트 요소입니다. 이는 대상 객체의 조상 요소여야 합니다. 기본값은 브라우저 뷰포트이며, root 값이 null 이거나 지정되지 않을 때 기본값으로 설정됩니다.\n* rootMargin: root 가 가진 여백입니다. 이 속성의 값은 CSS의 margin 속성과 유사합니다. e.g. \"10px 20px 30px 40px\" (top, right, bottom, left). 이 값은 퍼센티지가 될 수 있습니다. 이것은 root 요소의 각 측면의 bounding box를 수축시키거나 증가시키며, 교차성을 계산하기 전에 적용됩니다. 기본값은 0입니다.\n\n### IntersectionObserver - 생성자로 받은 객체\n\n```js\nlet observer = new IntersectionObserver(callback, options);\nlet target = document.querySelector('#listItem');\nobserver.observe(target)\n\n...\n\nobserver.unobserve(target)\nobserver.disconnect()\n\n```\n\n* observe: 특정 HTML Element를 관찰 하게 된다.\n* unobserve: 특정 HTML Element의 관찰을 멈춘다.\n* disconnect: observer가 모든 HTML Element에 대한 관찰을 멈춘다\n\n\n## IntersectionObserver를 실무에서는 어떻게 쓸까?\n\n### 예제 1. 무한 스크롤링\n간단한 이 블로그 프로젝트에 쓰인 사용법을 소개하며 글을 마치려고 한다.\n무한 스크롤링을 구현해서 더 가져오기 기능을 구현하는데 쓰였다.\n\n```js\nuseEffect(() => {\n  let observer: IntersectionObserver\n  observer = new IntersectionObserver(\n      (\n          entries: IntersectionObserverEntry[],\n          observer: IntersectionObserver\n      ) => {\n          const [entry] = entries\n          if (\n              !entry.isIntersecting ||\n              articles.length < DEFAULT_PAGINATION_COUNT\n          ) {\n              return\n          }\n          loadMore()\n          observer.unobserve(\n              loadingIndicatorElementRef.current as Element\n          )\n      },\n      {\n          threshold: 0.5,\n      }\n  )\n\n  if (loadingIndicatorElementRef.current) {\n      observer.observe(loadingIndicatorElementRef.current as Element)\n  }\n\n  return () => {\n      if (observer) {\n          observer.disconnect()\n      }\n  }\n}, [articles.length, loadMore])\n\n...\n\nreturn (\n  ...\n      <div\n          className={css`\n              display: flex;\n              align-items: center;\n              justify-content: center;\n              width: 100%;\n              margin-top: 10px;\n              margin-bottom: 10px;\n          `}\n          ref={loadingIndicatorElementRef}\n      >\n          {isLoading && <RotatingLines width=\"100\" />}\n      </div>\n\t</ArticleListContainer>\n)\n```\n\n설명을 해보자면 react의 ref를 사용하여 `loadingIndicatorElementRef`를 일반 div element에 주입을 시킨다. 그 div element가 IntersectionObserver가 관찰하게 될 HTML Element이다.\n유저가 스크롤을 하여 하단으로 스크롤을 내리면, 특정 하단의 div element가 보이게 되고, 따라서 그것을 관찰하던 IntersectionObserver가 관찰을 하다가, 특정 threshold에 맞추어 콜백함수를 실행한다. threshold 값이 만족이 된다면, entry의 `isIntersecting` 속성이 true로 변하게 된다.\n따라서 그때에 필요한 비즈니스 로직을 실행하게 된다. 여기서는 loadMore 함수를 실행 시킨다.\n\n### 예제 2. dynamically fixed 사이드바\n\n```js\nconst NavItemList = styled.ul<{ isFixed: boolean }>`\n    position: ${(p) => (p.isFixed ? 'fixed' : 'relative')};\n    top: ${(p) => (p.isFixed ? '1rem' : '0px')};\n    width: ${(p) => (p.isFixed ? '230px' : '100%')};\n\n...\n`\n\n...\n\nuseEffect(() => {\n    let observer: IntersectionObserver\n    observer = new IntersectionObserver(\n        (entries, observer) => {\n            const [entry] = entries\n\n            if (entry.isIntersecting) {\n                setIsFixed(false)\n            } else {\n                setIsFixed(true)\n            }\n        },\n        {\n            threshold: 0.1,\n        }\n    )\n\n    if (sideBarTopSpaceRef.current) {\n        observer.observe(sideBarTopSpaceRef.current as Element)\n    }\n\n    return () => {\n        if (observer) {\n            observer.disconnect()\n        }\n    }\n}, [])\n\nreturn (\n  <Container style={{ position: 'relative' }}>\n      <div\n          ref={sideBarTopSpaceRef}\n          style={{\n              height: '90px',\n          }}\n      />\n      <NavItemList isFixed={isFixed}>\n          <NavItem>\n              <Link href={`/`} passHref>\n                  <NavLink matched={router.pathname === '/'}>\n                      <NavLinkText>All</NavLinkText>\n                  </NavLink>\n              </Link>\n          </NavItem>\n...\n```\n이 상황에 대해서 살짝 설명을 하자면, 사이드바가 특정 스크롤 높이에서는 fixed 상태가 되어야 하는 상황이다. 따라서 스크롤바 위에 특정 높이를 가진 div element를 놓고 그것을 IntersectionObserver를 이용해 관찰한다. 그 후, 특정 element가 `isIntersecting === true` 일때 `isFixed` 상태를 변경한다.\n\n\n\n\n\n","thumbnail":"js.png","excerpt":"IntersectionObserver를 살짝 훑어보고, react에서 사용법 알아보기","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-04-11T01:27:39.650Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"생활과건강 - 4강. 신체건강 문제와 관리(3)":{"id":126,"title":"생활과건강 - 4강. 신체건강 문제와 관리(3)","content":"# 생활과건강 - 4강. 신체건강 문제와 관리(3)\n\n## 신경계  해부생리\n* 신경계\n\t* 체내 및 체외에서 일어나는 변화(자극)를 모니터링하여 정보를 모음\n\t* 통합\n    \t* 체내에 투입된 감각정보는 처리되고 해석되어 매순간 무엇을 해야할지 결정하는 처리과정\n\t* 운동반응\n    \t* 정보에 대해 인체가 근육관 선을 활성화 시키는 반응\n\t* 중추신경계\n    \t* 뇌\n        \t* 대뇌, 뇌간 (중뇌, 뇌교, 연수), 소뇌\n\t\t* 척수\n        \t* 경수, 흉수, 요수, 천수의 4개 영역으로 나뉨\n\t* 말초신경계\n    \t* 뇌신경: 뇌와 뇌간에서 나오는 12쌍의 신경\n        * 척수신경: 31쌍의 신경이 척수에 연결, 운동신경과  감각신경을  포함\n\t* 자율신경계\n    \t* 내장기능, 심장근육의 변화 등 불수의적 활동을 조정하는 말초신경계의 일부\n\n## 신경계 건강문제\n* 두통\n\t* 1군 (원발 두통): 긴장성 두통, 편두통\n    \t* 긴장성 두통\n        \t* 특별한 원인이 없음\n            * 대부분 과도한 스트레스\n            * 피로에 의한 근육 수축\n\t\t* 편두통\n        \t* 세로토닌의 대사이상으로 혈중 세로토닌이 증가, 뇌혈관이 확장되면서 발생\n            * 성인에게 주기적으로 나타나는 심한 두통\n            * 원인이 뚜렷이 밝혀지지는 않았음\n    * 2군 (이차 두통)\n    * 3군 (통증성 투개신경병증, 기타얼굴 통증 그리고 기타 두통)\n* 수핵 탈출증\n\t* 추간판 파열 혹은 디스크\n    * 수핵: 반젤라틴성 물질\n    * 원인: 척추의 퇴행성 변화, 척추 부상\n* 뇌졸중\n\t* 뇌혈관장애\n    \t* 뇌에 정상적인 혈액공급이 이루어지지 않아 중추신경계의 기능에 이상이 오는 현상\n\t* 중풍 이라고 불리는 뇌혈관 질환\n    * 혈관이 막히거나 터져서 뇌가 손상되면서 그에 따른 신경학적 변화를 경험하게 됨\n    * 크게 뇌출혈과 뇌경색으로 분류\n    * 뇌출혈\n    \t* 고혈압에 의해 대부분 발생\n\t* 뇌경색\n    * 반신마비 혹은 반신부전마비 (편측부전마비)\n\t* 실어증, 인지장애\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"생활과건강 - 4강. 신체건강 문제와 관리(3)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-03T03:15:44.121Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"우린 항상 어딘가에 쫓겨 사는 것은 아닌지...":{"id":127,"title":"우린 항상 어딘가에 쫓겨 사는 것은 아닌지...","content":"# 우린 항상 어딘가에 쫓겨 사는 것은 아닌지...\n\n최근들어 자신만의 시간의 중요성을 알게 되었다.\n사람을 만나면, 혹여 그 상대가 나와 가장 가까운 친구라 할지라도\n나는 그 혹은 그녀에게 나의 시간을 떼어주는 것은 분명하다.\n\n하지만 그 시간이 오롯이 나의 것인가? 라는 것에 대한 질문은 아직 모르겠다.\n나의 것이기도 하지만 그 반은 남의 것이다.\n남, 그래 나 자신 이외에는 모두 남이 맞다.\n이론적으로도 물리적으로도 말이다.\n\n우리는 왜 자신만의 시간을 가져야 할까?\n자신만의 시간이 없다면 우리는 수분이 증발해 가는 스펀지와 같다고 생각한다.\n수분이 증발해져 모두 날아간다면, 우리의 정신조차 지탱하지 못 할 것이다.\n\n최근들어 번아웃 이라는 증상으로 고생하는 사람들이 많다고 한다.\nBurn Out. 말 그대로 모두 타버려 없어지는 것.\n무엇이? 나의 정신이. 그들의 정신이. 정신은 곧 나 자신을 의미한다.\n우리는 육체를 가지고 태어나지만, 또한 정신을 기르며 자라난다.\n그 정신은 나의 정체성이 되고, 그 정체성이 무너지는 순간 나 자신을 잃어버리는 현상에 맞닥뜨리게 된다.\n\n오롯이 나 자신을 위한 시간은 이래서 중요하다.\n그 혹은 그녀, 그들이 나에게 정말 중요한 사람일지라도, 나보다 중요한 사람은 없으니까 말이다.\n내가 없으면 그 혹은 그녀, 그렇게 나에게 중요한 사람들도 없다.\n\n\"나\"와 \"남\"을 잘 분리하자. 그것이 올바르게 지혜롭게 살아가는 방법이다.\n또한 분리 후에는 내가 누군지 기억하자.\n나를 잃어버리지 않아야, 나에게 필요한 남과 그것들도 잃어버리지 않는 법이다.\n","thumbnail":"ocean.png","excerpt":"우린 항상 어딘가에 쫓겨 사는 것은 아닌지...","blogArticleCategoryId":5,"isPublic":true,"createdAt":"2022-03-31T13:53:10.944Z","deletedAt":null,"blogArticleCategory":{"name":"life"},"blogArticleTags":[]},"내가 추구하는 문화를 가진 기업과 팀":{"id":128,"title":"나에게 맞는 기업은 어떤 기업일까","content":"# 나에게 맞는 기업은 어떤 기업일까\n\n나는 개발자이다. 프런트엔드 쪽을 주로 맡고 일을 해왔다.\n이제까지는 가야하는 회사를 가서 일했다면, 이제는 조금 더 나와 맞는 회사에서 오래 일하고 싶은 생각과 그에따른 고민들이 들기 시작했다.\n\n## 내가 원하는 나의 동료\n\n1. 개개인의 센스가 좋은 구성원들이 자리하고 있는 팀을 가진 기업\n2. 제품이 무엇이든, 제품에 대한 열정을 가지고 주도적인 생각으로 일하는 팀원들이 있는 기업\n3. 자신의 분야 뿐만 아니라, 다른 부서와도 거리낌없이 대화가 가능한 팀원들이 있는 기업\n\n## 내가 원하는 나의 팀\n1. 서비스를 하는 제품을 만드는 팀이면 더욱 좋을 것 같다. (B2C)\n2. 정적인 팀보다는 동적으로 서로에게 동기부여를 할 수 있는 팀이면 더 좋을 것 같다.\n3. 다양한 변화에 유연한 팀이면 좋을 것 같다.\n4. 서로의 의견에 귀기울이는 팀이면 좋을 것 같다.\n5. 일할 때에 대기업 같이 딱딱하게 일하는 느낌을 받지 않는 팀이면 좋을 것 같다.\n6. 나는 무엇인가를 만들어내는 사람이므로, 창작에 대한 즐거움을 많이 느낄 수 있는 팀이면 좋을 것 같다.\n\n## 내가 원하는 나의 기업\n1. Top to Bottom이 아닌, Bottom to Top에 조금 더 집중 하는 문화가 있는 기업\n2. 인재를 채용 할 때에 조심스러운 기업 (단지 하루 일을 메꾸는 사람을 뽑는 것에 집중하지 않는 기업)\n3. 각 직원들의 다양성을 보장 해 줄 수 있는 기업\n\n## 그러면 지금 나의 상황에서 어디를 선택해야 할까?\n\n나에게는 어떻게 될진 모르지만, 일단은 두가지 선택지가 있다.\n기업을 숫자 1과 2로 표현하겠다.\n\n### 요약\n1. 조금 더 정적 이지만, 나와 기술을 다루는 생각이 비슷한 팀\n2. 조금 더 동적 이지만, 나와 궁극적인 목표가 비슷한 팀\n\n### 각 팀들의 장점\n1. 퇴사율이 낮다. 팀원들이 서로에게 만족하면서 일을 하는 것 같다. 또한 금전적으로 훨씬 안정적이다.\n2. 실행력이 좋다. 팀원들이 아직은 서로에게 조금은 낯설지만, 의지력과 결합력이 좋아 보인다. 금전적으로는 아직 안정적이진 못하지만, 잭팟이 터질 가능성이 있어 보인다.\n\n### 각 팀들의 단점\n1. 음 뭔가 내가 싫어하는 일 중 하나인 단순한 일을 하게 될 가능성도 높아보인다. 왜냐하면 이미 각 분야에서 오래 일한 분들이 있기 때문이다. 또한 이미 BM이 굳건히 자리잡혀 있어서 조금 더 일개미(?)가 되어야 할것 같다. 단순히 일을 많이 한다는 표현은 아니고, 시키는 일에 조금더 집중해야 할것 같은 느낌이랄까.\n2. 일단 지금 적당한 BM은 아직 없어보인다. 각 팀마다 스타플레이어들이 있어 보인다. 하지만 안정성은 없어보이는 것이 단점이다. 또한 아직 미래를 보장할 순 없다. 너무나도 급박하게 일이 진행되거나 꽤나 빠른 방향성의 변화가 있을 것도 같다.\n\n\n## 결론\n\n아직은 아무런 결과도 보장할순 없지만, 머리가 복잡하여 정리를 해보았다.\n아직도 어디를 선택해야 할지는 잘 모르겠다.\n나는 단지 저명한 기술자가 되는 것은 원하지 않는다.\n나는 궁극적으로 조금더 flexible하고 여러 분야에 능동적으로 대처 할 수있는 사고력을 가진 인재가 되고 싶다.\n\n조금 더 안정적이지만 기술에 집중할 수 있는 곳을 갈 것 인가, 아니면 조금 더 불안정 하지만 나의 목소리를 내어가며 조금 더 능동적으로 일 할 수 있는 곳을 갈 것인가 중에서 택하면 될 것 같다.\n\n\n\n\n\n\n\n\n\n","thumbnail":"ocean.png","excerpt":"내가 추구하는 문화를 가진 기업과 팀","blogArticleCategoryId":5,"isPublic":true,"createdAt":"2022-04-04T05:19:39.058Z","deletedAt":null,"blogArticleCategory":{"name":"life"},"blogArticleTags":[]},"Macro Task와 Micro Task의 차이":{"id":129,"title":"Event Loop in Browser 번역 (feat. Macro Task와 Micro Task)","content":"# Event Loop in Browser 번역 (feat. Macro Task와 Micro Task)\n\n[원글 링크 (dev.to)](https://dev.to/jasmin/difference-between-the-event-loop-in-browser-and-node-js-1113)\n\n![how event loop works in browser](https://res.cloudinary.com/practicaldev/image/fetch/s--I8K4E512--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/tg7893fgvd0q8im1fy3s.png)\n\n1. Heap\n\t* 함수에서 정의한 object와 변수를 저장한다\n2. Call Stack\n\t* 코드에서 만든 함수들을 LIFO형식의 스택으로 쌓는다.\n    * 가장 마지막에 들어온 것이 가장 위에 쌓이는 형태 (가장 처음 들어온 것이 가장 아래에 쌓인다.)\n3. Web API\n\t* V8 엔진에 의해서 제공되는 추가적인 기능들이다.\n    * Web API를 사용하는 함수들은 이 컨테이너에 저장되었다가, Web API가 완료 시 나오게 된다. (callback 함수)\n4. Queues\n\t* 비동기적인 코드의 응답을 계산하기 위해서 사용된다.\n    * 이러한 응답들은 엔진을 블락하지 않는다.\n    * **Macro Task Queue**\n    \t* Job Queue보다 낮은 우선순위에 있는 비동기 함수들을 실행시킨다.\n        * 또한 DOM Events, Ajax calls, setTimeout 등의 함수들을 실행시킨다.\n\t* **Micro Task Queue**\n    \t* Message Queue 보다 높은 우선순위에 있는 비동기 함수들을 실행 시킨다.\n        * promise를 사용하는 비동기 함수들을 실행시킨다.\n        \n> Event Loop는 Call Stack을 확인하여 Stack이 비어있을 때에 Queue에 있는 함수들을 Call Stack으로 넣고 실행한다. 이미 제공된 함수들은 높은 우선순위를 받게 되고 Message Queue에 있는 함수들보다 먼저 실행된다.","thumbnail":"js.png","excerpt":"Macro Task와 Micro Task의 차이","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-31T02:26:22.978Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"영감, inspiration. 그리고 조금 더 지속적이게.":{"id":130,"title":"나의 영감은 어디에서 와서 어디로 사라지는 것 일까","content":"# 나의 영감은 어디에서 와서 어디로 사라지는 것 일까\n\n## 영감 (Inspiration)\n\n에디슨이 말한 유명한 말이 있다.\n> 천재는 99프로의 노력과 1프로의 영감으로 만들어진다.\n\n영감은 중요하다.\n어떻게 보면 살아가면서 삶의 원동력이 되는 가장 중요한 부분이 아닌가 싶다.\n\n아이가 걷기 위해서 노력을 하는 것도 중요 하지만, 나는 아이의 미약한 정신 세계에서 걸을 수 있다는 강렬한 영감이 본능적으로 오기 때문에 결국 노력이란 것을 하여 걷게 된다고 생각한다.\n\n자전거를 타는 것을 배우는 것도 마찬가지라고 생각한다.\n처음에는 무작정 시도를 하여 여러 경험과 노력을 하지만, 결국 마지막 한 순간에 두 발을 모두 땅에서 띄고 페달에만 의존하여 자전거를 타게되는 순간을 만드는 순간은 영감이 아닐까 싶다.\n\n영감, 영어로는 Inspiration.\n감각이다. 사람이 느낄 수 있는 감각. 비록 그것이 단순히 오감에 속하진 않을 지라도, 그 오감을 활용하여 다른 정신적인 것과 결합하여 나온 것이 영감이 아닐까 싶다.\n나는 이 영감이 사람에게만 오는 것은 아니라고 생각한다.\n어린 새가 처음 날기 시작하는 것도, 본능적이고 동물적인 영감에서 오는 것이 아닌가 싶다.\n\n## 영감의 중요성\n사람은 기계가 아니다. 감정에 지배받기도 하고, 정신에 지배받기도 하는 그런 영적인 동물이 아닌가 싶다. 사람이 의미있는 삶을 살기 위해서는 동기부여가 필요하다.\n무작정 열심히 사는 사람들은 무엇인가 황폐해 보이기도 하는 이유가 여기에 있는 것이 아닌가 싶다.\n목적지 없는 항해는 결국 어딘가에는 도착 하겠지만, 중간중간 끊임없이 포기하고 싶은 생각이 들 것이다.\n\n이렇게 중간에 포기를 하지 않고 더욱 적절한 삶을 살아가는 과정을 만들어 주는 것이 영감이 아닌가 싶다.\n\n나는 조금 더 영감이 정신적이라기보다는 동물적인 감각에 가깝다고 생각한다.\n단순히 추악한 사람의 본능적인 그런 감각이 아닌, 본능적이지만 선한 감각이라고 생각한다.\n나에게는 영감을 `조금 더 진취적인 본능의 감각`이라고 정의 할 수 있을 것 같다.\n\n이러한 감각이 발달된 사람이 결국 조금 더 성공할 가능성이 높다.\n성공할 가능성이 높다는 것은 결국 기회를 잡을 가능성이 높다는 것.\n\n그렇다면 이렇게 중요한 영감이라는 것을 어떻게 지속적으로 나에게 맞게 유지할지 생각해보자.\n\n## 어느때 나는 영감이 왔나?\n\n아무래도 무의식에 사로잡혀 있을때 조금더 자유로운 사고를 하게 되는 것 같다.\n단순히 딴생각을 하면서 시간을 보내는 그런 무의식 이라기보다는, 머리를 식히게 되는 무의식 이랄까.\n그런 시간을 가지면서 딱딱했던 사고가 풀어지고, 조금더 자유로운 사고를 하게 되면서 신체적으로 신호를 보내어 그 신호로 사람이 영감을 낚아채는 것 아닌가 싶다.\n\n결국 영감을 얻기까지의 과정은 호수에서 고기를 낚아 올리는 작업과 같다고 표현할 수 있을 것 같다.\n`호수 = 동물적인 무의식 (세속적인 자아에 갇힌 것이 아닌 조금 더 태초의 사람 혹은 포유류에 가까운 자아)`\n`호수 속의 고기 = 사람의 본능속의 진취적인  감각`\n`고기를 낚아채는 행위 = 본능적인 감각을 신체적으로 느껴서 깨닫게 되는 것`\n이렇게 세가지로 영감을 얻는 과정을 축약할 수 있을 것 같다.\n\n\n## 어떨때 영감이 사라지거나 오지 않는가?\n1. 너무 세속적이거나 외부적인 쾌락에만 의존하거나 중독 된 때 (ex. 알콜 중독, 마약 중독 등)\n2. 신체적 혹은 정신적으로 건강하지 않을 때\n3. 어떤것에 너무 집착이 심할 때 (중독과 비슷하지만, 대상이 여러가지가 될 수 있을 것 같다)\n4. 자존감이 낮을 때 (나 자신을 챙기지 못하는 삶을 살고 있을 때)\n\n## 지속적으로 영감을 유지하기 위한 비법?\n\n엄청난 비법이 있는 것은 아니지만, 조금 더 신체적인 감각에 귀 기울이는 것이 좋지 않을까 싶다.\n사람은 고민을 한다. 그러한 고민을 번뇌라고도 표현한다.\n번뇌에 사로잡힌 사람은 길을 잃은 아이와 같다.\n그때에는 선택을 하기 어렵고, 머릿속이 복잡해져서 조금 더 생각에 귀를 기울이게 된다.\n이러한 행위는 신체적으로 집중하거나 본능에 집중하기 어렵다.\n번뇌에 사로잡히는 상황을 축구선수 공격수가 골키퍼와 1:1 상황에서 높은 확률로 골을 넣을 수 있지만, 낮은 확률로 골을 넣지 못하는 그러한 상황에 비유할 수 있을 것 같다.\n생각이 많아져서 조금 더 나은 신체적인 결정을 하지 못하는 것이다.\n\n사람은 정신이 많은 부분을 차지하는 이성적인 동물이다.\n하지만 그 이성을 지탱하는 것은 결국 신체이며, 신체적으로 약해지면 이성적으로도 약해진다.\n물론 정신을 통해서 신체의 결함을 극복하거나, 엄청난 자제력을 보여주는 사람들도 있다.\n\n하지만 나는 여기서 그러한 노력이나 끈기를 이야기하는 것은 아니다.\n그러한 노력이나 끈기를 이끌어 낼 만한 영감을 이야기 하고 있다.\n\n영감은 나도 모르는 곳에서 왔다가, 사라지기도 한다.\n마치 고기를 낚아채는 낚시를 하는 행위와도 같다.\n어떤날은 영감을 많이 느끼지만, 어떤날은 아무런 소득이 없이 빈 그물로 돌아오는 강태공 처럼 말이다.\n\n아무래도 영감자체도 감각이라, 뻔쩍하다가 시간이 지나면 자연스레 사라진다. (ex. 잠을 자거나 하는 행위로 휴식을 취할 때 등)\n\n조금 더 신체적이고 본능적인 `감각`에 계속 집중하는 일이 영감을 잘 이용하면서 조금 더 지속적으로 영감을 받거나 받은 영감이라는 불이 꺼지지 않게 다시 불을 지펴주는 작업을 하는 것이 아닌가 싶다.\n\n\n\n\n\n\n\n\n","thumbnail":"ocean.png","excerpt":"영감, inspiration. 그리고 조금 더 지속적이게.","blogArticleCategoryId":5,"isPublic":true,"createdAt":"2022-04-04T06:08:45.134Z","deletedAt":null,"blogArticleCategory":{"name":"life"},"blogArticleTags":[]},"2022년 1분기 회고":{"id":131,"title":"2022년도 1분기를 마치며","content":"# 2022년도 1분기를 마치고서\n\n## 들어가며\n2022년은 나에게 뭔가 터닝포인트가 될 수 있을 것 같다.\n이제 1년 뒤면 30살로 들어갈 때이고, 커리어 적으로도 내가 이때까지 쌓아논 것을 바탕으로 나의 꿈이나 열정을 실현하는 쪽으로 조금 더 방향을 틀어야 한다고 생각이 들기 때문이다.\n\n해야만 하는, 살아야만 하는 그런 삶은 이제 더 이상 내 인생에 큰 도움이 되지 않는 것 같다.\n주도적으로, 이때까지의 경험을 바탕으로 조금 더 나은 결정과 조금 더 능동적으로 나에게 맞는 결정을 내리는 것이 중요해지는 때가 아닌가 싶다.\n\n## Soft Release를 하다.\n\n이것은 직장 이야기 인데, 맡고있는 업무에서 새 제품을 Soft Release했다.\n사실 Soft Release는 내가 지어낸 말은 아니고, 직장 동료가 부르는 말이었는데 현 시점에서 상황을 가장 잘 표현하는 축약된 단어인 것 같긴 하다.\n\n팀 빌딩이 중요하다는 것을 이번 작업을 하면서 많이 느꼈다.\n제품 자체는 그리 어려운 제품이 아니었다. 먼저 선두를 달리는 기업들이 보여주는 것을 벤치마킹 할 수도 있었고, 레퍼런스가 없는 그런 레어한 제품이 아니었다.\n\n하지만 구성원들의 의견을 합치하는 것이 너무 어려웠다.\n개개인의 능력차도 있겠지만, 그것은 큰 어려움은 아니었던 것 같다.\n왜냐하면 만드는 제품 자체가 부서별로 엄청난 능력을 요구하는 제품은 아닌 것 같다.\n어떻게하면 빠르게 좀 더 효율적으로 트러블 없이 원하는 모습을 구현해 내는가가 가장 큰 문제였다.\n이 부분에서 서로가 의견을 좁히지 못했던 탓이 원래 3-4개월이면 충분히 만들 것을 거의 반년에 걸쳐서 만들게 된 원인이 아닌가 싶다.\n\n이런 부분에서 서로가 고찰은 당연히 할 텐데 (아마도), 그것을 누구 하나 능동적으로 나서서 서로에게 으쌰으쌰하는 기운을 불어넣어 준 기억은 없었던 것 같다.\n나도 나름의 그런 부분에 대한 일조는 하였지만 다른 부서에게 크게 와닿았던 것 같지는 않다.\n누구의 잘못은 아닌 것 같다. 내가 느끼기에는 단지 서로의 생각이 너무나도 다르고 시점이 너무나도 다르다. 좋은 방향으로 다양성이 아닌, 서로가 의견이 합치 되지 않는 문제로 번졌다.\n\n이것은 누구 하나의 노력으로 해결되는 문제는 아닌 것 같다.\n게다가 Project Manager를 하시는 역할을 가진 분이 없었다.\n결국 지도자가 없는 축구팀 이었던 것 이다.\n\n이래서 팀 빌딩이 중요하다는 것을 너무 크게 깨달았다.\n소수의 스타플레이어가 있어도, 팀으로 운영하는 게임에서는 서로의 몫을 다하지 못하면 결국 지게 되는 싸움이라는 것을 깨달았다.\n\n팀빌딩이 잘 된 회사는 내가 보기엔 드물다. 단지 서로의 노력으로 메꾸어 나가는 것 아닌가 싶다.\n규모가 크다고 팀 빌딩이 잘 되어있다고 이야기 할 순 없을 것 같다.\n단지 경력직이 많고, 서로의 경험이 많으니 그것을 해결 해 나가는 방식이 조금 더 많을 뿐.\n\n## 개인 1인 창작 단체를 만들다.\n\n지금은 나 혼자라서, 개발 위주로 만들어 가고 있지만 앞으로 네트워킹이 된다면 조금 더 인원수를 늘려서 어떤 분야에서라도 여러 가지를 융합하여 창작 단체를 만들어 갈 계획이다.\n\n나 자신에겐 많은 영감을 주기도 했고, 이때 까지 못 했던 밀려왔던 하고싶었던 작업들을 조금더 속도를 붙여 만들 수 있는 기회가 되었기에 이번년도 들어서 가장 잘한 일이 아닌가 싶다.\n\n앞으로도 즐거운 창작을 했으면 좋겠다.\n\n## 책을 많이 읽게 되다.\n\n이제는 나도 조금 연륜이 생겨서 그런지, 외부적인 즐거움 보다는 내부적인 즐거움을 조금 더 추구하게 되는 것 같다.\n최근에 약속이 있어서 강남 부근에서 자리를 하고 약속을 가졌는데, 이제는 더이상 강남과같은 분위기의 삐까뻔쩍하고 사람이 바글바글한 그런 곳은 나에게 맞지 않다는 것을 깨달았다.\n예전에는 전혀 느끼지 못한 부분이었는데, 이제는 확 와닿는 것을 보니 나도 변하긴 한 것 같다.\n\n그래서 책을 읽게 되었다. 집중하면서 책을 읽는 그 순간만큼은 온전히 나 자신에게 집중하는 순간이 되는 것 같은 기분이 들어서 좋다. 아직 책은 잘 모르지만 지금은 책을 알아가고 지식을 얻기 위해서 읽는 다기 보다는 새로운 취미를 하나 가진 것 같은 기분이다.\n\n예전에는 시간이 남을때에 유튜브를 보거나 하는 등의 단순히 시간을 소비하면서 보냈다면 요즘은 조금 더 나를 위한 시간으로 채워가는 것 같아 뿌듯하다.\n\n## 조금 더 나에게 맞는 네트워킹을 하게 되다.\n\n관심사가 비슷한 사람끼리 결국 모이게 되는가 싶다.\n아예 일면식도 없는 분들과 요즘 꽤나 흥미로운 자리를 같이 했다.\n물론 연락은 내가 먼저 취하는 편이지만, 그 연락을 받은 분들도 나의 의견이나 나에 대해 꽤나 흥미로워 하고 즐거운 시간을 보내는 것 같았다.\n\n아직은 처음이지만 이런 네트워킹을 하다보면 조금 더 생산적이고 즐거운 일을 할 수 있지 않나 싶다.\n\n## 건강을 생각 하게 되다.\n\n살아오면서 많은 병치레를 한 것은 아니지만, 유독 나에게 취약한 부분들이 있다.\n아니면 끊어야 할 건강적으로 안좋은 습관들이 있기도 했다.\n\n이런것을 이제 조금씩 더 자각하고 나의 건강을 챙기게 되는 것 같다.\n단순히 미래에 아픈것이 두려워서 그런다기 보다는, 이제는 건강이라는 것이 참 중요하다는 것을 깨달았기 때문이다.\n건강해야 내가 원하는 것을 할 수 있고, 내가 원하는 삶을 살 수 있다는 것을 알게 되었기 때문이다.\n또한 건강한 삶을 지속적으로 유지하는 것이 조금 더 생산적인 삶을 살 수 있지 않나 싶다.\n\n\n## 마치며\n\n아직은 정확하게 알 수 없다. 아직 이번년도도 3분기나 남았으며, 1분기때에 벌려놓은 일들을 아직 해결하지 못한 것이 많다.\n직장에 대한 고민, 취미에 대한 고민 등 앞으로의 시간은 그런 쪽에 조금 더 쏟을 계획이다.\n나에게 맞는 것이 무엇인지, 어떻게 하면 조금 더 만족스러운 시간들을 보낼 수 있는 것이 무엇인지 자연스럽게 알아가는 이 시간들을 즐기면서 생활할 계획이다.\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"ocean.png","excerpt":"2022년 1분기 회고","blogArticleCategoryId":5,"isPublic":true,"createdAt":"2022-04-04T04:55:27.029Z","deletedAt":null,"blogArticleCategory":{"name":"life"},"blogArticleTags":[]},"소프트웨어공학 - 4강. 소프트웨어 품질":{"id":132,"title":"소프트웨어공학 - 4강. 소프트웨어 품질","content":"# 소프트웨어공학 - 4강. 소프트웨어 품질\n\n## 품질의 정의\n* 제품이나 서비스가 가지는 수월성에 관한 종합적 특성\n* 생산자 입장의 품질: 명시된 요구사항을 만족시키는 정도\n* 고객 입장의 품질: 고객의 기대나 사용목적에 부합하는 정도\n\n## 소프트웨어 품질 \n* 명확히 기술된 요구사항 만족, 묵시적인 좋은  품질특성을 가지는 것\n\n## 품질 관점\n* 사용자 관점\n\t* 제품의 신뢰성\n    * 효율성\n    * 사용 용이성 등\n* 개발자 관점\n\t* 검증 가능성\n    * 유지보수성\n    * 이식성 등\n* 관리자 관점\n\t* 프로세스의 생산성과  제어 용이성\n\n## 소프트웨어 품질의 분류\n* 소프트웨어 제품의 품질 특성\n\t* 내부 특성이 외부 특성에 영향\n    * 외부 특성과 내부 특성이 분명히 구분되는 것은 아님\n* 외부 특성\n\t* 사용자 관점의 품질 특성\n    * 실행을 통해, 행위를 측정하여 평가\n    * 신뢰성, 사용성\n* 내부 특성\n\t* 개발자 관점의 품질 특성\n    * 개발자가 외부 특성을 개선하고자 할때 도움을 줌\n    * 개발 문서나 코드에 대해 정적으로 측정하여 평가\n* 프로세스의 품질이 제품의 품질에 영향을 줄 수 있음\n\t* 제품과 함께 프로세스의 품질도 중요\n* 제품 특성\n\t* 제품이 가지는 품질 특성\n    * 제품: 고객에게 전달 되는 것\n    * 개발자는 요구사항, 설계문서, 소스코드, 사용자 매뉴얼 등을 모두 제품으로 생각\n* 프로세스 특성\n\t* 체계적인 프로세스가 정의, 개발과정에 적용\n    * 프로세스의 품질은 소프트웨어 제품의 품질에 영향을 줌\n    * 프로세스 품질관리와 개선을 위한 노력이 필요\n\n## 소프트웨어 제품의 품질 표준\n* ISO/IEC 9126\n\t* 제품의 품질 분류와 메트릭을 정의한 표준\n    * 6가지로 분류\n    * 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성\n* ISO/IEC 25000\n\t* SQuaRE\n    \t* 품질 관리\n        * 품질 모델\n        * 품질 메트릭\n        * 품질 요구사항\n        * 품질 평가\n\n## 외부 메트릭과 내부 메트릭 \n* 외부 메트릭: 완성된 소프트웨어를 실행하여 제품 품질 측정\n* 내부 메트릭: 산출물의 품질을 측정하기 위한 것\n* 부특성을 측정하는 메트릭이 정의\n* 평균 고장 간격: MTBF\n\n## 사용 품질\n* 사용자가 실제 느끼는 제품의 효과\n* 효율성, 생산성, 안전성, 만족성\n\n## 맥콜의 제품 품질 특성\n* 11개의 품질 요인 제시\n\t* 제품 운영: 정확성 신뢰성 효율성 무결성 사용성\n    * 제품 개선: 유지보수성 시험성 유연성\n    * 제품 전이: 이식성 재사용성 상호운영성\n\n## 프로세스 품질 표준\n* 프로세스 품질: 성숙한 개발 프로세스\n* SPICE - ISO/IEC 15504\n\t* 프로세스 평가 프레임워크\n* ISO/IEC 12207\n\t* 생명주기 프로세스의 공통 프레임워크 제공\n* CMMI\n\t* 역량 성숙도 평가 모델\n* ISO 9001\n\t* 품질 경영체제 도입, 프로세스 품질 인증 획득을 위한 모델\n\n## ISO 9000 시리즈\n* 품질 경영을 위한 기본 요소 규정, 실천을 위한 활동 지침 제시\n* ISO 9000\n\t* 품질 관리 시스템의 기본과 관련 용어 설명\n* ISO 9001\n\t* 품질 관리 시스템의 요건 설명\n* 특징\n\t* 프로세스 평가 보다 품질 관리 자체에 중점을 둠\n    * 평가를 등급화 하지 않고 ISO 9001 인증 여부만을 결정\n\n## CMMI\n* 조직의 프로세스 성숙도를 평가하는 모델\n\t* 개발을 위한 CMMI, 발주위한 CMMI, 서비스위한 CMMI 존재\n* 다양한 기업에 프로세스 구축 평가 개선을 위한 프레임워크 제공\n* 단계적 모델 (성숙도 수준 평가): 조직의 프로세스의 성숙도를 1 ~ 5 수준으로 평가\n* 연속적 모델 (역량 수준 평가): 20여개의 실무 영역에 대해 각각 0 ~ 3 수준으로 평가\n* 개발을 위한 CMMI-DEV는 20개의 실무 영역 (PA)로 구성\n\t* 평가영역을 여러 실무 영역으로 구분\n    * 개별 실무 영역에서 수준(1~5)별로 분리된 지침그룹(PG)존재\n* 실무 영역은 4개 범주, 9개 역략 영역(CA)로 분류\n\t* 이행, 관리, 지원, 개성\n\n## CMMI와 평가\n* 연속적 모델(역량 수준 평가)\n\t* 실무 영역별로 평가\n    * 실행되지 않음, 초기, 관리됨, 정의됨\n* 단계적 모델(성숙도 수준 평가)\n\t* 초기(Initial), 관리됨(Managed), 정의됨(Defined), 양적으로 관리됨(Quantitatively Managed), 최적화됨(Optimized)\n\n## SQA: 소프트웨어 품질 보증\n* 품질 요구가 만족됨을 보증하는 품질관리 활동\n* 개발 과정 전체에 적용\n* 제품과 프로세스의 표준 정하고 시스템에서 요구되는 품질 속성을 정의\n\n## 품질 보증 계획\n* SQA를 수행하기 위한 로드맵\n\n## 품질 제어 (QC)\n* 품질 목표를 만족하도록 필요한 활동을 취하는 것\n\t* 프로세스\n    * 요구 명세서, 설계 문서, 코드\n    * 형상 관리 절차에서 나오는 문서들 검토\n* 용어의 혼용\n\t* 결함 발견, 수정 목적\n    * 제품 대상: 품질 제어, 프로세스 대상: 품질 보증\n\n## 확인과 검증 (V&V)\n* 모든 테스트를 포함하는 개념 (정적검토 / 동적 테스트)\n* 확인 (Verification)\n\t* 소프트웨어가 요구사항 명세서와 일치하는 지 검사\n* 검증 (Validation)\n\t* 고객의 기대를 충족하는지 검사\n\n## 검토\n* 정적 테스트\n\t* 정적 분석 도구\n* 목적\n\t* 요구명세서와 일치하는지 확인\n    * 계획 표준 및 지침에 맞게 개발되었는지 확인\n    * 소프트웨어 요소 변경이 적절히 구현되었는지 확인\n* 공식 기술 검토(FTR)\n* 인스페션\n* 코드 워크스루\n\n## 신뢰도\n* 의도된 기능을 고장 없이 실행 가능한 능력\n* 사용환경과 고장의 결과에 따라 다르게 인식 가능\n\n## 신뢰도 메트릭\n* MTTF (Mean Time To Failures)\n\t* 고장이 발생 할 때 까지의 평균 시간 (평균 수명)\n    * 고장의 복구를 고려하지 않음\n    * MTTF = (a1 + a2 + a3) / 3\n* MTBF (Mean Time Between Failures)\n\t* 고장이 수리된 후 다시 고장이 일어날때 사이의 평균 간격\n    * 고장의 복구를 고려\n    * MTBF = ((a1 + a2 + a3) + (r1 + r2 + r3)) / 3\n* AVAIL (가용성)\n\t* 논스톱 시스템의 신뢰도 측정에 사용\n    * 고장 발생 후 빠른 복구가 필요 (가용성 높이기)\n    * AVAIL = MTBF / (MTBF+MTTR) = (a1 + a2 + a3) / (a1 + a2 + a3 + r1 + r2 + r3)\n* ROCOF (Rate of Occurences Of Failures)\n\t* 고장의 발생 비율\n    * 규칙적 빈번한 서비스 요청이 들어오는 시스템 신뢰도 측정\n    * ex) 예약 시스템의 ROCOF가 0.002라면 1000회의 요청에서 2회의 오류가 발생\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"소프트웨어공학 - 4강. 소프트웨어 품질","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-03-29T09:06:07.944Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"컴퓨터그래픽스 - 4강. 컴퓨터 그래픽스 기본요소":{"id":133,"title":"컴퓨터그래픽스 - 4강. 컴퓨터 그래픽스 기본요소","content":"# 컴퓨터그래픽스 - 4강. 컴퓨터 그래픽스 기본요소\n\n## 원 그리기\n* 원뿔곡선\n* 원의 방정식\n\t* 중심이 (xc, yc) 반경이 r인 원\n    * (x - xc)^2 + (y - yc)^2 = r^2\n* 타원의 방정식\n\t* 두 초점으로부터의 거리의 합이 일정한 점들의 집합\n    * 장축과 단축이 좌표축에 정렬된 방향에 놓인 경우\n* 포물선의 방정식\n\t* 한점 (초점) 과 하나의 직선(준선)과의 거리가 동일한 점들의 집합\n* 쌍곡선의 방정식\n\t* 두 점으로부터의 거리의 차가 일정한 점들의 집합으로 구성된 곡선\n    * 중심이 원점에 존재하며 횡단축이 x축과 일치하는 쌍곡선\n\n## 원의 방정식\n* 데카르트 좌표계에서의 원의 방정식\n\t* (x - xc)^2 + (y - yc)^2 = r^2\n\n## 원 그리기 알고리즘\n* 원주상의 좌표 계산\n\t* 중심 좌표가 (0,0) 인 원의 좌표들을 구한 후 (xc, yc)를 더하여 실제 좌표들을 구함\n    * 단위 x좌표 변화에 대한 y좌표 변화 크기가 1보다 작은 구간에서 원주상의 좌표를 구함\n    * x = 0부터 x = y가 되는 구간\n* 원의 대칭성을 이용한 좌표 계산\n\n## 중간점 원 그리기 알고리즘\n* 판별 함수\n\t* x^2 + y^2 < r^2 -> 원 내부의 점\n    * x^2 + y^2 = r^2 -> 원주 상의 점\n    * x^2 + y^2 > r^2 -> 원 외부의 점\n* `F(x,y) = x^2 + y^2 - r^2`\n* F(x,y)\n\t* < 0 원 내부의 점\n    * = 0 원주 상의 점\n    * > 0 원 외부의 점\n* `Mk+1 = (xk + 1, yk - 0.5)`\n* 판별 함수 값에 따른 다음 좌표 결정\n* (xk+1, yk+1) 을 결정하기 위한 판별식\n* (xk+2, yk+2) 을 결정하기 위한 판별식\n* 판별식의 초기값 F(M1)\n\t* P0 = (0, r), M1 = (1, r - 0.5)\n    * F(M1) = 1^2 + (r - 0.5)^2 - r^2 = 1.25 - r\n* 다음 픽셀위치의 결정 및 판별식 갱신\n\n```c\nvoid bresenham_circle (int xc, int yc, int radius) {\n\tvoid circlePoints(int, int, int, int);\n  \tint F = 1 - radius;\n  \tint x = 0;\n \tint y = radius;\n  \t\n  \tcirclePoint(xc, yc, x, y);\n  \twhile (y > x) {\n\t\tif (F < 0)\n          F += x * 2 + 3;\n      \telse {\n        \tF += (x - y) * 2 + 5;\n          \ty--;\n        }\n      x++;\n      circlePoint(xc, yc, x, y);\n\t} \n}\n```\n\n## 다각형 그리기\n* 다각형이란?\n\t* 세 개 이상의 선분으로 둘러싸인 평면 도형\n    \t* 모서리 (edge) 또는 변 (side): 다각형을 구성하는 선분\n        * 꼭짓점 (vertex)\n* 단순 다각형\n\t* 다각형의 변들이 꼭짓점에서만 만나는 다각형\n* 블록 다각형과 오목 다각형\n\t* 볼록(convex) 다각형: 모든 내각들이 180도 이하인 다각형\n    * 오목(concave) 다각형: 볼록하지 않은 다각형 (180도 이상인 내각이 존재)\n* 볼록 다각형과 오목 다각형의 판별\n\t* 꼭짓점들을 정해진 순서로 연결하는 벡터를 나열한 후 모든 두 인접 벡터 쌍의 외적을 구함\n    * 볼록 다각형: 모든 외적의 방향이 동일\n    * 오목 다각형: 일부 외적의 방향이 반대\n\n## 다각형의 앞면과 뒷면\n* 앞면을 정하기 위한 꼭짓점 나열 순서\n\t* 시계 반대방향 (ccw) 순서\n    * 시계 방향 (cw) 순서\n* 홀-짝 규칙\n\t* 판별하고자 하는 점으로부터 다각형 외부의 점을 잇는 선과 다각형의 변이 교차하는 횟수가 홀수면 내부, 짝수면 외부로 판단함\n    * 주의: 판별을 위한 선이 다각형의 꼭짓점을 교차하는 경우 올바른 판별이 이루어지지 않을 수 있음\n    \n##  Open GL의 다각형 그리기\n* 다각형의 종류를 지정하는 상수 사용\n\t* GL_TRIANGLES\n    * GL_TRIANGLE_STRIP\n    * GL_TRIANGLE_FAN\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"컴퓨터그래픽스 - 4강. 컴퓨터 그래픽스 기본요소","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-04-03T04:47:54.671Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"정보통신망 - 4강. 데이터 통신의 요소(II)":{"id":134,"title":"정보통신망 - 4강. 데이터 통신의 요소(II)","content":"# 정보통신망 - 4강. 데이터 통신의 요소(II)\n\n## 전송 매체\n* 컴퓨터 통신망에서 수신기와 송신기 간에 물리적인 데이터 전송로 역할\n* 유선 통신매체 (하드와이어 매체)\n\t* 꼬임선 케이블\n    \t* 간섭 현상 감소 (두 가닥의 절연된 구리선이 균일하게 꼬여있음)\n        * 한 선은 정보 전송, 다른 선은 접지로 사용\n\t\t* 여러개의 쌍이 다발로 묶어져 하나의 케이블 형성\n        * 차폐 꼬임선, 비차폐 꼬임선\n    * 동축 케이블\n    \t* 중심도체 (심선) / 외부 원형도체가 서로 절연된 상태로 동일한 축 형성\n        * 용도: 장거리 전화망, tv전송, LAN 등\n        * 리피터 (repeater): 아날로그 전송 (수 km), 디지털 전송 (1km)\n    * 광섬유\n    \t* 3개의 단계로 구성\n          * 부호화 단계 (정보 -> 광)\n          * 광 전송 단계\n          * 복호화 단계 (광 -> 정보)\n\t\t* 광 코어 / 광 클래딩 / 자켓  \n        * 전송 모드\n        \t* 다중 모드\n            * 단일 모드: 전용선\n                 * 광 섬유 끼리의 접속이 상대적으로 쉬움\n\t\t* 장점\n        \t* 넓은 대역폭\n            * 작은 크기와 적은 무게\n            * 적은 감쇠율\n            * 전자기적 영향 최소화\n\t\t* 단점\n        \t* 접속의 전문성 요구\n            * 단방향 전송\n            \t* 양방향을 위해서는 2개의 광섬유가 필요\n* 무선 통신매체 (소프트와이어 매체)\n\t * 공기, 해수, 진공\n     * 지상 마이크로파, 위성 마이크로파, 라디오파, 적외선\n     * 지상 마이크로파\n     \t* 주파수: 2~40GHz\n        * 방향성을 가지고 있다\n     * 위성 마이크로파\n     \t* 통신위성: 중계국\n        \t* 정지위성, 임의위성, 위상위성 등\n        * 주요 용도: 장거리 전화, 텔렉스, TV\n        * 최상 주파수: 1~10GHz\n        * 장점\n        \t* 대량의 통신 용량 제공\n            * 오류율의 감소\n            * 통신 비용의 감소\n\t\t* 단점\n        \t* 전송 지연\n            * 점대점 통신만 가능\n            * 복구 불가능\n            * 지상의 무선통신과의 혼선 가능성\n            * 통신 보안의 문제점 등\n\t* 라디오파\n    \t* 다방향성 -> 방향성이 없다 -> 접시형 안테나 불필요\n        * 문제점: 다중 경로 간섭\n\t* 적외선\n    \t* 가시광선보다 파장이 긴 전자기파\n        * 주요용도: 단거리 통신\n        * 주파수: 300 ~ 500 GHz\n        * 특징: 높은 주파수\n\n\n## 네트워크 형태\n\n* 성형, 환형, 버스형, 그물형, 계층형 네트워크\n* 성형 네트워크\n\t* 점대점 선로\n    * 중앙 컴퓨터의 의존도\n* 환형 네트워크\n\t* 2개의 통신 경로\n* 버스형 네트워크\n\t* 하나의 선로\n* 그물형 네트워크\n\t* 많은 단말기로부터 많은 양의 통신\n* 계층형 네트워크\n\t* 작업의 계층성\n\n## 네트워크 장치\n\n* 리피터, 허브, 브리지, 라우터, 게이트웨이\n* 리피터\n\t* 약해진 신호를 원래 신호만큼 증폭해서 보내준다\n    * 신호를 구분하여 재생 (잡음증폭을 피하기 위해서)\n    * 통과시 약간의 시간지연이 발생\n* 허브\n\t* 신호를 재생하여 다른 노드로 보내는 장치\n    * 더미 허브, 스위칭 허브, 스태커블 허브\n* 브리지\n\t* 복수의 LAN을 연결하기 위한 장치, 데이터링크 계층에서 동작하는 통신장치\n* 라우터\n\t* 네트워크 계층에서 동작\n\t* 서로 다른 매체접근 방식을 사용하더라도 동일한 네트워크 계층 프로토콜만 사용한다면 상호간에 데이터를 송수신 할 수 있음\n    * Routing 기능: 최적의 경로 선택하여 데이터 패킷을 전송\n    * 오류제어: 오류가 있는 패킷 검출하여 폐기\n    * static routing: 수동적인 방법으로 라우팅 테이블 관리\n    * dynamic routing: 라우터간의 라우팅 정보교환을 통해 라우팅 테이블을 자동 관리\n    * 라우터와 브리지의 비교\n    \t* 브리지: 데이터링크 계층에서 동작\n        \t* 물리주소 (MAC)사용\n        * 라우터: 네트워크 계층에서 동작\n        \t* 네트워크 주소 (IP)사용 \n* 게이트 웨이\n\t* 응용계층에서 동작\n    * 프로토콜의 전환\n    * 데이터 형식의 변환\n\n## 네트워크 소프트웨어\n\n* 정의\n\t* 유선 혹은 무선환경의 네트워크 계층에서 단말기들이 서로 약속된 프로토콜 메커니즘을 이용해 데이터를 교환할수 있도록 한다\n* 종류\n\t* 네트워크 어플리케이션\n    \t* 웹브라우저, FTP, 텔넷\n\t* 네트워크 운영체제 (NOS)\n    \t* 네트워크 제어 / 전송 메시지 제어\n        * 자원 접근 제어\n        * 보안 등 관리자 기능 제공\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"univ.jpg","excerpt":"정보통신망 - 4강. 데이터 통신의 요소(II)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-03-30T06:17:02.739Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"모바일앱프로그래밍 - 4강. Button과 EditText":{"id":135,"title":"모바일앱프로그래밍 - 4강. Button과 EditText","content":"# 모바일앱프로그래밍 - 4강. Button과 EditText\n\n## ImageView\n* maxHeight, maxWidth, minHeight, minWidth: 화면에 표현되는 최소, 최대 크기를 지정\n* adjustViewBounds: 이미지가 레이아웃보다 큰 경우, 화면에 표현되는 종횡비를 맞추기 위해 `ImageView`의 크기의 조정에 이미지 크기의 비율을 고려한 조정 여부를 지정함\n\t* 높이만을 조정함\n\t* 참 거짓 (true, false)값을 가짐\n* `cropToPadding` 속성: maxWidth, maxHeight 속성 값에 의해 결정된 ImageView의 크기에 따라 layout 내부에 설정된 padding 값까지 고려하여 이미지의 일정 부분이 잘려 나가는지에 대한 여부를 지정하는 속성\n* `tint` 속성: 이미지의 색조값 지정\n* `scaleType` 속성: 이미지 확대 축소 알고리즘을 지정하여 원래 크기와 다른 이미지를 화면에 표현함\n\n## Button\n* 사용자가 선택 명령을 내릴 수 있는 위젯\n* pressed, clicked 에 의해 액션이 취해짐\n* TextView의 모든 속성들을 상속\n\n## EditText\n* 문자열 입력을 받는 위젯\n* 에디트라고 부름\n* TextView의 모든 속성들을 상속\n\n## ViewGroup의 속성\n* layout_width, layout_height의 속성\n\t* fill_parent, match_parent, wrap_content,정수 크기\n* padding 속성\n* layout_margin 속성\n\t* View와 부모 View의 간격","thumbnail":"univ.jpg","excerpt":"모바일앱프로그래밍 - 4강. Button과 EditText","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-03-25T01:43:12.509Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"React의 memo를 쓰다가 난 장애 회고":{"id":136,"title":"React memo를 쓸 때 주의해야 할 점 (feat. 배열의 아이템을 index로 가져오기)","content":"# React memo를 쓸 때 주의해야 할 점 (feat. 배열의 아이템을 index로 가져오기)\n\n이 글은 React memo를 쓰다가 나온 장애를 회고하는 글 입니다.\n\n기존 코드는 다음과 같았다.\n\n```jsx\nexport default memo(ProjectItemList, (prev, next) => {\n  return prev.data.length === next.data.length && prev.data[0].id === next.data[0].id\n});\n```\n\n배열의 아이템의 개수가 0개일때 exception 처리를 안한것이 에러의 원인.\n따라서 유저가 생성한 project의 개수가 0개였을때 rerender가 일어나면 에러가 나는 현상 이었다.\n\n다음과 같이 코드를 변경하였다.\n\n```jsx\nexport default memo(ProjectItemList, (prev, next) => {\n  const prevFirstId = prev.data?.[0]?.id;\n  const nextFirstId = next.data?.[0]?.id;\n  return prev.data.length === next.data.length && prevFirstId === nextFirstId;\n});\n```\n\ntest 파일에서는 단순히 `render`라는 testing-library의 함수로만 테스트를 했기 때문에 해당 에러를 잡을 수 없었다.\n또한 dummy empty array에 대한 테스팅이 추가되어있지 않았고 무조건 array의 length가 1이상이었기 때문에, 빈 array에 대한 테스팅 조차 없었던 것이 테스팅으로 거를수 없었던 이유.\n\n따라서 test파일에서는 `rerender` 함수를 사용하여 React.memo가 props를 compare하도록 만들었다.\n\n```jsx\nimport { screen, render } from \"@testing-library/react\";\n\n...\n...\n\ndescribe(\"ProjectItemList\", () => {\n  it(\"render with empty data array\", () => {\n    const { rerender } = render(\n      <ProjectItemList\n        data={fakeProjectList} // 이때에는 배열의 길이가 0\n        renderItem={(item) => <ProjectItem key={item.id} data={item} />}\n      />,\n      {\n        wrapper: AllTheProviders,\n      }\n    );\n    expect(screen.getByTestId(\"project-item-list\").children.length).toBe(0);\n\n    // rerender를 사용하여 React의 memo가 작동하게 하여 memo내의 areEqual 콜백 함수가 작동하게 한다.\n    rerender(\n      <ProjectItemList\n        data={fakeProjectList}\n        renderItem={(item) => <ProjectItem key={item.id} data={item} />}\n      />\n    );\n    expect(screen.getByTestId(\"project-item-list\").children.length).toBe(0);\n  });\n```\n\n## 결론\n* 배열의 아이템을 index로 가져올 때에는 반드시 유효성 검사를 하자.\n* React memo를 사용할때에 testing 코드를 쓸 때에 `@testing-library/react`모듈의  `rerender` 를 사용하여 memo 함수의 areEqual 콜백함수가 동작하도록 해서 memo를 테스트 할 수 있다.","thumbnail":"unsplash-code-react.jpg","excerpt":"React의 memo를 쓰다가 난 장애 회고","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-25T05:34:50.049Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"depth에 관계없이 number array를 모두 flat 시켜보자":{"id":137,"title":"알고리즘 - number array flat 시키기","content":"# 알고리즘 - number array flat 시키기\n\n[코드샌드박스](https://codesandbox.io/s/condescending-haslett-xeqbm0?file=/src/index.js)\n\n### 문제 1\n> [1, [2, 3], [4, 5]]를 모두 flat 해보세요\n\n**답안**\n\n```js\nfunction flat(numbers) {\n  var answer = [];\n  answer = numbers;\n  answer = answer.flatMap((v) => v);\n  return answer;\n}\n\nconsole.log(\"문제 1:\", flat([1, [2, 3], [4, 5]]));\n```\n\n답안 설명: 간단하게 flatMap을 쓰면 1 depth array까지는 flatten이 가능하다.\n\n### 문제 2\n> [1, [2, 3], [4, 5], [4, [5, 6, [6, 7]]]]를 모두 flat 해보세요\n\n**답안**\n\n```js\nfunction flatAll(numbers) {\n  var answer = [];\n  answer = numbers;\n  while (answer.some((v) => Array.isArray(v))) {\n    answer = answer.flatMap((v) => v);\n  }\n  return answer;\n}\n\nconsole.log(\"문제 2:\", flatAll([1, [2, 3], [4, 5], [4, [5, 6, [6, 7]]]]));\n```\n\n답안 설명: depth 가 무한개일때라고 가정 할때, 모두 flatten작업이 들어가야 하므로, `some` 함수를 사용하여 하나라도 array type인 것을 걸러낸다. 따라서 answer값을 계속 검사하여 하나라도 array type을 가질때까지 모두 flat 작업을 계속 한다.","thumbnail":"unsplash-programming.jpg","excerpt":"depth에 관계없이 number array를 모두 flat 시켜보자","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-21T09:16:03.780Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"컴퓨터보안 - 4강. 사이버 공격":{"id":138,"title":"컴퓨터보안 - 4강. 사이버 공격","content":"# 컴퓨터보안 - 4강. 사이버 공격\n\n## 목차 \n1. 사이버 공격의 개요\n2. 다양한 사이버 공격\n3. 최근의 사이버 공격 방식\n\n## 1. 사이버 공격의 개요\n* 인터넷을 통해 다른 컴퓨터에 불법 접속하여, 다른 개인 혹은 집단에게 손상을 입히는 행동\n* 과거에는 네트워크를 통한 잘못된 설정을 이용하여 관리자  권한을  얻는 방식이 대부분\n* 기술이 발전함에 따라 네트워크 상의 패킷을 조작하는 공격\n* 상용 웹사이트의  취약점을 이용한 공격\n* 스마트폰의 보급에 따라 무선 환경에서의 공격\n\n## 2. 다양한 사이버 공격\n* 악성코드\n* 네트워크\n* 스팸메일\n* 피싱\n\n### 2 - (1) 악성코드 (Malware, Malicious Code)\n* 컴퓨터에 악영향을 끼칠 수 있는 모든 소프트웨어의 총칭\n* 웜, 트로이 목마 등\n* 시스템 손상, 전파, 정보 유출 등 다양한 목적\n* 대부분 무분별한 인터넷 사용으로 인한 감염\n* 예방 방법\n\t* 의심스러운 사이트 이용하지 않기\n    * 메신저로 오는 의심가는 링크로 접속하지 않기\n    * 보안등급 설정, 불법 복제 금지\n    * 보안프로그램 사용\n* **바이러스**\n\t* 시스템이나 사용자의 파일에 자신을 복제하고 그 컴퓨터 시스템 내에서 증식하거나 시스템을 파괴하는 악성 코드\n    * 일반적인 특성\n    \t* 자기복제\n        * 저수준 언어 사용\n        * 다양한 변종\n        * 지능화 및 악성화\n    * 동작 원리\n    \t* 바이러스에 감염된 프로그램이 필요\n        * 감염된 프로그램을 사용자가 실행하거나 실행되면 바이러스 활동이 시작\n        * 찾아진 대상 파일을 검사하여 이미 감염된 파일인지 확인\n        * 감염된 파일이 아니라면 파일의 앞 혹은 뒷부분에 자신의 코드를 삽입하여 감염시킴\n        * 감염 과정을 감추기 위하여 바이러스 코드 실행이 끝나면 원래 프로그램의 작업을 수행\n        * 메모리에 있는 바이러스는 다른 파일들에 대한 감염 수행\n* **웜**\n\t* 컴퓨터의 취약점을 찾아 네트워크를 통해 스스로 감염되는 바이러스 (따로 host 파일이 없어도 감염 가능)\n    * 네트워크를 경유하여 자기 복제능력을 통한 빠른 전파력\n* **트로이 목마 (Trojan Horse)**\n\t* 정상적인 프로그램으로 가장하여 프로그램 내에 숨어서 의도하지 않은 기능을 하는 악성 코드\n    * 개인정보 유출, 감염대상 원격 조종 등 비인가 된 기능 수행\n* 비교\n\t* 바이러스 / 웜: 자기복제 가능\n    * 바이러스는 숙주 필요. 웜, 트로이목마는 숙주 필요 없음.\n* **백도어**\n\t* 공격자가 시스템에 침입 한 후, 이후에 손쉽게 들어오기 위해 다른 프로그램을 설치하여 다시 쉽게 들어오기 위해 악성코드 설치\n    * 시스템의 보안 취약점을 찾아서 OS나 응용 프로그램에 삽입된 코드\n* **스파이 웨어**\n\t* 다른 사람의 컴퓨터에 설치되어 개인정보를 빼가는 악성 코드\n    * 사용자 동의 없이 혹은 모르게 설치 되는 코드\n    * 거짓으로 백신프로그램을 가장하여 치료 유도 등\n* **랜섬 웨어**\n\t* 사용자의 중요 정보를 인질삼아 금전을 요구하는 악성 코드\n    * 사용자의 중요 파일을 암호화\n\t* 암호를 풀기 위해 비트코인 등 요구\n    * 키를 알지 못하면 풀수 없는 암호화 알고리즘을 사용\n    \n### 2 - (2) 네트워크 공격\n* **스캐닝**\n\t* 네트워크의 취약점을 알아내기 위해서 정보 수집하는 행위\n    * 취약점을 찾기 위한 도구로 사용됨\n    \t* Nmap, Acutenix 등\n* **스푸핑**\n\t* 공격자의 제어하에 host를 준비\n    * 상대방이 신뢰하는 host로 가장하여 유저를 속여서 정보를 가로채는 행위\n    * IP Spoofing, DNS Spoofing 등\n* **스니핑**\n\t* 네트워크상에서 도청하는 행위\n    * Passive 스니핑\n\t\t* 무차별 모드\n        * 패킷내의 정보를 조작없이 도청\n\t* Active 스니핑\n    \t* ARP 스푸핑을 사용\n        * 패킷 방향을 조작하여 공격자에게 패킷을 보내는 형식, 정보를 훔친 후 다시 원래 패킷의 방향으로 전송\n* **서비스 거부 (DoS, Denial of Service)**\n\t* 특정 자원에 트래픽 등을 유도하여 다른 쪽의 performance를 떨어뜨리는 행위\n    * 서비스를 못하게 만드는 공격\n\t* 해당하는 서버에 대량의 데이터를 전송하여 트래픽 발생 유도\n    * SYN Flooding 공격\n    \t* 반열림 tcp 연결들을 생성하여 시스템을 서비스 거부 상태로 만드는 공격\n* **분산 서비스 거부**\n\t* 여러대의 공격자들의 분산된 배치를 통해 서비스 거부 공격을 하는 방법\n    * 기존 DoS의 multiple 방식\n\n### 2 - (3) 스팸 메일\n* 불특정 다수를 대상으로 스팸 메일을 보내는 행위\n* DNS를 이용한 탐지법\n\t* 이미 알려진 스팸 메일의 DNS를 가지고 파악\n* 통계 기법을 이용한 탐지법\n\t* 스팸메일의 통계를 가지고 높은 비율이라면 스팸메일이라고 인지\n\n### 2 - (4) 피싱\n* 유명한 혹은 공신력 있는 이름을 사칭\n* 메일을 통해 수신자를 속여서 정보를 받아내는 행위\n* 가짜로 만든 피싱사이트를 활용\n* 대처 기법\n\t* 의심가는 링크를 누르지 않는다\n* VoIP, 전화, sns 메시지등으로 가장하여 변화되기도 함\n* 파밍 (Pharming)\n\t* 사용자 PC의 도메인 정보를 조작\n    * 도메인 자체를 중간에서 탈취\n    * URL주소를 똑같이 사용\n    \n## 3. 최근의 사이버 공격 방식\n* 사이버 테러, 사이버 범죄 등 특정 대상을 통해서 공격하는 방식으로 발전\n* 에이전트화, 분산화, 자동화 은닉화\n* 분산 서비스 거부 (DDoS) 방식이 대표적\n* APT (Advanced Persistant Threat)\n\t* 지능형 지속적인 위협\n    * 특정 대상을 목표로 다양한 공격기술을 활용해 차근차근히 공격해 나감\n    * 목적성, 지속성, 은밀함\n* 혹은 미래에 새로운 방법이 등장할 것","thumbnail":"univ.jpg","excerpt":"컴퓨터보안 - 4강. 사이버 공격","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-03-26T06:20:41.102Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"초기값 설정에 따라서 언제 어느 것을 사용하여야 할까?":{"id":139,"title":"useEffect와 useLayoutEffect","content":"# useEffect와 useLayoutEffect\n\n## useEffect\n> componentDidMount 혹은 componentDidUpdate와는 달리 useEffect에서 사용되는 effect는 브라우저가 화면을 업데이트하는 것을 차단하지 않습니다.\n이를 통해 애플리케이션의 반응성을 향상해줍니다.\n대부분의 effect는 동기적으로 실행될 필요가 없습니다.\n흔하지는 않지만 (레이아웃의 측정과 같은) 동기적 실행이 필요한 경우에는 useEffect와 동일한 API를 사용하는 useLayoutEffect라는 별도의 Hook이 존재합니다.\n\n[React 문서](https://ko.reactjs.org/docs/hooks-effect.html)\n\n이 설명을 코드로 풀어 말하자면 다음과 같다.\n\n```jsx\nconst Page = () => {\n\tconst [name, setName] = useState(\"\")\n    \n    useEffect(() => {\n    \tsetName(\"John Doe\")\n    }, [])\n  \n\treturn <h1>My name is {name}</h1>\n}\n```\n\n위 코드에서 name값의 초기값은 \"\"이다.\nuseEffect를 사용하여 초기 렌더링 시 name값을 \"John Doe\"로 바꾸어준다.\n실제로 이 코드를 실행 시켜 보면, 잠깐동안 layout shifting (깜빡이는 현상)이 일어날 것 이다.\n(layout shifting을 경험해보기 위해서는, 브라우저의 네트워크 설정에서 throttling을 걸어서 느리게 할 필요가 있다.)\n\n이것을 방지하기 위해서 `useLayoutEffect`를 사용할 수 있다.\n\n## useLayoutEffect\n\n위에서 쓴 코드를 useLayoutEffect를 사용한다면 다음과 같다.\n\n\n```jsx\nconst Page = () => {\n\tconst [name, setName] = useState(\"\")\n    \n    useLayoutEffect(() => {\n    \tsetName(\"John Doe\")\n    }, [])\n  \n\treturn <h1>My name is {name}</h1>\n}\n```\n\n이렇게 사용한다면 John Doe라는 글자가 layout shifting이 없이 초기 화면에서 그려질 것이다.\n\n* useLayoutEffect\n\t* **DOM이 그려지기 전**에 실행\n\t* 동기적\n* useEffect\n\t* **DOM이 그려지고 나서** 실행\n\t* 비동기적\n\n### 참고 자료\n> https://merrily-code.tistory.com/46","thumbnail":"unsplash-code-react.jpg","excerpt":"초기값 설정에 따라서 언제 어느 것을 사용하여야 할까?","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-21T02:17:58.205Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"컴퓨터 그래픽스 - 3강. 컴퓨터 그래픽스 기본요소":{"id":140,"title":"컴퓨터 그래픽스 - 3강. 컴퓨터 그래픽스 기본요소","content":"# 컴퓨터 그래픽스 - 3강. 컴퓨터 그래픽스 기본요소\n\n## 데카르트 좌표계\n* 하나의 점에서 수직으로 교차하는 직선 축으로 표현되는 좌표계\n* 2차원, 3차원\n* 동차 좌표: n차원 투영공간을 n + 1 개의 좌표로 나타내는 좌표계\n* 2차원 동차 좌표\n* 데카르트 좌표 (x, y)에 대한 동차좌표 표현\n\t* (hx, hy, h), h != 0\n    \n## OpenGL의 점 그리기\n* 꼭지점 좌표의 전달\n* 점 그리기\n\t* `glDrawArrays` 함수 사용\n\n## OpenGL의 선분 그리기\n* mode: GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP 중 하나의 상수를 전달함\n* 직선 방정식: `y = mx + b`\n* 기울기-절편 방정식: `y = mx + yl - mxl`\n\n## DDA 알고리즘\n* Digital Differential Analyzer\n* |m|에 따라 기준 축을 정한 후, 기준 축의 좌표가 1만큼 변화 할 때 나머지 축 좌표의 변화를 구하여 다음 점의 좌표를 계산함\n\t* |m| <= 1인 경우: x축 좌표를 1씩 변화 시킬 때, y축 좌표를 m만큼 변화시켜 다음 점의 좌표를 계산함\n    * |m| > 1인 경우: y축 좌표를 1씩 변화 시킬 때, x축 좌표를 1/m만큼 변화시켜 다음 점의 좌표를 계산함\n    \n```c\nvoid DDA(int x0, int y0, int xEnd, int yEnd)\n{\n\tint dx = xEnd - y0, dy = yEnd - y0, steps, k;\n    float xIncrement, yIncrement, x = x0, y = y0;\n    \n    if (abs(dx) > abs(dy)) steps = abs(dx);\n    else\t\t\t\t   steps = abs(dy);\n    \n    xIncrement = float (dx) / float (steps);\n    yIncrement = float (dy) / float (steps);\n    \n    setPixel(round(x), round(y));\n    for (k = 0; k < steps; k++) {\n    \tx += xIncrement;\n        y += yIncrement;\n        setPixel(round(x), round(y));\n    }\n}\n```\n\n* DDA 알고리즘의 특성\n\t* 기울기 값에 따라 한 축의 좌표는 1, 다른 축의 좌표는 m(m 또는 1/m)만큼 변화 시키며, 다음 좌표를 계산하여 가장 가까운 정수 좌표에 해당되는 픽셀을 그림\n* 문제점\n\t* 부동 소수점을 계산 해야 함\n\t\t* 반올림 및 부동소수점 연산으로 시간이 많이 소요됨\n\t* 긴 선분의 경우 부동소수점 연산의 오차가 누적되어 정확한 직선 경로를 벗어날 수 있음\n\n## Bresenhem의 직선 알고리즘\n* 기울기가 0과 1 사이인 직선을 가정함\n* 매 단계의 판별식의 값은 이전 단계의 판별식에 한 번의 정수 덧셈만 하면 구할 수 있어 실수 연산이 필요한 DDA 알고리즘에 비해 효율적이다.\n* 판별식의 초기값 F(M1)\n* 다음 픽셀 위치의 결정 및 판별식 갱신\n\n### ex) 선분 (1, 1) - (6, 4)\n> W = 5, H = 3\n2H = 6, 2(H-W) = 4\nF = 2H - W = 1\n\n```c\nvoid bresenhem_line (int xl, int yl, int xr, int yr)\n{\n\tint x, y = yl, W = xr - xl, H = yr - yl;\n    int F = 2 * H - W, dF1 = 2 * H, dF2 = 2 * (H - W);\n    \n    for (x = xl; x <= xr; x++) {\n    \tsetPixel(x, y);\n        if (F < 0)\n        \tF += dF1;\n        else {\n        \ty++;\n            F += dF2;\n        }\n    }\n}\n```\n\n\n","thumbnail":"univ.jpg","excerpt":"컴퓨터 그래픽스 - 3강. 컴퓨터 그래픽스 기본요소","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-03-24T14:17:03.004Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"Virtual DOM은 무엇일까?":{"id":141,"title":"Virtual DOM","content":"# Virtual DOM은 무엇인가?\n\n[유튜브영상](youtube.com/watch?v=d7pyEDqBDeE)\n\n## DOM\n> Document Object Model\n\n트리구조로 HTML, XHTML, XML 문서에서 보여주는 기준화된 API\nJavascript를 HTML과 연결해준다.\nDOM Node들은 직접 접근이 가능하다. (ex. getElementById)\nTree의 각 노드들은 html element를 나타낸다\n\n## Web Browser 작동 순서\n> HTML을 파싱하여 DOM Tree를 구성한다\n-> 렌더 트리를 만든다\n-> 렌더 트리의 레이아웃을 구성한다\n-> 렌더 트리를 그린다\n\n* DOM 트리 자체는 HTML 문서를 파싱하는 렌더링 엔진에 의해 생성된다. (ex. Webkit)\n* CSS를 파싱하고 HTML에 파싱된 CSS를 적용하는 하여 렌더 트리를 생성한다\n* 렌더트리가 브라우저에 그려진다.\n\n우리가 node를 변경할때에 위의 일들이 매번 일어난다.\nnode의 변경이 자주 일어날수록, 뷰를 다시 그려주기 위해 브라우저가 받는 부하는 계속 된다.\n굉장히 고비용의 일이 되는 것 이다.\n\n## Virtual DOM을 사용함으로써 해결한 일들\n\n* node들의 변화를 감지하여 바로 그려주는 대신, 먼저 Virtual DOM에 적용한다.\n* Virtual DOM에 적용된 것은 실제 뷰에는 그려지지 않는다. 따라서 저비용의 작업에 해당한다. 새로운 빌딩을 짓는 것과 새로운 빌딩을 짓기위한 청사진을 그리는 것의 차이이다.\n* 또한 Virtual DOM은 효율성을 위해 변화를 한번에 모아서 배치작업을 한다.\n\n## Virtual DOM\n> 단순히 Virtual DOM은 트리구조를 가지는 순수 자바스크립트 객체이다.\n\n가볍고, 메모리 내부에 존재한다. 절대로 실제로 그려지지 않는다. 이 Virtual DOM이라는 아이디어는 React에 의해서 나왔지만, 다른 프런트엔드 프레임워크들에도 사용중이다. (ex. Angular 2, Vue)\n\n\n## React의 Virtual DOM은 어떻게 작동할까?\n* 초기 렌더링 작업에서, JSX는 템플릿 컴파일러에게 in-memory DOM Tree를 어떻게 생성할지 알려준다.\n* `ReactDOM.render()` 함수를 불렀을때에, Virtual DOM Tree를 메모리 내부에서 생성한다.\n\n## State의 변화 다루기\n* 대부분 `setState`함수에 의해서 App이 업데이트 된다.\n* 이 때에 Tree는 완전히 다르게 새로이 생성된다.\n* state가 변할시에 두개의 다른 Virtual DOM이 메모리 내부에 존재하게 된다\n* 이것은 비효율적으로 보이지만, 실제로는 그렇지 않다. React Element들은 굉장히 가볍기 때문이다.\n* 이때에 React는 두개의 Tree를 비교한다. 그리고 두 Tree간의 차이점을 매핑한다.\n* 그 차이점들을 조합하여 패치를 만들어내고, 변화를 실제 DOM에 반영한다.\n* 이때 사용하는 diff 알고리즘은 실제 DOM을 업데이트하기 위해서 최소한의 작업을 찾기 위해 사용된다.\n* 이러한 작업들은 batch되어 처리되어서 매 lifecycle 마다 실제 DOM은 한번만 변화된다.\n\n## Diffing, or \"Reconciliation\"\n* 최소한의 작업을 찾기 위한 것은 `O(n3)` complexity를 가진다.\n* React는 `O(n)`을 사용한다.\n* 어떻게? 두가지 가정에 의존한다.\n\n### 가정 1\n* 서로 다른 타입의 Element들은 서로 다른 Tree를 생성해낸다.\n* 따라서 React는 두개의 서로다른 Tree를 비교할때에 각 트리의 Root Element를 비교한다.\n* 만약 두개의 Root Element가 서로 다른 타입을 가지고 있다면, React는 이전의 Tree를 모두 새로운 Tree로 갈아 엎는다. Root Element 밑의 모든 SubTree를 새로이 그려낸다.\n\n### 가정 2\n* `key` 값을 사용하는 것이 자식 Element들의 변화를 감지하는데 힌트가 되어 줄 수 있다.\n* 성능을 개선하기 위해서는 `key`값들이 모두 안정적이고 예측가능하고 중복된 값이 없어야 한다.\n\n```html\n<ul>\n  <li>John</li>\n  <li>Alice</li>\n</ul>\n```\n\n\n```html\n<ul>\n  <li>John</li>\n  <li>Alice</li>\n  <li>Ed</li>\n</ul>\n```\n\n`key` 값이 없다면 새로운 자식 element가 추가되어도, 모든 자식 element를 모두 다시 그려줘야 한다. 하지만 `key` 값으로 자식 element를 구분할 수 있다면, 어떤 것만 새로이 추가해야 하는지 알 수 있다.\n\n```html\n<ul>\n  <li key=\"9\">John</li>\n  <li key=\"10\">Alice</li>\n  <li key=\"11\">Ed</li>\n</ul>\n```\n\n만약 `key` 값이 예측하지 못하는 random한 값이라면 (ex. Math.random()) React는 예측할 수 없기 때문에 자식 Element가 제대로 그려지지 못하는 현상이 발생 할 수 있다.\n\n## 다음은?\n### React Fiber\n> React의 reconciliation 알고리즘을 다시 쓰는데에 새로 나온 것이다.\nDOM 을 계속 순환하는 대신에, fiber라고 부르는 새로운 데이터 구조를 사용한다.\nFiber는 순수 자바스크립트 객체이며 parent-child node 간 관계를 하나의 linked-list형태로 트래킹한다. 위의 작업들은 \"incremental rendering\" 혹은 \"scheduling\"이라고 불리운다\n\n\n","thumbnail":"unsplash-code-react.jpg","excerpt":"Virtual DOM은 무엇일까?","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-20T13:27:54.602Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"신체건강 문제와 관리(2)":{"id":142,"title":"생활과건강 3강. 신체건강 문제와 관리(2)","content":"# 생활과건강 3강. 신체건강 문제와 관리(2)\n\n## 호흡기계\n* 상기도: 비강, 후두, 인두\n* 하부기도: 기관, 기관지, 세기관지, 폐포\n* 폐: 좌, 우에 1개씩 배치\n* 오른쪽 폐: 3개의 엽 (lobe)\n* 왼쪽 폐: 2개의 엽\n각 폐는 늑막이라는 두겹의 막으로 싸여 보호됨\n\n## 호흡\n> 인체가 산소를 흡입 한 후 세포로 운반하여 세포 대사 작용 소비\n대사 과정에서 생성된 이산화탄소를 체외로 배출하는 과정\n**산소 -> 비강통로 -> 이물질 제거, 가습, 가온 -> 인두 -> 후두 -> 기관 및 좌우 기관지 -> 폐포 (허파꽈리) -> 산소와 이산화탄소 교환**\n\n## 호흡과정\n* 외호흡 (허파호흡): 외부에서 들어온 공기와 폐포의 모세혈관 사이의 가스 교환\n* 내호흡 (조직호흡): 혈액과 조식세포 사이에 일어나는 가스 교환\n\n## 호흡기계 건강 문제\n* 급성 후두염: 급성으로 후두와 주변조직에 염증\n\t* 원인\n    \t* 대부분 바이러스성 감염 (인두염, 후두염, 기관지염 = 감기)\n    \t* 말을 많이 하거나 대기오염물질에 노출이 되었을때\n    * 증상\n    \t* 전신증상, 감기증상 열이 날 수 있다.\n        * 전신의 쇠약감 (전신 증상)\n        * 후두의 이물감 (국소 증상) 혹은 통증\n     * 예방 관리\n     \t* 대부분 자연 치유\n        * 필요시 구강내 가글액\n        * 염증이 오래 지속 된다면 병원 방문\n* 폐렴\n\t* 원인\n    \t* 미생물에 의해 발생하는 폐의 염증, 화학물질이나 방사선 치료 등 비감염성 물질에 의해도 발생 가능\n    * 증상\n    \t* 기저질환과 같이 다르게 나타남\n        * 폐렴구군에 의한 폐렴: 고열, 오한, 기침 등 동반\n        * 상기도 감염 증상\n        * 근육통 등 비특이적 증상\n        * 소화기 증상\n        * 산소 교환에 심각한 장애 시 호흡 부전으로 사망에 이르게 됨\n    * 예방\n    \t* 폐렴구균에 의한 폐렴: 예방 백신 접종\n    * 관리\n    \t* 원인균 진단, 최근 항생제 내성 갖는 병원균이 있을 수 있기 때문에 여러 약물 혼합 해서 처방 받을 수 있음\n\n* 결핵\n\t* 결핵균에 의한 전염성 질환, 1882년 독일의 로버트코흐 박사가 결핵균 발견\n    * 1940년대 이후 항 결핵제 개발\n\t* 결핵 예방 관리 강화 대책\n\t* 원인\n    \t* 사람의 입에서 나온 비말(비말핵)이 퍼져서 전염\n        * 결핵균에 노출되었다해서 모두 결핵에 걸리는 것은 아님\n\t* 증상\n    \t* 천천히 발병, 진전될때까지 증상이 없는 경우가 대부분\n        * 마른 기침 -> 누런 기침 -> 2주이상 지속 이면 결핵 의심\n        * 호흡 곤란, 늑막 통증\n\t* 예방 관리\n    \t* 병력 조사, 흉부 x선 검사\n\t\t* BCG 접종\n\t\t* 약물치료만으로 완치 가능. 처방대로 복용하지 않을 시 내성이 생길 가능성이 있음\n        ","thumbnail":"univ.jpg","excerpt":"신체건강 문제와 관리(2)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-03-20T08:35:59.427Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"어서오세요":{"id":143,"title":"Welcome to ColdSurf blog","content":"# Welcome !\n어서오세요 반갑습니다.\n저는 콜드서프 입니다.\n\n## Who am I ?\n\n```javascript\nconst hello = 'world';\n```","thumbnail":"welcome.jpg","excerpt":"어서오세요","blogArticleCategoryId":1,"isPublic":true,"createdAt":"2022-03-14T13:20:00.000Z","deletedAt":null,"blogArticleCategory":{"name":"etc"},"blogArticleTags":[]},"modal을 위한 웹 표준 태그":{"id":144,"title":"dialog 태그","content":"# <dialog /> 대화 상자 요소\ntabindex 속성을 dialog에 사용해서는 안 된다.\nIE에서는 지원하지 않는다\n\n## 속성\n* open: 대화상자가 활성화 된 상태임을 나타낸다. open이 없을 때에 사용자에게 대화상자가 보여져선 안 된다. \n\n## 예시\n\n### open\n```html\n<dialog open>\n  <p>여러분 안녕하세요!</p>\n</dialog>\n```\n\n### showModal event\n```js\nupdateButton.addEventListener('click', function onOpen() {\n  if (typeof favDialog.showModal === \"function\") {\n    favDialog.showModal();\n  } else {\n    alert(\"The <dialog> API is not supported by this browser\");\n  }\n});\n```\n\n### close event\n```js\nfavDialog.addEventListener('close', function onClose() {\n  outputBox.value = favDialog.returnValue + \" button clicked - \" + (new Date()).toString();\n});\n```\n\n[MDN 문서](https://developer.mozilla.org/ko/docs/Web/HTML/Element/dialog)","thumbnail":"js.png","excerpt":"modal을 위한 웹 표준 태그","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-17T11:17:54.538Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"localStorage와 sessionStorage":{"id":145,"title":"Web Storages","content":"# LocalStorage\n\ndocument 객체 안에 포함.\n\nlocalStorage는 sessionStorage와 비슷하지만 sessionStorage는 session이 만료되면 사라진다.\nlocalStorage는 session이 만료되더라도 사라지지 않는다.\n\nlocalStorage는 http protocol에 따라서 다르게 저장된다.\n\n같은 도메인 호스트를 가지고 있더라도, http와 https에서의 localStorage는 다르다.\n\n자동으로 값은 문자열로 변환되어 저장되며, key, value 형태로 저장된다.\n각 key, value는 2 byte를 최대로 UTF-16 DOMString 형태로 저장한다.\n\n```js\nlocalStorage.setItem(key, value);\nlocalStorage.getItem(key);\nlocalStorage.clear() // localStorage 항목 전체 제거\n```\n\n# Session Storage\n\n브라우저가 열려있는 동안만 값을 저장한다.\n세션 쿠키와는 다르게 새 탭이나 새 페이지를 열면 또 새로운 sessionStorage가 동작.\nhttp protocol에 따라 다르게 동작한다. (http, https)\n각 key, value별로 최대 2 byte까지 저장 가능, UTF-16 DOMString 형태로 저장.\n\n```js\nsessionStorage.setItem(key, value);\nsessionStorage.getItem(key);\n```","thumbnail":"js.png","excerpt":"localStorage와 sessionStorage","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-17T11:06:57.532Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"블로그 만들기 후기":{"id":146,"title":"블로그 프로젝트 (proj. surf-log)","content":"# Proj. surf-log (블로그  프로젝트)\n\n[github repo](https://github.com/coldsurfers/surf-log)\n\n## 1. Spec\n\n* NextJS + Typescript\n* marked + codemirror + prismjs\n\n## 2. markdown meta build 기능 구현\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst matter = require('gray-matter')\n\nconst thumbnailDirPathStr = '../thumbnails'\n\nfunction generateUniqSerial() {\n    return 'xxxx-xxxx-xxx-xxxx'.replace(/[x]/g, (c) => {\n        const r = Math.floor(Math.random() * 16)\n        return r.toString(16)\n    })\n}\n\nfunction main() {\n    const mdFilesDirectoryPath = path.resolve(__dirname, '../articles')\n    const mdFileNames = fs.readdirSync(mdFilesDirectoryPath, 'utf8')\n    const mdFilesMetaArray = mdFileNames\n        .map((fileName) => {\n            const mdFilePath = path.resolve(\n                __dirname,\n                `../articles/${fileName}`\n            )\n            const mdFileContent = fs.readFileSync(mdFilePath, 'utf8')\n            const mdFileMeta = matter(mdFileContent, {\n                excerpt: function (file, options) {\n                    file.excerpt = encodeURI(file.data.excerpt)\n                    if (file.data.thumbnail) {\n                        const thumbnailFileBase64Encoded = fs.readFileSync(\n                            path.resolve(\n                                __dirname,\n                                `${thumbnailDirPathStr}/${file.data.thumbnail}`\n                            ),\n                            'base64'\n                        )\n                        file.thumbnailBase64 = thumbnailFileBase64Encoded\n                    }\n                },\n            })\n            return mdFileMeta\n        })\n        .sort((a, b) => {\n            return new Date(a.data.createdAt) - new Date(b.data.createdAt)\n        })\n        .reduce((prev, curr) => {\n            if (prev.find((prevItem) => prevItem.excerpt === curr.excerpt)) {\n                curr.excerpt = `${curr.excerpt}-${generateUniqSerial()}`\n            }\n            return prev.concat(curr)\n        }, [])\n        .sort((a, b) => {\n            return new Date(b.data.createdAt) - new Date(a.data.createdAt)\n        })\n\n    const categories = mdFilesMetaArray\n        .map((meta) => meta.data.category)\n        .filter((value, index, self) => self.indexOf(value) === index)\n\n    const mdFilesMeta = mdFilesMetaArray.reduce((prev, curr) => {\n        prev[curr.excerpt] = curr\n        return prev\n    }, {})\n\n    const metaFilePath = path.resolve(__dirname, '../public/article-meta.json')\n\n    const meta = {\n        articles: mdFilesMeta,\n        categories,\n    }\n    fs.writeFileSync(metaFilePath, JSON.stringify(meta))\n}\n\nmain()\n\n```\n\n## 3. editor 기능 구현\n[codemirror](https://codemirror.net/)로 editor 기능을 구현하였다.\n\n## 4. markdown renderer 기능 구현\n[marked](https://www.npmjs.com/package/marked) 모듈을 사용하여 markdown으로 작성된 string text를 html로 변환\nprismjs로 코드 부분 Highlight\n\n## 5. markdown 파일 쓰기(write) 기능 구현\nnext page api를 사용하여 구현.\n\n```typescript\nimport { NextApiHandler } from 'next'\nimport fs from 'fs'\nimport path from 'path'\n\nfunction generateUniqSerial() {\n    return 'xxxx-xxxx-xxx-xxxx'.replace(/[x]/g, (c) => {\n        const r = Math.floor(Math.random() * 16)\n        return r.toString(16)\n    })\n}\n\nconst SaveAPI: NextApiHandler = (req, res) => {\n    if (req.method === 'POST') {\n        const { title, excerpt, category, thumbnail, text } = req.body\n        let articlePath = path.resolve(\n            __dirname,\n            `../../../../articles/${title}.md`\n        )\n        if (fs.existsSync(articlePath)) {\n            articlePath = path.resolve(\n                __dirname,\n                `../../../../articles/${`${title}-${generateUniqSerial()}`}.md`\n            )\n        }\n        let content = `---\ntitle: ${title}\nexcerpt: ${excerpt}\ncategory: ${category}\nthumbnail: ${thumbnail}\ncreatedAt: ${new Date().toISOString()}\n---\n${text}`\n        fs.writeFileSync(articlePath, content)\n        return res.status(200).json({\n            error: null,\n        })\n    }\n    return res.status(501).json({\n        error: 'not implemented',\n    })\n}\n\nexport default SaveAPI\n\n```\n\n## 6. markdown meta 정보 가져오기\nnextjs server side api를 사용하여 다음과 같이 초기 fetching 후 pageProps로 페이지에 전달\n```typescript\nexport const getStaticProps: GetStaticProps<ServerProps> = async (ctx) => {\n    const articleMeta = (await import('../../public/article-meta.json')) as {\n        articles: {\n            [key: string]: Article\n        }\n        categories: string[]\n    }\n    return {\n        props: {\n            articles: Object.entries(articleMeta.articles).map(\n                ([key, content]) => content\n            ),\n        },\n    }\n}\n```\n\n## 7. emotion으로 스타일링\n[emotion](https://emotion.sh/docs/introduction)을 사용하여 style 코드 작성.\n꽤나 편리하다. styled-components가 제공해주는 기능도 제공하면서 css로 children의 tag들도 모조리 styling 할 수 있는게 장점이다.\n```jsx\nimport { css } from '@emotion/css'\n\n...\n\n<SaveModal\n    className={css`\n        label {\n            font-weight: bold;\n        }\n        input {\n            height: 1.5rem;\n            margin-top: 0.5rem;\n        }\n\n        input + label {\n            margin-top: 0.8rem;\n        }\n\n        button {\n            margin-top: 1rem;\n            font-weight: bold;\n            background-color: #000000;\n            border: 1px solid #000000;\n            border-radius: 3px;\n            color: #ffffff;\n            cursor: pointer;\n            height: 1.95rem;\n\n            &:active {\n                background-color: #ffffff;\n                color: #000000;\n            }\n        }\n    `}\n>\n    <label>Title</label>\n    <input\n        name=\"title\"\n        value={modalValues.title}\n        onChange={handleChange}\n    />\n    <label>Excerpt</label>\n    <input\n        name=\"excerpt\"\n        value={modalValues.excerpt}\n        onChange={handleChange}\n    />\n    <label>Category</label>\n    <input\n        name=\"category\"\n        value={modalValues.category}\n        onChange={handleChange}\n    />\n    <label>Thumbnail</label>\n    <input\n        name=\"thumbnail\"\n        value={modalValues.thumbnail}\n        onChange={handleChange}\n    />\n    <button onClick={handleClickSaveModalSave}>save</button>\n</SaveModal>\n```\n앞으로 애용할 것 같다.\n\n## 8. 배포\n\nvercel을 사용하여 domain 연결 후 배포\n\n## 9. 깃 전략\n\ngit flow를 사용\n","thumbnail":"nextjsimage.png","excerpt":"블로그 만들기 후기","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-17T12:46:03.222Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"promise, worker, animation":{"id":147,"title":"JS Asynchronous 간략 설명","content":"# JS Asynchronous\n\n## Promise\n\nPromise와 같은 비동기 작업은 eventQueue에 들어간다.\nmain thread가 끝난 후 실행되어 Javascript의 block 현상을 막는다.\nqueued된 작업들은 가능한 빨리 실행되어 Javascript 환경으로 결과를 반환해준다.\n\n## Worker\n\n분리된 thread에서 태스크들을 실행 가능하게 한다.\n하지만 여러 thread를 동시에 사용한다면 동시성을 보장하기 어렵다.\n따라서 이러한 사이드 이펙트를 막기 위해서 main 쪽 코드와 worker의 코드는 완벽히 분리되어야 한다. 같은 변수를 공유하면 사이드 이펙트가 일어난다.\n\n### 종류\n* Shared Worker\n* Dedicated Worker\n* Service Worker\n\n## Animation\n\n```js\nelement.animate();\n```\n\n### 예시\n\n```js\nconst aliceTumbling = [\n  { transform: 'rotate(0) scale(1)' },\n  { transform: 'rotate(360deg) scale(0)' }\n];\n\nconst aliceTiming = {\n  duration: 2000,\n  iterations: 1,\n  fill: 'forwards'\n}\n\nconst alice1 = document.querySelector(\"#alice1\");\nconst alice2 = document.querySelector(\"#alice2\");\nconst alice3 = document.querySelector(\"#alice3\");\n\nalice1.animate(aliceTumbling, aliceTiming);\n```","thumbnail":"js.png","excerpt":"promise, worker, animation","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-17T11:32:19.056Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"3강. 데이터 통신의 기초(II) 데이터 통신의 요소(I)":{"id":148,"title":"정보통신망 - 3강. 데이터 통신의 기초(II) 데이터 통신의 요소(I)","content":"# `전송 방향`\n\n### 단방향 전송\n* 정보 전달의 방향이 한 방향\n\n### 반이중 전송\n* 정보 전달 방향이 교대로 이루어 지는 방식\n* 무전기\n* 통신 채널이 2개 필요\n* 정보 흐름을 바꾸기 위해서는 시간이 필요\n\n### 전이중 전송\n* 동시에 양방향 모두 전송이 가능\n\n# `전송 모드`\n\n### 병렬 전송\n* 부호화된 코드의 모든 비트가 동시에 전송\n* 근거리 데이터 전송\n\n### 직렬 전송\n* 원거리 데이터 전송\n\n# `전송 동기`\n### 비트 동기\n* 송 수신측에 동일한 클럭 사용\n* 비트 검출 위치는 각 비트의 중앙\n\n### 문자 동기\n* 비트들을 그룹지어 원하는 문자를 구성\n* 동기식 전송 방식\n* 비동기식 전송 방식\n\n### 동기식 전송\n* ASCII 문자 전송\n* 전송 제어 문자 SYN 사용\n\n### 비동기식 전송\n* 한 문자씩 전송, 문자 사이에는 특별한 시간적 제약이 없음\n* 시작펄스 / 정지펄스\n\n# `전송 효율`\n\n* 정보 비트 수 / 총 전송 비트 수 * 100\n\n# `통신 선로`\n\n### 2선식\n* 신호선과 공통 접지선이 2개로 구성\n* 주로 저속 회선에서 사용 / 반이중 통신에 해당\n\n### 4선식\n* 전이중\n\n### 점대점 선로\n* 점대 점으로 두 단말기를 연결하는 통로\n* 단말기 <-----> 단말기\n\n### 성형 네트워크\n* 멀티드롭 선로: 복수개의 단말기가 연결된 하나의 선로, 선로 통신용량의 공유 -> 전용선보다 통신 선로의 효율성이 높음, 데이터 충돌 가능(선로제어 프로토콜 필요)\n\n### 집선 선로\n* 다수 회선의 호출을 집약하여 그보다 적은 수의 중계선으로 전송\n\n","thumbnail":"univ.jpg","excerpt":"3강. 데이터 통신의 기초(II) 데이터 통신의 요소(I)","blogArticleCategoryId":4,"isPublic":true,"createdAt":"2022-03-18T01:45:51.151Z","deletedAt":null,"blogArticleCategory":{"name":"univ"},"blogArticleTags":[]},"http 상태 코드에 대해서 알아봅시다":{"id":149,"title":"HTTP Status Code","content":"# HTTP 상태 코드 (HTTP Status Code)\n\n웹 브라우저가 서버에 http 요청을 할 경우, 성공 혹은 실패 여부 및 다음 행동으로 무엇을 해야 하는지 알려주는 상태 코드이다.\n\n그룹은 5개 그룹으로 나누어 진다.\n\n# 100번대 (Information): 정보 응답\n* 100 (continue): 서버가 request header는 받았고, 클라이언트가 request body를 보내고 있는 상태\n* 101 (switching protocols): 요청자가 서버에게 switching protocol 을 묻는 상태\n* 102 (processing): 요청자가 서버에게 요청 하였고, 서버가 이를 처리하였지만 응답이 없는 상태\n* 103 (checkpoint): 중단된 Put과 Post 요청을 되찾을 수 있는 request를 사용하는 상태\n\n# 200번대 (Successful): 성공 응답\n* 200 (ok): 에러없이 성공이 완료된 상태\n* 201 (created): request가 되었고, 요청을 바탕으로 새로운 자원이 만들어진 상태\n* 202 (accepted): 서버가 request를 전송 받았으나, 현재 완전하게 처리되지 않은 상태\n* 203 (non-authoritative information): 서버가 클라이언트 요구 중 일부만 전달한 상태\n* 204 (no content): request 요청을 처리 후 클라이언트에게 전달 할 컨텐츠가 없는 상태. 주로 삭제 요청 후 status code로 쓰인다.\n* 205 (reset content): no content 상태라서 클라이언트의 뷰가 reset이 필요한 상태\n* 206 (partial content): 클라이언트의 header 범위 문제로 서버가 자원의 일부만을 전달**받은** 상태\n* 207 (multi-status): 멀티-상태 응답은 다수의 리소스가 여러 개의 상태 코드인 상황이 적절한 경우에 해당되는 정보를 서비스에 전달한 상태 (*사실 무슨 말인지 잘 모르겠다*)\n* 208 (multi-status): 멀티-상태 읍응답 DAV에서 사용, propstat(property와 status의 합성어) 응답 속성으로 동일 컬렉션으로 바인드된 복수의 내부 멤버를 반복적으로 열거하는 것을 피하기 위해 사용하는 상태 (*사실 무슨 말인지 잘 모르겠다*)\n* 226 (IM Used): 서버가 GET 요청에 대한 리소스를 처리했으며, 응답이 하나 또는 그 이상의 인스턴스 조작이 현재 인스턴스에 적용이 되었음을 알리는 상태\n\n# 300번대 (Redirection): 리다이렉션 응답\n* 300 (Multiple Choices): 최대 다섯개의 링크를 골라서 이동할 수 있는 상태\n* 301 (permanently moved): 요청된 페이지가 새로운 URL로 이동 된 상태\n* 302 (found): 요청된 페이지가 일시적으로 새 URL로 이동 된 상태\n* 303 (see other): 요청된 페이지는 다른 URL에서 찾을 수 있는 상태\n* 304 (not modified): 마지막 요청 이후 수정되지 않은 상태\n* 305 (use proxy): location 필드에 proxy의 URL을 사용하는 상태\n* 306 (switch proxy): 사용하지 않는 코드\n* 307: Temporary Redirect 302 Found HTTP 응답 코드와 동일한 의미를 가지고 있으며, 사용자 에이전트가 반드시 사용된 HTTP 메소드를 변경하지 말아야 하는 점만 다른 상태\n* 308: Permanent Redirect 301 Moved Permanently HTTP 응답 코드와 동일한 의미를 가지고 있으며, 사용자 에이전트가 반드시 HTTP 메소드를 변경하지 말아야 하는 점만 다른 상태\n\n# 400번대 (Client Error): 클라이언트 에러 응답\n* 400 (Bad Request): 요청에 대한 문법적 오류가 있어서 서버가 이해할 수 없는 상태. 주로 전달 받은 요청의 자원의 불충분함을 나타낼 때 쓴다.\n* 401 (Unauthorized): 특정 요청이 인증이 되지 않아서 권한이 없는 상태\n* 402 (Payment Required): 최신 status code 인데 아직 쓰지 않는 걸로 알고 있음. 추후 payment 서비스에서 결제를 요할때 쓰는 것으로 알고 있다.\n* 403 (Forbidden): 요청이 인증은 되었지만, 요청한 자원에 대해서는 접근 할 권한이 없는 상태. 401은 인증이 되지 않아서 누구인지 모르는 상태이지만 403는 인증은 되어서 요청자가 누구인지는 알고 있으나 요청한 자원에 대한 권한은 없음을 알리는 상태이다.\n* 404 (NotFound): 요청한 자원을 찾을 수 없는 상태\n* 405 (Method Not Allowed): 요청의 method가 제공되지 않은 상태\n* 406 (Not Acceptable): request에서 accept header에 not acceptable의 내용을 가진 자원을 요청한 상태\n* 407 (Proxy Authentication Required): 프록시 서버에게 해당 요청이 수행되도록 인증을 받아야 하는 상태\n* 408 (Request Timeout): 요청 대기시간이 지난 상태\n* 409 (Conflict): request 충돌로 인해서 요청이 완료되지 않은 상태, 생성 요청인데 이미 생성되어 있는 상태\n* 410 (Gone): 요청 페이지는 더 이상 사용할 수 없는 상태\n* 411 (Length Required): Content-Length 부분이 빠져서 요청을 허가하지 않은 상태\n* 412 (Precondition Failed): request 헤더 필드에 선결 조건에 대한 값이 서버에서 false가 나온 경우\n* 413 (Request entity too large): 요청 엔티티를 서버가 처리하기에 너무 큰 상태\n* 414 (Request-URI Too Long): 요청 URI가 너무 긴 상태\n* 415 (Unsupported Media Type): 지원하지 않는 미디어 타입을 요청한 상태\n* 416 (Requested Range Not Satisfiable): 클라이언트가 파일의 일부를 요청했을 때 서버가 지원하지 않는 상태\n* 417 (Expectation Failed): Expect request-header 필드의 요구를 서버가 충족시킬 수 없는 상태\n* 418 (im a teapot): HTTP 418 I'm a teapot 클라이언트 오류 응답 코드는 서버가 찻주전자이기 때문에 커피 내리기를 거절했다는 것을 의미합니다. 이 오류는 1998년 만우절 농담이었던 하이퍼 텍스트 커피 포트 제어 규약(Hyper Text Coffee Pot Control Protocol)의 레퍼런스입니다.\n* 422 (Unprocessable Entity): 요청은 잘 전달 됐지만, 문법 오류가 난 상태\n* 429 (Too Many Requests): 사용자가 지정된 시간에 너무 많은 요청을 보낸 상태\n\n# 500번대 (Server Error): 서버 에러 응답\n* 500 (Internal Server Error): 포괄적인 서버 에러 메시지, 서버가 에러가 왜 났는지 어떻게 처리해야하는지 아직 모르는 상태. 서버 측에서 특정 에러에 대한 핸들링이 되어있지 않다.\n* 501 (Not Implemented): 서버가 해당 요청 메소드를 인식 못하거나, 이행할 능력이 없는 상태\n* 502 (Bad Gateway): 게이트웨이나 프록시의 상태가 나쁘거나 과부하인 상태\n* 503 (Service Unavailable): 일시적으로 서비스가 사용 불가능 한 상태, (임시 조건에 사용되어야 하며, Retry-After: HTTP 헤더는 가능하면 서비스를 복구하기 전 예상 시간을 포함해야 함)\n* 504 (Gateway Timeout): 과부하 등의 이유로 게이트웨이나 프록시의 한계 대기 시간이 지난 상태\n* 505 (HTTP Version Not Supported): request에서 사용한 HTTP 프로토콜을 서버가 지원하지 않는 상태\n* 511 (Network Authentication Required): 클라이언트의 접근을 위한 네트워크 인증이 필요한 상태\n\n> 참고자료\nhttp://www.incodom.kr/Status_code\nhttps://developer.mozilla.org/ko/docs/Web/HTTP/Status/418\n\n\n\n","thumbnail":"418.jpg","excerpt":"http 상태 코드에 대해서 알아봅시다","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-18T07:35:12.184Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"웹 클라이언트를 구성하는 방식들은 무엇이 있을까? 그리고 어떻게 다른가?":{"id":150,"title":"JAM Stack 그리고 SPA, CSR, SSR","content":"# JAM Stack 그리고 SPA, CSR, SSR\n\n# 목차\n1. JAM Stack 이란 무엇인가?\n2. JAM Stack은 SSR / CSR과 어떻게 다를까?\n3. 그럼 SSR 방식은 필요가 없어진 것 일까?\n\n\n## 1. JAM Stack 이란 무엇인가?\n* J: Javascript\n* A: API\n* M: Markup\n\nJavascript와 API 그리고 Markup(HTML)으로만 이루어진 웹의 구성을 이야기 한다.\n우리가 알고 있는 SPA 과는 비슷하지만 다르다고 한다.\nJAM Stack은 특정 기술 (ex. React, Vue)을 채택하는 것과는 다른 관점이며, 이들을 이용해서 웹사이트를 어떻게 구성할지에 대한 관점이다.\n\n> **JavaScript**\nClient 의 모든 처리는 Javascript 에게 맞긴다.\n**API**\n모든 기능 및 비즈니스 로직은 재사용 가능한 API 로 추상화한다.\n**Markup**\nSSG (Static Site Generator) 나 Template Engine (Webpack 등) 을 이용하여 Markup 을 미리 생성한다.\n\n\n비슷하게 `MERN Stack`이 있다.\n* M: Mongo DB\n* E: Express\n* R: React\n* N: Node.JS\n\n## 2. JAM Stack은 SSR / CSR과 어떻게 다를까?\n\nReact, Angular, Vue와 같은 모던 웹 프레임워크 및 라이브러리가 나오기 전에 SSR로 웹 사이트를 보여주었다. SSR이라 함은 브라우저의 요청을 받아 서버에서 html을 내려주어 렌더링 해주는 방식을 말한다. 하지만 이러한 방식은 CSR에 비해 서버의 자원을 많이 쓰게 되므로 그런 부분에서 비효율 적이다.\n또한 속도측면에서도 CSR은 서버를 타지 않고 렌더링을 해주기 때문에, SSR에 비해 효율적이다.\n페이지를 이동할 때 마다 서버에서 html을 받아서 뷰를 그려주는 것보다는 http request를 통해서 필요한 자원만 받아서 뷰에 그려주는 것이 속도상 이점이 있기 때문이다.\n\n그래서 React와 같은 SPA (Single Page App) 프레임워크 및 라이브러리는 html 마크업 부분은 사실상 title 및 meta 를 나타내는 head 태그와 body 태그내에서 javascript를 이용하여 렌더링 할 tag를 지정해주는 태그 외에는 많은 부분이 비어있다.\n\nSPA 방식은 서버에서 의존하던 클라이언트를 그려주는 방식에서 많이 탈피한 방식이다.\n서버에서 html을 그리는데 필요한 자원을 모두 받아오는 SSR 방식에서 서버에서는 필요한 자원(클라이언트와 분리된 서버 API를 통해서)만을 받아오며 html은 기본 토대만을 담당 하며 나머지 클라이언트에서 보여주는 모든 뷰들은 자바스크립트와 css가 담당한다.\n\n## 3. 그럼 SSR 방식은 필요가 없어진 것 일까?\nSPA를 통한 CSR 방식은 다음과 같은 두가지 단점을 가진다.\n1. SSR에 비해서 첫 그림을 그려주기 전 까지 딜레이가 걸린다.\n2. HTML이 거의 비어있기 때문에, SEO (검색엔진 최적화)에 좋지 않다.\n\nSPA를 사용한 CSR 방식은 위 두가지 단점에도 너무나 매력적인 스택이기 때문에, 위 두가지 단점을 보완하고자 하는 방식들이 나오게 되었다.\n\n예를들면 부분적으로 SSR 방식을 채택한 Next (React)와 Nuxt (Vue) 등이 있다.\n첫 페이지는 SSR로 보여주고, 나머지는 SPA의 javascript를 사용하여 CSR로 보여주는 방식이다.\n이로써 단점 1번을 보완하여 첫 페이지는 완성된 html을 보여주어 `First meaningful paint`의 속도를 향상시키고 단점 2번을 보완하여 검색 봇이 html을 크롤링 해서 SEO를 향상 시켰다.\n\n\n\n\n","thumbnail":"unsplash-code-react.jpg","excerpt":"웹 클라이언트를 구성하는 방식들은 무엇이 있을까? 그리고 어떻게 다른가?","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-19T06:26:37.017Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"간단히 SOLID 원칙 정리":{"id":151,"title":"SOLID 원칙","content":"# SOLID 원칙\n\n## SOLID 원칙의 개요\n컴퓨터 프로그래밍에서 SOLID란 로버트 마틴이 2000년대 초반에 명명한 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 마이클 페더스가 두문자어 기억술로 소개한 것이다.\n프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용할 수 있다.\nSOLID 원칙들은 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩터링하여 코드 냄새를 제거하기 위해 적용할 수 있는 지침이다. 이 원칙들은 애자일 소프트웨어 개발과 적응적 소프트웨어 개발의 전반적 전략의 일부다.\n\n> 자료\nhttps://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)\n\n좀 더 나은 코드의 품질을 위해 클린 코드를 지향하는 원칙인 것 같다.\n프로젝트 사이즈가 커지면서 혹은 프로젝트 사이즈가 작더라도, 각 클래스가 맡은 일에 최대한 영향을 받지 않으면서 어떻게 깔끔한 코드를 작성 하는가에 대한 논리이다.\n\n객체 지향 설계라고 나와있으나, 굳이 객체 지향 방법을 따르지 않는 react같은 라이브러리의 방식에도 적용할 수 있다.\n\n사람이 이해할 수 있는 코드를 만드는데에 있어서 알고 있으면 굉장히 도움이 되는 원칙이라고 할 수 있다.\n\n## SOLID 원칙의 내용\nSOLID 원칙은 다음과 같이 5개로 나뉜다.\n\n### S: 단일 책임 원칙 (Single responsibility principle)\n>한 클래스는 하나의 책임만 가져야 한다.\n\n단일 책임 원칙에 의하면 하나의 클래스는 하나의 책임, 즉 하나의 하는 일에만 집중해야 한다.\n하나의 클래스가 하는 일이 여러개로 뭉쳐져 있다면, 클래스를 수정시에 다른 일들에 엮여서 깔끔하지 않을 가능성이 높다. 관심사를 분리하여 최대한 잘게 나누어 하나의 클래스는 하나의 일에 집중하도록 만들어야 추후 코드를 변경 할 시에도 안전하게 변경할 수 있다.\n\n### O: 개방-폐쇄 원칙 (Open/closed principle)\n> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.\n\n만약 우리가 하나의 모듈을 수정했다고 가정 할 때에, 그 수정으로 인해 이 모듈을 쓰는 다른 곳에서 똑같이 수정을 해줘야 한다면 규모가 큰 프로젝트에서는 굉장히 많은 수정작업이 일어나야 한다.\n따라서 무엇을 수정하여 모듈의 사용성을 확장 할 때에는, 이 모듈을 사용하던 기존의 코드를 **수정**하는 것이 아닌 코드를 **추가**하여 확장성을 넓히는 방향으로 가야한다.\n\n```js\nlet cakeMaker = {\n\tavailableFlavor: ['chocolate', 'milk chocolate', 'strawberry'],\n  \tmakeCake: function(flavor) {\n    \tconst cake = this.availableFlavor.find((v) => v === flavor)\n        if (cake) {\n        \treturn cake\n        } else {\n        \tthrow Error(`We don't have ${flavor} flavor`)\n        }\n    }\n}\n```\n\n더 많은 맛을 가진 케익을 만들고 싶다면, 이 cakeMaker 코드에서 availableFlavor를 늘려주는 것이 아닌 아래와 같이 `addFlavor` 함수를 추가하여 이 cakeMaker를 사용하는 쪽에서 변경하는 것이 좋다.\n\n```js\nlet cakeMaker = {\n\tavailableFlavor: ['chocolate', 'milk chocolate', 'strawberry'],\n    makeCake: function(flavor) {\n    \tconst cake = this.availableFlavor.find((v) => v === flavor)\n        if (cake) {\n        \treturn cake\n        } else {\n        \tthrow Error(`We don't have ${flavor} flavor`)\n        }\n    },\n    addFlavor: function(flavor) {\n    \tthis.availableFlavor = this.availableFlavor.concat(flavor)\n    }\n}\n```\n\n### L: 리스코프 치환 원칙 (Liskov substitution principle)\n> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.\n\n하나의 인터페이스로부터 파생된 인터페이스를 만들고, 파생된 하위 인터페이스에서 확장을 한다.\n\n### I: 인터페이스 분리 원칙 (Interface segregation principle)\n> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다\n\n여러 기능이 모여진 인터페이스라면, 한 기능을 사용할때에는 다른 기능을 사용하지 않을 가능성이 생긴다. 따라서 이런 기능들을 분리하여 따로 인터페이스를 구현한다.\n\n```typescript\ninterface Phone {\n\tcall: {\n    \tphotoShoot: () => void\n        callTo: (phoneNumber: string) => void\n    }\n}\n```\n\n위와같이 call에서 photoShoot을 사용하는 일은 드물 것이다, 하지만 Phone객체는 photoShoot기능이 필요하다. 따라서 photoShoot기능은 call에서 분리한다.\n\n```typescript\ninterface Phone {\n\tcall: {\n        callTo: (phoneNumber: string) => void\n    }\n    photoShoot: () => void\n}\n```\n\n### D: 의존관계 역전 원칙 (Dependency inversion principle)\n> 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.\n\n확장성이 필요할 시 이미 구현되어있는 구현체에서 작업을 한다기 보다는, 하나의 기능을 더 늘려서 새로운 인터페이스를 만든다. 그 새로이 추가된 인터페이스에서 확장성을 구현한다.\n\n즉 새로운 기능을 하나 만들어서, 기존 있던 기능을 확장을 위해 고쳐서 사이드이펙트를 만드는 상황을 줄인다.\n\n","thumbnail":"unsplash-programming.jpg","excerpt":"간단히 SOLID 원칙 정리","blogArticleCategoryId":2,"isPublic":true,"createdAt":"2022-03-19T07:39:59.979Z","deletedAt":null,"blogArticleCategory":{"name":"dev"},"blogArticleTags":[]},"react + pwa + webpack PWA 적용하기":{"id":152,"title":"react + pwa + webpack PWA 적용하기","content":"# PWA 적용하기\n\n## 1. 노드 모듈 인스톨\n\npwa에 관련한 웹팩 모듈을 인스톨 해준다.\n\n```bash\nyarn add -D webpack-pwa-manifest workbox-webpack-plugin\n```\n\n## 2. manifest.json 파일 생성\n\n`public/manifest.json`\n\n```json\n{\n    \"name\": \"react-webpack\",\n    \"short_name\": \"react\",\n    \"description\": \"react todo list app with pwa\",\n    \"background_color\": \"#ffffff\",\n    \"crossorigin\": \"use-credentials\",\n    \"theme_color\": \"#eeeeee\",\n    \"filename\": \"manifest.json\"\n}\n```\n\n## 3. webpack 설정 추가\n\n`webpack.config.js`\n\n```js\n...\nconst WebpackPwaManifest = require('webpack-pwa-manifest')\nconst { GenerateSW } = require('workbox-webpack-plugin')\nconst manifest = require('./public/manifest.json')\n\n...\n\nconst pwaPlugin = new WebpackPwaManifest(manifest)\n\nconst workboxPlugin = new InjectManifest({\n    swSrc: './src/sw.js',\n    swDest: 'sw.js',\n})\n...\n\n{\n    ...\n    plugins: [htmlPlugin, cssPlugin, pwaPlugin, workboxPlugin],\n}\n```\n\n`src/sw.js`\n\n```js\nworkbox.core.skipWaiting()\nworkbox.core.clientsClaim()\n\nworkbox.routing.registerRoute(\n    new RegExp('https://jsonplaceholder.typicode.com'),\n    new workbox.strategies.StaleWhileRevalidate()\n)\n\nself.addEventListener('push', event => {\n    const title = 'Get Started With Workbox'\n    const options = {\n        body: event.data.text(),\n    }\n    event.waitUntil(\n        self.ServiceWorkerRegistration.showNotification(title, options)\n    )\n})\n\nworkbox.precaching.precacheAndRoute(self.__precacheManifest)\n```\n\nmanifest 와 service worker 설정까지 추가하였다.\n\n## 4. serviceWorker 작동 시키기.\n\n`src/index.js`\n\n```jsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport Root from './components/Root'\nimport './styles/index.scss'\n\nReactDOM.render(<Root />, document.getElementById('root'))\n\nif ('serviceWorker' in navigator) {\n    window.addEventListener('load', () => {\n        navigator.serviceWorker\n            .register('/sw.js')\n            .then(registration => {\n                console.log('SW registered', registration)\n                registration.pushManager.subscribe({ userVisibleOnly: true })\n                Notification.requestPermission().then(p => {\n                    console.log(p)\n                })\n            })\n            .catch(e => {\n                console.log('SW registration failed: ', e)\n            })\n    })\n}\n```\n\n개발자 도구를 켜고 Application 탭을 클릭한 후, Sercice Workers 탭을 클릭 하면 서비스 워커가 잘 붙은것을 볼수 있다.\n또한 offline 으로 설정 한뒤 새로고침을 해도 새로고침 후 오프라인에서도 앱이 동작하는 것을 볼수 있다.\nrunTimeCaching 옵션에서 jsonplaceholder URL을 등록하였기 때문이다.\n\n마지막으로 푸쉬 노티피케이션까지도 구현되었다. 테스트는 Application 탭의 Service Workers 아래에 push 버튼을 눌러보면 할수있다.\n\n","thumbnail":"Velog.png","excerpt":"react + pwa + webpack PWA 적용하기","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2019-12-23T03:19:13.569Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"나의 이직기":{"id":153,"title":"나의 이직기","content":"# 나의 이직기\n\n안녕하세요?\n오늘 제가 쓸 글은 이직을 하면서 느꼈던 점과,\n저의 첫 이직을 하면서 있었던 이야기들에 대한 내용입니다.\n\n1. 왜 이직을 하게 되었는가?\n\n이유는 간단합니다. 회사에서 할 일이 없었습니다..\n물론, 면접관들이 물어봤을때엔 이런식으로 답하진 않았습니다. :)\n\n> 이직을 하게 된 주된 이유는, 개발 환경에 대한 아쉬움이 컸기 때문입니다. 개발 문화가 자리 잡지 않아, 주니어 개발자인 저에게는 회사에서 일을 하며 성장 할 수 있을까? 라는 의문이 들기 시작했고, 좀더 나은 개발 문화를 가진 조직을 찾아 나서게 되었습니다.\n\n라고 답변 한 것 같네요. \n\n2. 이력서 / 서류 준비\n\n저는 일단 원티드를 통해서, 이력서 및 서류 접수를 했습니다.\n(원티드... 수습기간 끝나면, 50만원 챙길... 읍읍)\n\n물론, 금전적 이유도 있고 하지만 원티드는 제가 평소에도 즐겨 보는 앱입니다. 이유는, 개발 모집 관련 글을 보면서 \"아 요즘에 프런트엔드 쪽은 이런 기술을 원하는 구나\" 혹은, \"아 요즘 회사들은 이런 기술을 프런트엔드 쪽에서 주로 쓰는구나\" 하는 최신 동향들을 바로 알 수 있기 때문이었지요.\n\n또한, 프런트엔드 개발 직군이 아닌 백엔드나 머신러닝, 혹은 Ops쪽의 모집요강도 살펴보며 \"요즘 회사들은 이런식으로 개발팀을 꾸려 나가는 구나\" 라는 생각도 할 수 있습니다.\n\n주니어 개발자인 저로 써는 제가 학생때 부터 해왔던 작업물을 포함하여, 최대한 제가 개발했던 내용들을 자세히 쓰려고 노력했습니다.\n\n처음에 이력서를 돌릴때에는, 너무 대충 썼다는 느낌을 제가 강하게 받았습니다. 이유는 제 사이드 프로젝트에 대한 내역을 깊게 안썼고, 회사 이력도 간단하게만 써서 그런 것 같습니다.\n\n처음 이력서를 돌린 회사들에는 당연히 저의 개발이력에 대해 알기가 힘들었고, (주니어 개발자이고, 첫 직장이었으므로 직장에 대한 이력만 가지고는 파악하기 힘들수도 있다는 생각이었습니다.) 따라서 서류 불통과 소식이 들려왔습니다.\n\n이것을 계기로 마음먹었습니다. \"아 좀더 자세하게 나의 개발을 알려야 하는구나!\" 라는 생각이 들면서, 영혼을 끌어모아 제가 했던 사이드 프로젝트들을 적어나가기 시작했습니다.\n\n그러다보니 두번째 개정판 이력서가 완성 되더군요.\n\n이 이력서로 5~7군데 정도 돌린 것 같습니다. 거기서 면접을 보러간 회사는 총 3군데 였습니다.\n\n> 이력서는 지원하는 회사가 최대한 자신을 많이 알 수 있도록, 혹은 나에대해 궁금증을 가질 수 있도록 써라! 라는 것을 느꼈던것 같네요 :) 회사가 나에대해 궁금해야 면접도 보고 싶기 마련이겠죠?\n\n3.  코딩 테스트 혹은 과제와 면접\n\n드디어,,, 불통소식만 듣던 제가 서류 통과가 된 기업들이 몇개 생기기 시작했습니다.\n\n일단 서류 불통만 되던 저에게는 굉장히 기쁜 일이었습니다.\n\n요즘 개발 직군을 뽑는 회사들은 대부분 사전 과제 혹은 코딩테스트를 면접 전에 치르게 하더군요.\n\n제가 1년 전, 학생 때 구직을 했을 때에는 이런 기업들이 거의 없었는데 말이죠. (스타트업 위주, 이미 그때도 대기업은 코딩테스트가 빡시기로 유명했죠..)\n\n뭔가 좋은 변화 인 것 같습니다. 코딩으로 나를 좀더 보여줄수 있는 계기라고 생각이 들었 던 것 같네요 :)\n\n사전 과제를 제시한 기업들도 있었고, 코딩테스트를 먼저 본 기업도 있었습니다.\n\n사전 과제의 경우 대부분 미니 프로젝트 형식으로 주어졌으며, typescript 와 redux / mobx 같은 전역 상태 관리 툴을 사용하여 미니 프로젝트를 완성시키는 과제였습니다.\n\n코딩 테스트의 경우, 요즘 온라인 코딩 테스트가 발달 되어 있어서 링크를 보내주고 3~4시간 정도 걸리는 코딩 테스트를 먼저 치루게 하더군요.\n\n저는 코딩테스트를 직장에서 했습니다.. 크크\n짜릿한 경험 이었고, 코딩테스트 치루면서 재밌었던 기억이 있네요.\n뭔가 다시 기초에 대해 공부한다는 느낌도 많이 들었고, 재밌는 수학 문제를 푸는 기분 이었습니다. \n\n> 사전과제와 코딩테스트를 하면서 저의 실력에 대해 많이 돌아본것 같습니다. 좀더 나은 방법론이 무엇일까? 혹은 어떻게 하면 이 문제를 좀더 효율적으로 풀수 있을까? 라는 질문을 저에게 던지면서, 한단계 성장할 수 있었던 기회였습니다.\n\n자, 이제! 코테 혹은 사전과제를 통과했습니다.\n고대하던 면접의 시간이 다가오면서 면접을 준비 하게 되었습니다..\n\n제가 가장 유용하게 본 프런트엔드 면접 기술 질문 모음이 있는데, 소개하고자 합니다.\n\nhttps://github.com/yangshun/front-end-interview-handbook\n\nhttps://github.com/JaeYeopHan/Interview_Question_for_Beginner\n\n\n이 두 레포지토리 인데요, 정말 이 레포지토리에 적힌 질문들이 많이 나왔습니다!\n\n> 면접을 준비하면서 이론에 대해서 많이 공부하게 된거 같아요. 확실히 좋은 개발자는 실무와 동시에 이론 지식이 많이 있어야 하는 것 같습니다. 이론이 받쳐진 개발자는 좀더 깊이있고, 최적화된 코드를 만들수 있는것 같아요.\n\n제가 이번 이론 공부를 하면서 제일 큰 수확은 Event Loop에 대해서 많이 알게 되었다는 것인데요. \n\n항상 Event Loop라는 것을 알고는 있었지만, 명확하게 알지는 못했는데, 이번 기회로 개념이 확립 된 것 같아서 기분이 좋습니다.\n\n말이 나온김에, Event Loop에 대한 궁금증을 많이 풀어준 유튜브영상을 소개 드리려고 합니다.\n\nhttps://www.youtube.com/watch?v=8aGhZQkoFbQ\n\n한글 자막도 있으니, 이벤트 루프에 대해서 공부해보고 싶으신 분들은 정말 한번 꼭 보시길 추천드립니다. 좋은 영상입니다.\n\n자 이제, 공부를 했으니 면접을 보러 가야겠죠?\n\n저의 경우는 3전 2패 1승 입니다.\n\n뭔가 나름대로 준비도 많이 해갔고, 같은 지식으로 같은 포지션의 직군의 면접을 보았는데, 왜 어떤곳은 떨어지고 어떤곳은 합격 한 것일까요?\n\n제 결론은 이렇습니다.\n\n> 회사의 특성에 따라, 혹은 회사가 처한 상황에 따라 뽑으려고 하는 개발자들이 다릅니다. 따라서 같은 레벨의 개발자라도 면접을 보면서 느끼는 성향이나 지원자의 개발 철학에 따라서 면접은 당락이 좌우된다고 봅니다.\n\n따라서, 떨어지더라도 최선을 다했으면 너무 자신을 탓하지 않아도 될거 같아요! 단지 그 회사와 나는 지금 맞지 않았던 것이라고 생각하는 편이 좀더 긍정적인 생각을 하게 되는 것 같습니다. 또한 그게 사실인것 같기도 하구요. :)\n\n4. 면접 그리고 컬쳐 면접\n\n대부분 1차면접은 실무면접으로 이루어지고, 그 다음 면접은 컬쳐면접으로 이루어 집니다.\n\n컬쳐면접은 지원하려는 회사가 갖고 있는 문화나 특성에 대해서 지원자와 fit를 맞추어 보는 시간이라고 할수 있습니다.\n\n따라서 컬쳐면접을 통해 회사는 지원자의 철학이나 성향을 파악 할 수 있고, 지원자는 회사의 문화나 일을 하는 방식 혹은 비젼에 대해서도 알아 볼 수 있는 중요한 시간입니다.\n\n저는 이직 사유가 개발 문화에 대한 아쉬움이었기 때문에, 개발 문화나 일을 하는 방식에 대해서 물어 보았던 것 같아요.\n\n> 컬쳐 면접에서는 되도록 솔직하게 말하는 것이 좋은 것 같습니다. 속이거나 억지로 맞춘어 그 회사에 실제로 들어갔을 때에는 정말 문화적인 fit가 맞지 않으면 힘들 수 있거든요. 면접관 분과 최대한 솔직하고 진솔한 이야기를 나누는 것이 좋은 컬쳐면접의 예라고 할 수 있을것 같습니다 :)\n\n5. 처우 협상\n\n사실 이 처우 협상 과정에서 조금 삐걱댄 적이 있었습니다.\n지금 회사에서의 이해관계 때문이었는데요.\n\n선배들은 \"최대한 마무리를 다 짓고, 회사에다 이직을 한다고 얘기를 할 때에는 최대한 나중에 해라. 너를 먼저 생각하고, 회사는 일단 제쳐두어라.\" 라는 얘기를 많이 해주었습니다.\n\n근데, 제가 처한 상황은 좀 달랐습니다. 2명이서 일하는 부서에서 1명이 나간다고 먼저 말을 했기 때문이지요.\n\n남은 1명인 저는, 회사에 먼저 말을 해주는 것이 회사에 좋지 않을까? 라는 생각이 들었고, 마무리를 제대로 짓지 않은 상황에서 회사와 이직 관련 이야기를 나누게 되었습니다.\n\n참 총체적 난국이 벌어졌습니다.\n회사는 저를 잡으려 했고, 저는 그 상황에서 갈피를 잠시 잡지 못했습니다. 여러가지 이유에 머리가 복잡 해 졌고, 살짝 위험한 상황까지 왔으나.. 개발자의 마인드로 어디부터 잘못 된 것인가? 무엇이 궁극적인 목적인가? 라는 질문들을 다시 던지며 마지막은 이해관계를 잘 정리했던것 같습니다 :)\n\n> 이미 이직하기로 마음먹었다면, 현 회사는 신경쓰지 마세요 :) 어차피 떠날 회사이고, 최대한 모든 결정을 마무리 지은 후에 말을 하는것이 좋다는 것을 뼈저리게 느꼈습니다.\n\n또한, 처우 협상에서 가장 중요한것은 처우 겠지요.\n처우란 결국 연봉을 말합니다.\n\n이 부분에서도 지인들에게도 많이 도움을 청하고, 저 혼자서도 고민을 많이 해보았는데 내린 결론은 다음과 같습니다.\n\n> 연봉을 너무 올려서 이직을 하게되면, 그만큼 퍼포먼스를 내지 않으면 옮긴 회사에서 연봉을 올리기 힘들다. 또한, 다음 직장으로 이직 하기에도 그 올린 연봉을 맞춰주는 회사는 많지 않다. 따라서 이직할때에 돈보다는 내가 진짜로 이직하려는 이유가 무엇인가? 를 먼저 생각해야 한다. \n\n저는 이러한 고민을 바탕으로 제가 진짜 이직 하려는 이유는,\n\n\"개발을 행복하게, 또한 재미있게 하기 위함\" 이구나 라는것을 뼈저리게 느꼈습니다.\n\n\"나는 개발을 하며 집중할때 행복을 느끼는 사람\" 이구나 라는 것을 느낀 뒤로, 돈에 대한 욕심은 많이 줄었던 것 같습니다.\n\n6. 마무리~\n\n지인분이 이런말을 했습니다.\n\n> 이직을 하려 할때 받는 스트레스는, 이혼을 하려 할때 받는 스트레스와 그 스트레스의 크기가 비슷하다.\n\n정말 맞는 말입니다. \n현재 다니고 있는 회사도 내가 다니고 싶기에 들어왔고, 그 현 직장을 떠난 다는 것은 무엇인가를 포기하고 다른 하나를 쟁취하기 위함이죠.\n\n그러기에, 정들었던 첫 회사를 떠나는 것이 쉽지만은 않았던 것 같습니다.\n\n허나, 내가 궁극적으로 바라는 것이 무엇인가? 나는 무엇을 위해 이직을 하려 하는가? 를 잘 생각해보고, 그것이 불순한 마음이 아니라면 충분히 도전해볼만 하다고 생각합니다 :)\n\n모든 이직러분들에게 건승을 기원하며, 이 글을 마칩니다!\n\n읽어주셔서 감사합니다 🤘🏻\n\n\n\n","thumbnail":"Velog.png","excerpt":"나의 이직기","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2020-02-18T13:57:13.996Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"나는 중니어 개발자다. 따라서 고찰해보았다.":{"id":154,"title":"3 > but 4 <","content":"\nvelog.io 에 올린 원 글을 복사 해서 만들었습니다.\n아래는 그 글의 내용입니다.\n\n안녕하세요, 정말 오랜만에 벨로그에 글을 남깁니다.\n\n# 목차\n\n1. What is `3 > but 4 <` ?\n2. 고찰\n\t1. 과거\n\t2. 현재\n\t3. 미래\n3. 글을 마치며\n\n# 들어가면서\n왜 벨로그에 불현듯 글을 쓰게 되었는가에 대해서 먼저 정리를 하고 가는게 맞을 것 같습니다. 최근에 유발 하라리 작가님의 인류 3부작 중 **호모데우스**라는 책을 읽게 되었습니다. 또한 유발 하라리 작가님에 대한 관심이 생겨서 **21세기를 위한 21가지 제언**이라는 책도 보고 있는 중 입니다.\n\n저는 원래 책을 읽지 않는 사람 중의 한 명이었다고 할 수 있습니다.\n어렸을 때 부터 이성보다는 육감과 감각에 의존하여 살아 왔고 또한 직감이 주는 영감과 직감만이 할 수 있는 매력들에 조금 더 가치를 두고 살아 왔습니다.\n\n그러다보니 책보다는 영상을, 이론보다는 실무를, 고찰보다는 미래를 위한 행동을 먼저 하며 살아 왔습니다.\n\n그러다 보니 책을 싫어하진 않았지만, 뭔가 손에 잡히지 않았고 제 인생에 있어 책이 많은 부분을 차지 하지 않았습니다.\n\n하지만 최근의 저에게는 혼자만의 시간을 가질 여유 및 또한 그러고 싶은 욕구가 많이 들었습니다. 뭔가 제가 무엇을 진실로 원하는지, 앞으로 내 인생을 어떻게 살아가야 정말 잘 살았다고 할 수 있을지 등등과 같은 생각들을 많이 하게 되었어요.\n\n이때까지는 외부적인 요인을 충족시키며 만족감을 느끼며 살아왔다면, 최근에는 내부적인 요인에 눈을 돌리게 되었달까요.\n\n그렇게 된 이유는 여러가지가 있을 것 같아요. 매우 복합적인 이유인 것 같습니다. 단순히 하나만의 트리거 포인트로 시작된 동기라기 보다는 원래부터 저 자신에게 항상 꼬리표처럼 달려왔던 질문들이 이제야 눈에 보이기 시작했다는 표현이 가장 맞는 표현인 것 같습니다.\n\n# 1. What is `3 > but 4 <`?\n\n위에서 들어가기 전에 말했던 이야기들에서 이어져서 글을 작성해 보겠습니다.\n> 3 > but 4 <\n\n위에 대한 의미는 제가 개발자로써 또한 사회인으로써 커리어를 쌓아온 연차 수 입니다. 3년보다는 크고 4년보다는 작죠.\n\n애매한 시기라고 생각합니다. 여러 고민들이 들기 시작하고, 어떻게 보면 하나의 성장통을 겪는 시기라고 생각합니다.\n\n1, 2년차에 경험을 쌓기 바빴고, 그 경험을 바탕으로 이제 어느정도 경력직이 되어가는 과정에 있다고 생각합니다. 어떻게 보면 신입 때 정신없이 앞만 보고 달리느라 챙기지 못했던 자신에게 물음표로 남았던 것 들을 돌아 볼 수 있는 여유를 가질 수 있는 시기라고도 생각합니다.\n\n그러다보니 1, 2년차에 물음표로 남아있던 것에 대해서 최근에 많이 고찰을 했던 것 같습니다. 그 고찰이 어느정도 완료가 되었는지는 모르겠지만, 그래도 하나의 짤막한 글을 쓸 만큼의 완료는 된 것 같아서 이 글을 쓰게 되었습니다.\n\n다시 유발 하라리 작가님의 호모데우스로 돌아와서 이야기를 진행 해 보겠습니다. 그 책을 보면서 가장 기억에 남는 부분과 이때까지 제가 물음표를 달고 지냈던 질문들과 교집합을 이루었던 부분은 다음과 같습니다.\n\n* 의식 vs 지성: 어떤것에 더 가치를 두어야 하는가?\n* 공유하는 문화: 맹목적으로 공유하는 문화의 룰에 따라야 하는가?\n* 스토리 텔링: 전할 이야기가 없는 것 들은 큰 힘을 갖지 못한다.\n\n## 의식과 지성\n가장 단순한 예를 들면 **사람 vs 사람과 비슷한 지능을 가진 로봇**이라고 할 수 있을 것 같습니다.\n저는 최근 개발자의 연봉이 오르면서 이런 고민을 많이 했습니다.\n> 결과적으로 연봉이 올라서 좋긴 하지만, 이게 과연 어떤 결과를 가져다 줄까?\n맹목적으로 회사의 발전을 위해서 받은 만큼 열심히 일하는 것이 과연 옳은 것 인가? 너무 회사의 발전과 기술의 발전에 무게를 둔 채, 사람 (인적자원)의 무게는 잃어가는 것이 아닐까?\n\n저는 사람만이 할 수 있는 혁신이 존재 한다고 생각합니다.\n물론 그 혁신이 이루어지려면 기술력이 밑받침 되어야 하는 건 사실이겠지만요.\n하지만 그 기술이 사람을 먹어치우게 될 정도라면 그것은 고민을 해보아야 하는 것 같습니다.\n\n비슷한 예시로 이런 것이 있을 것 같습니다.\n\n> 문제점: 고객이 엘리베이터가 너무 느린 것 같다고 합니다.\n해결책 1: 엘리베이터 속도를 어떻게 하면 더 빠르게 할지 고민해보자\n해결책 2: 느린 것 같다고 하니, 그냥 느린 것 같이 느껴지지 않게 옆에 거울을 달자. 그럼 거울을 보면서 시간이 갈 것이고, 느린 것 같은 감각은 거울을 보면서 느끼지 못할 것 아닌가.\n\n1번은 오직 기술력만 활용한 해결책 입니다. 만약 머신러닝된 로봇이라면 해결책 1을 택할 가능성이 높다고 생각합니다. 하지만 의식이 더 강한 사람이라면 해결책 2도 충분히 택할 수 있죠.\n\n_엘리베이터 속도는 이미 빠른데, 더 빠르게만 하다가 부작용이 나는 것은 아닐까? 좀더 사람다운 방법으로 해결을 하는 것이 좋지 않을까?_\n라는 생각이 제가 추구하는 방법론인 것 같습니다.\n\n## 공유하는 문화 그리고 스토리텔링\n사실 제가 벨로그에 글을 쓰는 것도 공유하는 문화의 일부에 참여하는 것이고, 사람들이 SNS에 게시물을 올리는 것도, 음악인이 앨범을 만들어 시장에 내놓는 것도 모두 공유하는 문화라고 생각합니다.\n\n저는 공유하는 문화에 있어서 가장 중요한 점은 **스토리 텔링**이라고 생각합니다.\n\n제가 정말 좋아하고 많은 영감을 받은 음악가 중의 한 명인 밴드 멜빈스(Melvins)의 멤버인 버즈 오스본(Buzz Osbourne)은 한 인터뷰 영상에서 이런 말을 했습니다.\n\n[버즈 오스본 인터뷰 영상](https://youtu.be/eAHZU0WU-Bk?t=388)\n\n\n> 음악은 예술이다. 예술은 커뮤니케이션(소통)이다.\n아무도 당신의 예술을 이해하지 못 한다면, 당신은 아무것도 소통할 것이 없는 것이다.\n나에게 그런건 큰 의미가 없다. (하하하)\n...\n나는 나를 움직이게 할 만한 음악이 필요하다.\n나를 음악을 하게 만들 무언가 말이다.\n그게 내가 원하는 것이다.\n\n저는 이것이 의미하는 바가 많다고 생각합니다.\n결국 사람과 동물을 나누는 가장 큰 요소는 바로 스토리텔링 이라고 생각합니다.\n스토리텔링은 과거와 현재 그리고 미래가 존재합니다.\n동물들은 오직 현재만을 사는 반면, 사람은 과거와 현재 그리고 미래를 살아갑니다.\n\n또한 스토리텔링의 힘은 엄청나다는 것을 최근들어 많이 느꼈습니다.\n하나의 스토리텔링이 잘 이루어 지려면 나름의 논리와 사람이 이해할 만한 수많은 작은 생각의 톱니바퀴들이 잘 조화를 이루어야 한다고 생각합니다.\n결국 많은 고찰과 노력 그리고 시간이 필요하다는 것이라고 생각합니다.\n\n저는 최근에 이러한 고민들\n* 의식적인 삶\n* 이야기를 만들어 나가는 삶\n\n에 대해서 많이 생각을 하고 저에 대해서 돌아 보았던 것 같습니다.\n\n또한 고찰을 해야만 하는 시기가 저에게 왔다고 생각합니다.\n앞으로 더 나은 미래를 위해서 말이지요.\n\n# 2. 고찰\n이제 제가 위에서 소개한 저만의 고찰을 과거 / 현재 / 미래에 기반하여 글을 써내려 가 보겠습니다.\n\n## 2-1. 과거\n\n제가 처음 시작할 때에 오랜만에 벨로그에 글을 올렸다고 했는데요, 저는 벨로그 뿐만 아니라 제 생각을 공개적으로 써내려 간 일이 최근 1년 정도는 많지 않았습니다. 저는 공유 할 만한 생각이 들거나 아이디어가 생기면 공유하거나 실행 하는 성격인데 말이지요.\n그만큼 저는 할 말이 없었던 것 아닐까 싶습니다.\n이야기를 할 거리가 생길만한 삶을 최근 1년동안은 살지 않은 것 같습니다.\n\n좋게 말하면 생각을 할만한 여유를 갖기 위한 갭이어라고 생각을 합니다.\n혹은 좀더 성장 하기 위해 경험을 하는 여정이었다고 생각합니다.\n\n나쁘게 말한다면, 내부적인 요인보다는 외부적인 자극에 좀더 무게를 두고 살았다고 생각합니다.\n\n결국 자신을 돌아보지 않는 삶은 한계가 있는 것 같습니다.\n제가 가진 과거의 문제점은 다음과 같습니다.\n\n1. 개발자로 성장은 하고 싶었으나, 어떤 개발자로 성장하고 싶은지에 대한 목적이 없었다.\n2. 좋아하는 혹은 동경하는 개발자분들 처럼 되고 싶었으나, 내게 맞는 궁극적인 골(Goal)을 생각해 본 적이 없다.\n3. 너무 직관적으로만 코딩을 했다. 결과적으로 내가 쓴 코드를 다시 보면 무슨 말을 하려고 하는지 잘 모르겠다.\n4. 개발자로써 추구하는 가치들에 대한 우선순위 설립이 미흡했다.\n5. 결론: 나의 정체성이 부족했다.\n\n1-4 번은 결국 5번으로 집약됩니다.\n맞습니다, 저는 저에대한 정체성이 부족했습니다. 내가 누군지 무엇을 하고 싶은지 잘 몰랐습니다.\n\n그래서 저는 **ColdSurf**라는 제 3의 자아를 만들었습니다.\n어렸을때 저는 메이플스토리라는 게임을 좋아했어요. 초기에는 탑 랭커들이 누가 있는지 많이 보곤 했습니다. 탑 랭커들을 많이 보다보니, 그들의 닉네임을 기억하게 되었습니다. 쭉 생각해보니 뭔가 다들 유명하고 그들의 커리어에서 정점을 찍은 사람들에게는 좋은 이름들이 있었습니다.\n\n저와 비슷한 생각을 한 관련 유튜브 영상을 공유합니다\n[이름에 새겨진 의미 영상](https://youtu.be/MNyYSZzEovg)\n\n무튼, 저는 어렸을때는 게임에서 뭔가 나만의 멋진 닉네임을 가지고 싶어했습니다. 개발을 하다보니 멋진 개발명 (Ex. 민준님의 velopert, 수열님의 devxoul)을 가지고 싶어했습니다. 결과적으로 대학생때 만들어낸 이름이 **killi8n**입니다.\n그 당시 저는 뭔가 유니크하고 잘 쓰지 않는 사람이 쓰는 영어 이름과 뭔가 개발자스러운 단어를 조합하고 싶어했던것 같아요.\n그래서 유럽의 중세 소설에서 나올 것 같은 이름인 Killian을 떠올렸고 결과적으로 killi8n이 만들어졌습니다.\n\n근데 이 이름을 몇년간 써보니 너무 개발에만 치중된 이름인 것 같았어요.\n그래서 조금 더 범용적인 이름을 찾은 끝에 **ColdSurf**라는 이름을 갖게 되었습니다.\n\n무튼 ColdSurf라는 이름이 갖는 의미는 저에게 다음과 같습니다.\n\n1. 내가 되고 싶은\n2. 내가 하고 싶은\n3. 내가 남들에게 보여지고 싶은\n4. 내가 나에게 해주고 싶은\n\n등의 의미를 새겨넣었습니다.\nColdsurf라는 이름으로 저는 영감을 받길 원했습니다.\n항상 저에게 나다운게 무엇인지 상기시켜줄 그런 이름말이죠.\n저에게는 부모님이 지어준 혹은 남들이 지어준 이름이 아닌 **나 다운 것**을 강조해 줄 만한 내가 나를 위해 지은 이름이 필요했습니다.\n\n그래서 ColdSurf라는 닉네임을 최종적으로 선택했습니다.\n과거에만 머물러 있지 않기 위한, 또한 저를 위한 새로운 도약을 위해서 저에게 저만의 새로운 이름을 지어 준 것입니다.\n\n결과적으로 지금 돌아 볼 때에 많은 영감과 실행력을 가져다 준 것 같습니다.\n과거를 바탕으로 더 나은 미래를 생각하고 행동하게 했으니까요.\n\n## 2-2. 현재\n\n그 Coldsurf라는 이름을 가지니, 뭔가 예전부터 제가 하고 싶었던 일들이 머리에서 구상되기 시작했습니다.\n\n저는 다음과 같은 일들을 하고 싶었습니다.\n\n1. 나만의 플랫폼 만들기 (ongoing)\n2. 나만의 1인 창작 단체 만들기 (ongoing)\n3. 내가 좋아하는 것인 예술 분야와 내가 잘하는 것인 개발을 접목하기 (ongoing)\n4. 이때까지 미뤄왔던 사이드프로젝트 아이디어 실행하기 (Metronome 앱, Running 앱, web audio sound를 활용하여 기타 이펙터 만들기 등)\n5. 알고리즘의 고수가 되기\n6. 음악 작업 (ongoing)\n7. 내가 가야만 하는 회사가 아닌 내가 가고 싶은 회사를 가기 (ongoing)\n\n위의 몇가지는 아예 새로 해야하는 것과 기존에 쭉 해왔던 것들에서 좀 흐지부지 된 것들을 다시 불씨를 지펴야 하는 일들로 섞여있습니다.\n\n_**현재**_ 파트에서는 위 목록들 중 제가 지금 현재에 하고 있는 것들을 써보도록 하겠습니다.\n\n### 1. 나만의 플랫폼 만들기\n저는 예전부터 블로그도 한번 띄워서 글을 올려보고, 기타를 치기 때문에 유튜브에 기타 커버 영상도 올려보곤 했는데요.\n이러한 **플랫폼**에 대한 창작 욕구가 생겼습니다.\n아무래도 처음 시작은 멋지진 않겠지만, 한번 저만의 이야기를 써내려 갈 수 있는 플랫폼을 만들어 보려 합니다.\n\n간단한 블로그로 시작해보려 해서 레포를 만들고 틀을 짜고 있습니다.\nhttps://github.com/coldsurfers/surf-log\n위 레포입니다.\nnextjs 기반이며, `gray-matter`를 사용하여 markdown 파일의 메타태그를 읽어서 `marked`를 사용하여 markdown을 보여주는 형태를 작업하고 있습니다.\n\n아무래도 당분간은 벨로그에 글을 작성하며 Preview를 함께 보며 작성된 파일을 블로그 markdown 파일에도 복붙하여 사용하여야 하지 않나 싶습니다.\n\nmarkdown 파일들을 메타형태로 만들어 하나의 json파일로 만들어서 nextjs의 서버사이드 API를 사용하여 긁어와 보여주는 형태를 작업하고 있습니다.\n\n또한 기획에 참고할 만한 좋은 다른 플랫폼들을 몇가지 공유해 보겠습니다.\n\n1. [Surfit](https://www.surfit.io)\n2. [Fandom](https://www.fandom.com/)\n\n\n### 2. 나만의 1인 창작 단체 만들기\n저만의 1인 창작 단체를 만들고 싶었어요.\n이때까지 조금 더 소비적인 삶을 살았다면, 제가 가지고있는 재능들을 활용해 조금 더 생산적인 삶을 살고 싶었습니다.\n\n최근에 도파민 디톡스라는 영상을 보게 되었는데요, 함께 공유하면 좋을 것 같아서 공유해 보겠습니다.\n제가 좋아하는 Niklas Christl이라는 독일 유튜버의 영상을 공유해 볼게요.\n이 유튜버 분의 채널에는 자기개발에 도움이 되는 많은 영감들을 가진 컨텐츠들이 많답니다.\n\n[도파민 디톡스 영상](https://youtu.be/bV_NdUZEmnE)\n\n이 영상을 보면서 한번 저도 **조금 더 생산적인 삶**을 살아야 하지 않나라는 생각을 했습니다.\n\n단순히 영감을 받고 끝내는 것이 아닌, 영감을 받은 것을 기반으로 무언가 창작하는 즐거움을 조금 더 끌어내 보려고 합니다.\n\n그래서 일단 개발적으로 창작을 해보고자 ColdSurfers라는 github orgnization을 만들었습니다.\n\n[ColdSurfers](https://github.com/coldsurfers)\n\n개발과 여러 분야를 엮어 서비스 플랫폼을 만드는데에 관심이 있는 분들에게는 모두 열려있답니다.\n\n### 3. 내가 좋아하는 것인 예술 분야와 내가 잘하는 것인 개발을 접목하기\n\n최근에 가장 염두를 두고 있던 것인데요, 뭔가 제가 좋아하는 것과 제가 잘하는 것을 결합해 보면 재밌는 것을 할 수 있겠다 싶었어요.\n\n저는 어렸을때부터 음악과 영화를 좋아했습니다.\n넷플릭스와 같은 스트리밍 플랫폼이 없을 당시, 토렌트로 불법 다운로드를 받아서 영화를 보곤 했습니다. 특히나 해외 영화에 관심이 많았는데, 자막이 없는 것들도 많았어요. 그냥 에라이 모르겠다 자막 없이도 보자 할 정도로 해외영화를 좋아했습니다.\n\n또한 어렸을 적 어머님의 소개로 영국 형(?)을 만나게 되었는데, 그 분께 기타를 배웠습니다. 뭔가 한국 가요 기타를 노래로 배우는 것이 아닌, 외국의 밴드 음악으로 기타를 배워서 좀 더 proper한 음악을 많이 접하게 되었어요.\n또한 음악 전공자라서 그런지 좀 더 실용적인 기술들을 많이 배우게 되다보니 자연스레 기타는 제 인생에 있어서 가장 오래 함께 한 취미가 되었습니다.\n\n이렇게 예술문화에 관심이 많았기 때문에, 그런 쪽과 개발을 결합하여 하나의 앱이나 웹 플랫폼을 만들 수 있겠다 싶었어요.\n\n최근 공연 문화 인플루언싱을 하시는 분과 연락이 닿아서, 1주일 뒤 처음 만나기로 하였는데요. 관련해서 진척이 있다면 다시 또 글을 써보도록 하겠습니다.\n\n\n### 6. 음악 작업\n\n로직 프로라는 애플에서 만든 프로듀싱 프로그램을 통해서 음악 작업을 하곤 했는데요, 조금 더 이쪽에 집중해야 하는데 아직 완성하지 못한 곡들이 꽤 많아서 아쉽습니다. 조금 더 시간을 투자해야 할 듯 합니다.\n\n\n### 7. 내가 가야만 하는 회사가 아닌 내가 가고 싶은 회사를 가기\n\n이직을 준비하고 있습니다.\n제가 과거에는 **가야 만 하는 회사**를 갔던 것 같아요.\n\n경력을 쌓기 위해, 조금 더 대규모를 경험해 보기 위해, 다문화적인 개발문화는 어떨까 경험해 보기 위해 갔던 회사들입니다.\n이제는 조금 경험도 쌓였고 개발적인 능력치도 쌓였다고 생각하기에 조금 더 저와 뜻을 같이 할 수 있는 좋은 환경의 제가 가고 싶은 회사를 가야 겠다는 생각이 들었어요.\n\n최근 개발자들 연봉이 오르면서 이직 문턱이 조금 더 높아진 것 같아요.\n특히나 제가 좋다고 생각하는 회사는 다른 사람들에게도 좋게 느껴지기 마련이기에 조금 더 문턱이 높은 것도 사실인 것 같습니다.\n\n이 부분은 너무 급하게 생각하려 하진 않습니다. 결국 회사라는 것도 인연이기에 인연이라면 함께 할 수 있다고 생각합니다.\n\n## 2-2. 미래\n\n결국 남은 것들은 4번과 5번이 되겠네요 !\n\n\n4. 이때까지 미뤄왔던 사이드프로젝트 아이디어 실행하기 (Metronome 앱, Running 앱, web audio sound를 활용하여 기타 이펙터 만들기 등)\n5. 알고리즘의 고수가 되기\n\n### 4. 미뤄왔던 사이드프로젝트 아이디어를 실행에 옮기기\n\n제가 기타를 치면서 항상 하는 일이 있는데요, 마지막에 metronome을 틀어놓고 스케일을 연습합니다.\n제가 쓰는 플랫폼은 metronome online이라는 플랫폼이에요.\n\n[Metronome Online](https://metronomeonline.com/)\n\n이와 비슷한 앱이나 웹 플랫폼을 한번 만들어 볼까 합니다.\n\n또한 지금은 많이 풀렸지만 최근까지는 날씨가 추워서 러닝머신을 많이 했는데요. 그 때 나이키 러닝 앱이 많이 도움이 되었어요.\n뭔가 비슷하게 나만의 러닝 코스를 만들거나 나만의 러닝 강도를 만들어서 러닝을 하는데 도움이 되는 앱을 만들 수 있을 것 같았어요.\n이 부분도 한번 꼭 해보고 싶은 사이드 프로젝트입니다.\n\n예전에 비탈리 보브로브 라는 외국 개발자분의 기타와 웹 오디오를 결합해서 이펙터를 만드는 영상을 본 적 있는데요.\n이 분에게 영향을 받아서 한번 저도 비슷한 것을 만들어 보려합니다.\n예전부터 궁금했던 web audio의 세계에도 한번 발을 들여 보고 싶기도 했습니다.\n\n이분의 깃헙을 공유합니다.\n[비탈리 보브로브 님의 깃헙](https://github.com/vitaliy-bobrov)\n\n### 5. 알고리즘의 고수가 되기\n결국 개발의 끝은 알고리즘이 아닐까 싶습니다....\n최근 programmers 사이트에서 맛보기 알고리즘을 몇가지 풀어보았는데요.\n재밌어서 중간 중간 시간이 날 때 마다 한번 도전해 보려합니다.\n\n\n# 3. 글을 마치며\n\n저와 비슷한 고민을 하고 있는 모든 분들에게 화이팅이라는 말을 하고 싶습니다.\n또한 비슷한 고민들 털어놓는 그런 자리도 한번 마련해 보고 싶습니다.\n혼자보다 함께할 때 더 의미있는 일들을 할 수 있다고 생각합니다.\n\n한번 네트워킹에도 도전해 보아야겠네요 !\n그럼 이만 글을 마치도록 하겠습니다.\n\n감사합니다.","thumbnail":"ocean.png","excerpt":"나는 중니어 개발자다. 따라서 고찰해보았다.","blogArticleCategoryId":5,"isPublic":true,"createdAt":"2022-03-15T05:20:00.000Z","deletedAt":null,"blogArticleCategory":{"name":"life"},"blogArticleTags":[]},"react + pwa + webpack 투두 리스트 만들기":{"id":155,"title":"react + pwa + webpack 투두 리스트 만들기","content":"# 투두 리스트 만들기\n\n## 1. src/components/Root.js 생성\n\n`src/components/Root.js`\n\n```jsx\nimport React from 'react'\n\nconst Root = () => {\n    return <div>Hello world!</div>\n}\n\nexport default Root\n```\n\n`src/index.js`\n\n```jsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport Root from './components/Root'\n\nReactDOM.render(<Root />, document.getElementById('root'))\n```\n\n## 2. 스타일 관련 폴더 생성 및 sass-loader 추가\n\n```bash\nyarn add -D node-sass sass-loader\n```\n\n`webpack.config.js`\n원래 스타이 설정 부분(test: css)로 되었던 부분을\n아래와 같이 변경.\n\n```js\n{\n    test: /\\.(css|scss)$/,\n    use: [\n        {\n            loader: MiniCssExtractPlugin.loader,\n        },\n        {\n            loader: 'css-loader',\n            options: {\n                modules: {\n                    localIdentName: isDevelopMode\n                        ? '[path][name]__[local]--[hash:base64:5]'\n                        : '[name]__[local]--[hash:base64:5]',\n                },\n                importLoaders: 1,\n                sourceMap: true,\n            },\n        },\n        {\n            loader: 'sass-loader',\n            options: {\n                sourceMap: true,\n            },\n        },\n    ],\n},\n```\n\n`src/styles/index.scss`\n\n```scss\nbody {\n    color: blue;\n}\n```\n\n`src/index.js`\n\n```jsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport Root from './components/Root'\nimport './styles/index.scss'\n\nReactDOM.render(<Root />, document.getElementById('root'))\n```\n\n이제 다시 개발서버를 키면, 글자 색상이 blue로 바뀐것을 볼수있다.\n\n`index.scss`\n\n```scss\nbody {\n    margin: 0;\n\n    height: calc(100vh);\n\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\n## 3. TodoWrapper 생성\n\n`src/components/TodoWrapper/index.js`\n\n```jsx\nimport React from 'react'\nimport s from './style.scss'\n\nconst TodoWrapper = () => {\n    return <div className={s.wrapper}>TodoWrapper</div>\n}\n\nexport default TodoWrapper\n```\n\n`src/components/TodoWrapper/style.scss`\n\n```scss\n.wrapper {\n    border: 3px solid #ababab;\n\n    padding: 30px;\n    width: 500px;\n    height: auto;\n}\n```\n\n`src/components/Root.js`\n\n```jsx\nimport React from 'react'\nimport TodoWrapper from './TodoWrapper'\n\nconst Root = () => {\n    return <TodoWrapper />\n}\n\nexport default Root\n```\n\n## 4. TodoTitle & TodoList 컴포넌트 생성\n\n`src/components/TodoTitle/index.js`\n\n```jsx\nimport React from 'react'\nimport s from './style.scss'\n\nconst TodoTitle = () => {\n    return <div className={s.wrapper}>React Todo List</div>\n}\n\nexport default TodoTitle\n```\n\n`src/components/TodoTitle/style.scss`\n\n```scss\n.wrapper {\n    font-size: 25px;\n    padding-bottom: 10px;\n    border-bottom: 2px solid #eeeeee;\n}\n```\n\n`src/components/TodoList/index.js`\n\n```jsx\nimport React from 'react'\nimport s from './style.scss'\n\nconst TodoList = ({ todoList }) => {\n    const todoItem = todoList.map(({ id, todo }) => {\n        return (\n            <div key={id} className={s.todoItem}>\n                {todo}\n            </div>\n        )\n    })\n    return <div className={s.wrapper}>{todoItem}</div>\n}\n\nexport default TodoList\n```\n\n`src/components/TodoList/style.scss`\n\n```scss\n.wrapper {\n    color: blue;\n}\n```\n\napi 를 가져오기 위한 axios 모듈 설치\n\n```bash\nyarn add axios\n```\n\n`src/components/TodoWrapper/index.js`\n\n```jsx\nimport React, { useState, useEffect } from 'react'\nimport axios from 'axios'\nimport s from './style.scss'\nimport TodoTitle from '../TodoTitle'\nimport TodoList from '../TodoList'\n\nconst TodoWrapper = () => {\n    const [todoList, setTodoList] = useState([])\n\n    const getTodoList = async () => {\n        try {\n            const { data: todoList } = await axios.get(\n                'https://jsonplaceholder.typicode.com/todos'\n            )\n            setTodoList(todoList.splice(0, 10))\n        } catch (e) {\n            console.log(e)\n        }\n    }\n\n    useEffect(() => {\n        getTodoList()\n    }, [])\n\n    return (\n        <div className={s.wrapper}>\n            <TodoTitle />\n            <TodoList todoList={todoList} />\n        </div>\n    )\n}\n\nexport default TodoWrapper\n```\n\n","thumbnail":"Velog.png","excerpt":"react + pwa + webpack 투두 리스트 만들기","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2019-12-22T15:25:32.538Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"react + pwa + webpack 리액트 프로젝트를 웹팩으로 설정하기.":{"id":156,"title":"react + pwa + webpack 리액트 프로젝트를 웹팩으로 설정하기.","content":"# 리액트 프로젝트를 웹팩으로 설정하기.\n\n## 1. 프로젝트 생성 및 깃 저장소 master 푸시.\n\n```bash\nmkdir react-webpack\nyarn init -y\ngit init\n```\n\n`.gitignore`\n\n```\nbuild/\nnode_modules/\n.DS_Store\nyarn.lock\n```\n\n```bash\ngit remote add origin https://github.com/yungblud/react-webpack\ngit add .\ngit commit -m \"init\"\ngit push origin master\n```\n\n## 2. 프로젝트 구조 설정 및 기초가 되는 node module 인스톨\n\n1. src 폴더 생성.\n2. public 폴더 생성.\n3. es6 문법을 사용하기 위한 노드 모듈 설치.\n\n```bash\nyarn add -D @babel/core @babel/preset-env @babel/preset-react\n```\n\n## 3. 웹팩 관련 모듈 설치\n\n```bash\nyarn add -D webpack webpack-cli webpack-dev-server babel-loader css-loader style-loader html-webpack-plugin\n```\n\n## 4. webpack.config.js 설정\n\nwebpack.config.js 파일 생성\n\n`webpack.config.js`\n\n```js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nconst htmlPlugin = new HtmlWebpackPlugin({\n    template: './public/index.html',\n    filename: './index.html',\n})\n\nconst config = mode => {\n    const isDevelopMode = mode === 'development'\n    return {\n        entry: './src/index.js',\n        output: {\n            path: path.join(__dirname, '/build'),\n            filename: 'index.bundle.js',\n        },\n        module: {\n            rules: [\n                {\n                    test: /\\.(js|jsx)$/,\n                    exclude: /node_modules/,\n                    use: {\n                        loader: 'babel-loader',\n                    },\n                },\n                {\n                    test: /\\.(css)$/,\n                    use: [\n                        {\n                            loader: 'style-loader',\n                        },\n                        {\n                            loader: 'css-loader',\n                            options: {\n                                modules: {\n                                    localIdentName: isDevelopMode\n                                        ? '[path][name]__[local]--[hash:base64:5]'\n                                        : '[name]__[local]--[hash:base64:5]',\n                                },\n                                importLoaders: 1,\n                                sourceMap: true,\n                            },\n                        },\n                    ],\n                },\n            ],\n        },\n        plugins: [htmlPlugin],\n    }\n}\n\nmodule.exports = (env, argv) => {\n    const { mode } = argv\n    return config(mode)\n}\n```\n\n기본적인 리액트를 웹팩으로 띄울수 있는 설정만 하였다.\n\n## 5. public 폴더에 index.html 생성\n\n`index.html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n        <title>React PWA Webpack</title>\n    </head>\n    <body>\n        <div id=\"root\"></div>\n    </body>\n</html>\n```\n\nid 를 root로 하는 태그생성.\n\n## 6. .babelrc 파일 설정\n\n.babelrc 파일 생성\n\n`.babelrc`\n\n```json\n{\n    \"presets\": [\"@babel/env\", \"@babel/react\"]\n}\n```\n\n## 7. react 관련 모듈 인스톨\n\n```bash\nyarn add react react-dom\n```\n\n## 8. src/index.js 생성\n\n`src/index.js`\n\n```jsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nconst Root = () => <div>Hello World!</div>\n\nReactDOM.render(<Root />, document.getElementById('root'))\n```\n\n## 9. package.json scripts 명령어 추가.\n\n`package.json`\n\n```json\n\"scripts\": {\n    \"build:prod\": \"webpack --mode=production\",\n    \"build:dev\": \"webpack --mode=development\"\n},\n```\n\n이제 yarn build:prod 혹은 yarn build:dev 를 하면 build 폴더가 생성되면서, 번들링이 잘 된것을 볼수있다.\n\n## 10. hot reload 를 사용 할수 있는 개발용 서버 띄우기.\n\n`package.json`\n\n```json\n\"scripts\": {\n    \"start:dev\": \"webpack-dev-server --mode=development --open --hot\",\n    ...\n}\n```\n\nstart:dev 를 추가.\nyarn start:dev 를 해보면 개발용 서버가 8080포트에 띄워진다.\n\n","thumbnail":"Velog.png","excerpt":"react + pwa + webpack 리액트 프로젝트를 웹팩으로 설정하기.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2019-12-22T14:05:51.941Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Event Loop??? 그게 뭔데??":{"id":157,"title":"Event Loop??? 그게 뭔데??","content":"\n\n[![Video Label](http://img.youtube.com/vi/8aGhZQkoFbQ/0.jpg)](https://www.youtube.com/watch?v=8aGhZQkoFbQ&feature=emb_title)\n\n# EventLoop 를 알아보기 전에, JS 는 어떻게 이루어져 있는가?\n\n1. Call Stack: 프레임들의 스택.\n\n2. Task queue: 처리할 메시지의 대기열. (비동기로 호출되는 함수들(콜백 함수)이 이곳에 쌓인다.)\n\n3. Heap Memory: 구조화 되지 않은 메모리 공간.\n\n즉, 모든 콜 스택들이 빠지고 나서야, Task Queue 에 쌓여있던 것들이 이벤트 루프에 의해서 콜스택이 비어있기를 기다리다가 다시 콜스택으로 들어가서 실행.\n\n따라서 이벤트에 걸려있는 핸들러는 절대 먼저 실행 될 수 없다.\n\n# JS에서의 비동기 동작.\n\nJS: 싱글 쓰레드로 동작한다.\n\n그 말은 즉슨 한 함수가 끝나기 전까지 다른 함수가 진행중인 함수를 막을 수 없다는 것.\n\n\n그렇담, 비동기적으로 작동하는 것은 어떻게 구현할까?\n\njs는 이렇게 비동기를 구현한다.\n\n```js\nwhile(queue.waitForMessage()){\n  queue.processNextMessage();\n}\n```\n\nqueue에 메시지가 들어오기를 계속 기다린다.\n그리고, queue.waitForMessage() -> true가 되는 순간(queue에 메시지가 들어왔다 는 뜻.) 바로 들어온 메시지를 실행한다.\n하지만 싱글 쓰레드의 성질이 있는만큼, 기존 먼저 들어온 메시지가 있다면, 그 메시지가 끝나고 난 뒤 그 후에 들어온 메시지를 실행한다.\n\n다음과 같은 자바스크립트 코드가 있다고 가정하자.\n```js\nconsole.log('Hi!'); // 동기\n\nsetTimeout(() => {\n    console.log('Yay!');\n}, 4000); // 비동기\n\nconsole.log('Bye!'); // 동기\n\n```\n\nHi! 와 Bye!를 찍는 콘솔 로그 함수들은 모두 동기적으로 작동한다.\n\n따라서 코드가 위에서 아래로 실행될때에, `console.log('Hi!');`는 제일 먼저 콜 스택에 쌓인다.\n실행 되면 pop 되어 콜스택에서 사라진다.\n\n그리고 콘솔 창에 Hi! 를 찍게 된다.\n\n다음 코드인 setTimeout 함수가 콜스택으로 들어간다.\n`setTimout(cb, 4000);`\n콜스택에서 setTimeout 함수가 나온다.\n\n그렇지만 아무것도 동작 하지 않고 다음 코드인 Bye!를 찍는 콘솔로그 함수가 다시 콜스택에 들어간다.\nPop 된다. Bye!가 찍힌다.\n\n그리고 4초뒤에 Yay!가 찍힌다.\n\n왜그럴까?\n\n생각 같아서는 Hi! -> 4초간 기다림 -> Yay! -> Bye! 가 찍혀야 할 것 같은데 말이다.\n\n여기서 Event Loop 가 나온다.\n\n이벤트 루프의 역할은 콜스택을 주시 하는 것이다.\n\n즉, 이벤트 루프에 쌓인 이벤트들은 콜스택을 계속 모니터링하면서 눈치를 보다가,\n콜스택이 비었을시 이벤트 루프에 있는 이벤트들을 콜스택에 잽싸게 넣는다.\n\n그제서야 이벤트 루프에서 아무것도 안하고 빙빙 루핑하던 이벤트가 실행된다.\n\n위 코드로 다시 돌아가보면, 동기 함수인 콘솔로그들이 모두 콜스택에서 빠져나가고 나서야(모두 실행되고 나서야),\nsetTimeout의 콜백인 `console.log('Yay!');` 가 이벤트 루프에 담겨있다가, 4000ms 의 대기시간을 가진 뒤 실행 되는 것이다.\n\n\n그렇다면, setTimeout 의 딜레이 시간을 0으로 두면 어떨까?\n\n```js\nconsole.log('Hi!'); // 동기\n\nsetTimeout(() => {\n    console.log('Yay!');\n}, 0); // 비동기\n\nconsole.log('Bye!'); // 동기\n\n```\n\n마찬기지다. 결과는 똑같다. Hi! -> Bye! -> Yay!가 된다.\n\n이유는 위에서 설명한 것과 같다.\n\n0초를 딜레이 한다는것이 동기적으로 작동하게 만든다는 의미는 절대 아닌것이다.\n\n# web API\n\n단순 자바스크립트 함수가 아닌 web API를 타는 함수들은 비동기라고 볼수있다.\n위의 setTimeout 함수도 webAPI를 타는 함수이기 때문에, 제일 마지막에 실행 되었던 것이다.\n\nAjax 도 마찬가지이다.\n\n```js\nconsole.log('Hi! again.');\n\nfetch(.......).then(() => {\n    console.log('Fetched!');\n});\n\nconsole.log('Bye! again.');\n```\n\n위 코드는 Ajax 통신의 예제이다.\n\n자 마찬가지로, 먼저 Hi! again을 찍는 콘솔 로그함수가 콜스택에 쌓이고, 빠져나오고 실행된다.\n그다음 fetch 함수가 콜스택으로 들어가는데, webAPI인 fetch를 실행함으로,fetch 함수는 XHR통신이 모두 완료될때까지 계속 일한다.\n하지만 콜스택에서는 fetch 함수가 이미 빠져나간다.\n따라서 Bye!again을 찍는 함수가 콜스택으로 들어갔다 나옴으로써 실행되며 Bye!again. 이 먼저 찍히고,\nXHR 통신이 마무리 되었다면, fetch의 콜백인 `console.log('Fetched!');` 가 task queue로 들어가게 되고 이벤트루프는 비어있는 콜스택을 발견하고 콜백함수를\n콜스택으로 넣는다.\n\n이제서야 `console.log('Fetched!');`가 실행 되는 것이다.\n\n좀더 심화된 예제를 보자.\n\n```js\nconsole.log('Oops!');\n\nbutton.addEventListener('click', () => {\n    console.log('hehe did you click me?');\n});\n\nsetTimeout((() => {\n    console.log('I waited 3000ms!');\n}), 3000);\n\nconsole.log('Yay!');\n```\n\n자 위 코드는 어떻게 실행될것인지 예상이 가십니까??\n\n결과는 아래와 같습니다.\n\n```bash\nOops!\nYay!\nI waited 3000ms!\n```\n\n`hehe did you click me?` 는 버튼을 클릭할때 실행됩니다.\n\n따라서 무조건 Oops! 와 Yay! 보다는 늦게 실행 될수밖에 없습니다.\n\nweb api이기 때문이죠, 마찬가지로 이벤트 루프의 주시하에 Task Queue에 상주하고 있다가, 동기함수들이 실행되고 나서야 콜스택으로 가서 실행됩니다.\n\n만약 3초 안에 잽싸게 버튼을 누른다면, I waited 3000ms! 보다 먼저 찍히겠죠.\n\n근데 저 3000ms , 즉 3초가 정확한 3초를 의미할까요?\n\n정답은 `아니다.` 입니다.\n\n왜냐면 함수를 모두 처리하기 까지의 최소 지연 시간이 3초 라는 의미기 때문이지요.\n\n따라서 setTimeout 의 두번째인자를 0으로 두어도, 비동기적으로 작동합니다.\n\n이유는 최소 기다림의 시간이 0ms 라는 말이지, 0ms 만에 실행되지는 못합니다. 비동기 함수이기 때문에, task queue 에서 기다렸다 실행되기 때문이죠.\n\n# async 함수들의 이점 (benefit)\n\n자 그렇다면, 브라우저의 렌더링은 비동기일까요?\n맞습니다.\n\n웹 api 이잖아요.\n\n애초에 브라우저가 렌더링 하여 보여주는것 자체가 비동기 event 라는 겁니다.\n\nrender queue 라고도 하는데, 다른 비동기 웹 API 보다 우선권을 갖습니다. (하지만 콜스택에 들어가는 동기 함수보다는 우선권이 작습니다.)\n따라서 매 16ms 마다 큐에 렌더가 들어가고 스택이 깨끗해진 후에야 렌더링을 합니다.\n\n그런데, 그 위에 많은 동기 이벤트(비동기가 아닙니다, 동기!)를 쌓게 되면, 브라우저 렌더링이 멈추겠죠?\n\n왜냐면, 다른 콜스택에 들어간 동기 함수를 먼저 실행하고 있기 때문입니다. 그럴때, 브라우저는 작동이 멈춥니다.\n\n처리하는데 시간이 많이 걸리는 작업들을 동기 함수로 구현하게 된다면 그 동기 함수를 여러번 실행 하다보면, 브라우저가 멈춥니다.\n이유는 렌더 비동기 함수가 다른 시간이 많이 걸리는 동기 함수들을 콜스택에서 사라지기까지 기다리기 때문이죠.\n\n그러나, 동기 함수가 아닌 비동기 함수로로 시간이 걸리는 작업들을 구현하게 되면, 브라우저가 멈추는 현상이 훨씬 줄어듭니다.\n\n왜냐면, 비동기 함수들 중간중간에 렌더 함수가 끼어들수 있기 때문입니다. (16ms 마다 끼어들수 있음.)\n\n# Don't block the Event Loop!\n\n이벤트루프를 막지 말아라! 라는 말은 결국 쓸데없이 시간이 많이드는 일들은 동기 함수로 구현하지 말고 비동기함수로 구현하라는 말입니다.\n비동기 함수는 이벤트 루프를 막는 확률이 적죠. \n\n저 어딘가에서 뒤에서 실행되다가, 실행이 완료되면 그때 콜백을 콜스택에 넣으니까요.\n\n# Web API 그리고 Javascript Engine\n\n정말 pure 한 자바스크립트 함수들, 예를 들면 console.log() 같은 함수들은 동기적 함수입니다.\n\n진짜 자바스크립트 그 자체 함수이기 때문이죠. 즉, 이벤트가 아니라는 겁니다.\n\n근데 우리가 실 상용하고 있는 웹앱들은 이벤트 투성이입니다. 즉 배열을 돌리거나, 덧셈 뺄셈 과 같은 사칙연산을 하거나 이런 함수들로만 이루어져있지 않단 말이죠.\n\n그렇다면 이런 Web API 이벤트들은 어떻게 실행될수 있는 걸까요?\n\n정답은 바로 Javascript Engine 에 있습니다.\n\n대표적으로 구글에서 만든 V8 엔진이 있죠. 현재 크롬에서 사용하고있는 자바스크립트 엔진입니다.\n\n* 링크: https://velog.io/@godori/JavaScript-engine-1 \n\n위 링크에서 자바스크립트 엔진에 대해 더 자세히 알아볼수 있습니다.\n\n이러한 자바스크립트 엔진을 타는 이벤트들은 모두 비동기 함수입니다. browser API 를 타는 함수들 이죠.\n\n위에서 자주 쓰인 setTimeout도 자바스크립트 엔진에서 돌아갑니다.\n우리가 자주쓰는 이벤트리쓰너도 마찬가지 입니다.\n\n이런 자바스크립트 엔진에 대해서 자세히 공부하면, 좀더 event loop를 이해하는데 도움이 되지 않을까 싶습니다.\n\n\n\n### 추가적으로, 이 글에서 맞지 않는 내용이 발견 된다면 그 즉시 댓글로 보고해주세요!!!!!\n\n\n","thumbnail":"Velog.png","excerpt":"Event Loop??? 그게 뭔데??","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2020-01-17T15:58:57.124Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"2018년 겨울을 맞이하며 남기는 글":{"id":158,"title":"2018년 겨울을 맞이하며 남기는 글","content":"요새 통 글을 쓰지 못하였다. 아니 안썼다고도 할수 있겠다.\n오늘 처음으로 내게 질문 주신 분이 있어서, 정말 오랜만에 내 블로그에 방문하였다. 처음으로 질문을 받는 다는 것 자체가 나에게는 굉장히 설레는 일이었고, 누군가 나의 글을 보면서 나의 튜토리얼을 따라하는 사람도 있구나 라는 생각에 최대한 정성스럽게 답변을 해드리고 싶었다.\n\n무튼, 질문때문에 내 블로그에 정말 오랜만에 방문 하였는데, 이유는 간단한거 같다. 원래 튜토리얼 쓰던 글이 있었는데, 여러가지 다른 일들에 치이다 보니, 그냥 내팽개쳐 버렸고.. 그 결과 무관심을 낳게되었다.\n\n나름 만들때는 열의있게 만든 블로그인데, 왠지모르게 멀어져 간듯한 느낌이다. 음 쓰던 튜토리얼을 마무리 지을지, 아니면 삭제 하고 다른 글들을 올릴지는 미정이지만, 블로그 관리를 좀 더 해야겠다. 좀 더 많은 사람들에게 도움이 되고 싶은 마음이 제일 크기 때문이다. 또한, 글을 쓰게 되면서 한번 더 나의 코드를 보게 되었고, 좀더 깔끔한 코드를 완성할수 있었던것도 사실이다.\n\n그렇다면!\n그동안 무슨일이 있었냐 하면... 바로 리액트 개발자로써 최종 합격하게 되었다!\n정말 감사한 일이다. 간절히 바래왔던 리액트 개발자로써의 꿈이 이루어지는 순간이었다. 당시 정말 행복했고, 아드레날린이 솟구침을 느낄수 있었다.\n\n![YES!](https://media.giphy.com/media/3ohzdIuqJoo8QdKlnW/giphy.gif)\n\n허나.. 아직 학생 신분인 나는 학교 졸업작품과 회사와 연동하여 실습하는 프로젝트 수업을 마치고 가야만 했다.. 고맙게도 회사에서는 기다려준다는 연락이 왔고, 이 때 동안 바쁘게 바쁘게 살았던 이유는 바로 두 프로젝트를 완성하기 위함이었다. 뭐 한마디로 학교에서의 마무리를 짓고, 회사로 나올 준비를 했다고 보면 될 것 같다. \n\n두 프로젝트 모두 내가 해야 할 일은 마무리 지었고, 이제 회사에 갈 날만을 기다리고 있다. 또한, 학교에서의 모든 짐을 털어 내기도 하였다. 뭐 여러가지 일들이 있었지만, 사적인 일이므로 속으로만 시원하다고 생각 하도록 하겠다!\n\n역시 사람은 무엇을 하던간에, 거저 얻어지는 것은 의미가 없나보다... 여름방학 부터 취업을 하려고 정말 노력했지만, 마음대로 되지 않았다. 나는 이때까지 어른들이나 먼저 취업한 사람들이 취업에서 혹은 면접에서 떨어질때에, \"그 회사랑 너랑 안맞는거야\" 라고 하는것이 단지 나를 위로하려고 하는 그런 말인줄로만 생각했는데, (그런의미도 당연히 있지만.. ㅋㅋ) 단순한 그런 말은 아니었던것 같다. \n\n한창 취업이 안될때에, 주변인들에게 염치불구하고 취업에 대해 많이 물어보았다. 그중 한분은 이렇게 말을 하였다. \"회사입장에서, 더군다나 스타트업이라면 사람을 뽑는것이 예사일이 아닙니다. 대부분 절대 사람을 막 들이거나 일용직 처럼 생각하면서 뽑지 않아요.\" \n\n\n돌이켜 보면 정말 맞는 말이다. 내가 사회에 대한 불신이 가득했던지 혹은 취업이 안되어서 부정적으로 바라보았는지, 저 말이 그 당시에는 사실 잘 와닿지 않았다. 근데 여러군데 면접을 보러다니니까 확실히 위 두 말들이 모두 사실이었다. 정말 갖고 싶은 실력의 개발자라면 뭐... 어딜 가던지 일은 할수 있겠다만, 나는 신입으로 들어가는 것이었기 때문에, 지원자들 대부분 실력은 대동소이 하다고 생각 한다. (다분히 나의 주관적인 생각) 허나 그 중에서 사람을 뽑는 다면, 정말 그 사람이 주는 느낌, 신뢰감, 우리와 맞을 것 같다는 느낌적인 느낌이 강하게 작용할거라고 생각이 든다.\n\n또한, 그 사람이 회사와 맞다는 것은, 사용해보았던 기술 스택들도 크게 작용하는 것 같다. 예전에 취업을 준비할때, 주변인에게 한번 물어본적이 있었다. \"스타트업에 취업하려하는데, 해줄수 있는 조언같은것 있나요?\" 라고.\n\n답은 이러했다. \"음.. 일단 아무리 화려하게 프로젝트를 했다 하더라도, 기본을 무시하거나, 기본이 부족한 개발자들은 지원을 하더라도 많이 떨어지는 것을 보았다. 그리고 또한 회사의 성격과 맞는 (예를 들면 음악 스트리밍 관련 회사라면 음악 스트리밍 프로젝트가 있다면 큰 가산점이 된다 라는 뜻) 프로젝트를 해본 경험이 있다면, 도움이 많이 될것이다.\"\n\n주옥같은 말이다. \n\n무튼 이제 마무리를 지어야 겠다. 나의 글은 항상 주저리주저리 하다 끝나는것 같다... ㅋㅋㅋ (뭐 어디까지나 일기형식의 글이니까..)\n\n1년동안 나름 다사다난 했지만, 그래도 내 목표하나만큼은 이룰수 있었고, 그의 원동력은 바로 간절함이었다. 그 간절함이 없었다면 나는 아직도 내가 무엇을 하려고 하는지, 어떤 개발자가 되어야 하는지 애초에 깨닫지 못했을 것이고, 목표를 이룰수 없었을 거라는 생각이 든다.\n\n앞으로도 이 초심 잃지 않고 쭉 가자!\n\n![Steady](https://media.giphy.com/media/26BRNjat0rzLxmWXe/giphy.gif)\n\n\n\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"2018년 겨울을 맞이하며 남기는 글","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-11-14T13:35:43.969Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"2018년 가을을 맞이하면서 드는 생각들":{"id":159,"title":"2018년 가을을 맞이하면서 드는 생각들","content":"> 오랜만에 벨로그에 글을 남기네요! 최근 취업준비를 하다보니 글을 남길 시간이 없었습니다! 그 사이 벨로그에 좋은 글들이 많이 올라왔네요! 점점 많은 글들이 올라오는 것이 보기 아주 좋습니다. 글에 대한 설명을 하자면 제 블로그에 먼저 글을 올려서, 저에 대한 일기같은 형식의 문체 입니다. 그러나 현 시대의 젊은이라면, 혹은 신입 개발자라면 같이 공감 할 수 있는 분들이 있을것 같아서 올려보는 글이니, 관심 있는 분들은 가볍게 읽어 주시면 감사하겠습니다. 원글은 https://killi8n.com/post/5bc73813fb3ef567f38234d1 에서 보실수 있습니다. 감사합니다.\n\n오랜만에 글을 쓴다. 벌써 2018년도 10월 중순에 접어들었고, 곧있으면 겨울이 올것 같은 기분이 든다. 시간은 나이가 들수록 더 빨리 간다더니, 맞는 말인것 같다. 1주일이 체감상 3일같다. \n\n근래 1주~2주 정도는 뭔가 효율적인 삶을 살진 않았던것 같다. 머리에 드는 생각들에 갇혀서 무언가 행동에 옮겨야 할 것들이 있다는 것을 인지 했지만, 막상 행동으로 옮기지는 못한 느낌이었다. \n\n사실 지금 무엇이 우선순위이고, 무엇이 차후에 해도 되는것인지 인식하기가 쉽지 않다. 곧있으면 학교 시험기간이라 당분간은 개발에 집중을 하지 못할것 같다. \n\n개발을 하다가 아이디어가 떠올라 막상 시작했지만, 완벽하게 끝내지 못한것이 몇 있는데, 조금더 딜레이 기간이 있을것 같다.\n\n또한, 최근에는 다시 취업전선에 뛰어 들면서 여러가지를 느끼게 되었다. 전까지만 해도 내가 신입 개발자로서 어떠한 수준인지, 어느 정도로 내가 개발자로서 자신이 있는지 피상적으로만 느낄뿐, 정확한 인식을 하지는 못했던것 같다. 허나, 취업하려고 여러군데 이곳저곳 많지는 않지만 나에게 맞을 만한 곳에 이력서를 넣고, 나의 프로젝트들을 정리한 자료들을 돌렸다. 덕분에 나의 수준을 알게 된것 같다.\n\n확실히 좋은 개발자들이 많고, 딱 보기에 소문이 좋게 난 기업들 혹은 스타트업들에서는 나를 찾지 않았다. 지금 나의 개발자로서의 역량은 딱 거기까지인것 같다. 뭔가 조금 할줄은 알지만, 특출난 무언가가 없는 그런 애매한 상태.\n\n사람을 뽑는 사람 입장으로써 내가 나를 보아도 크게 와닿는 개발자로써의 프로젝트가 없었다. 조금더 나의 아이디어가 부각된 체계적인 개발 방식이 필요하다는 것을 느꼈다.\n\n이때까지는 단순한 호기심 및 즉흥적인 재미로 프로젝트를 만들어 온것 같다. 이런식으로 가다가는 무언가 내가 내 발에 채일것 같은 느낌이 많이 들었다. 이제는 조금더 프로 개발자로써의 느낌을 많이 살리는 프로젝트를 심도있게 만들어 보아야 겠다는 생각이 든다.\n\n또한 나는 단순한 코더인가? 역량있는 개발자 인가? 라는 질문에도 자신이 없다.\n그냥 취미로 하는 개발자라면 모를까, 내 꿈을 향해 달려가는 이 시점에서 단순한 코더로 내가 정체하게 된다면 나의 미래에 안좋은 영향을 상당히 가져다 줄 것이다. 조금더 심도있게 개발 및 개발환경을 더 공부해야 겠다는 생각이 든다.\n\n2018년이 아직 2달 조금 넘게 남아있지만, 지금 시점에서 돌아보면 근 10개월간 허겁지겁 달려온것 같다. 작년까지만 해도 마음이 이렇게 무겁진 않았는데 말이다. 나를 위한 시간을 갖지 못한 것이 사실이고, 꿈을 좇아간다는 핑계로 나를 조금 돌보지 못한것도 사실인것 같다. 단계단계 올라가야 하는데 무언가 두칸씩, 세칸씩 가려다보니 욕심으로 인해 무언가를 망칠것도 같다. 허나 난 내가 바보가 아니라고 생각하고, 그 당시에 나에게 최선의 선택을 했다고 생각하기에 어떤 선택을 내렸어도 절대 헛된 선택은 아니라고 생각한다.\n\n이제 결론을 짓자면, 나는 현재 매우 애매한 상태이다. 또한 나에 대한 자신감이 긴가 민가 하다. 이러한 시기일수록 나를 좀더 믿고 나의 마음에서 우러나오는 소리를 더 경청해야 겠다는 생각이 든다. 부정적인 생각들은 털어버리고 긍정적인 생각까지는 못하더라도 부정적인 생각의 빈도를 줄이려고 노력해야겠다. 언젠가는 나도 누가 같이 일해보고 싶은, 먼저 찾는 그런 사람이 될수 있을것이다.\n\n남은 2018년 조금더 노력하자. 남의 눈보다는 나의 마음에 경청하되, 남에게 피해를 주지 않으면서, 나에게 선물을 줄수있는 삶을 살자.\n\n","thumbnail":"Velog.png","excerpt":"2018년 가을을 맞이하면서 드는 생각들","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-10-17T13:32:20.432Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 5 - 1. Django - 권한 설정 및 로그인 / 회원가입 구현":{"id":160,"title":"Dnote 5 - 1. Django - 권한 설정 및 로그인 / 회원가입 구현","content":"일단 권한을 설정 해야 하니까, Django로 돌아옵시다.\n\ndjango-rest-knox 라는 패키지를 다운로드 해야합니다.\n\n\n```bash\n$ (venv) pip install django-rest-knox\n```\n\n`settings.py`\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'notes',\n    'rest_framework',\n    'knox',\n]\n\n...\n# 제일 하단에 추가해줍니다.\n# 처음에 10개만 받아오기 위해 PAGE_SIZE를 설정했습니다.\n# 그리고 기본 권한을 knox의 token을 기반으로 설정했습니다.\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',\n    'PAGE_SIZE': 10,\n    'DEFAULT_AUTHENTICATION_CLASSES': ('knox.auth.TokenAuthentication',),\n}\n```\n\n```bash\n$ (venv) python manage.py makemigrations\n$ (venv) python manage.py migrate\n```\n\n이제 기본 권한을 설정했으니, notes 모델에서 owner 필드를 추가해주겠습니다.\n\n`notes/models.py`\n\n```python\nfrom django.db import models\nfrom django.contrib.auth.models import User\n\n\nclass Notes(models.Model):\n    text = models.CharField(max_length=255)\n    owner = models.ForeignKey(\n        User, related_name=\"notes\", on_delete=models.CASCADE, null=True\n    )\n    created_at = models.DateTimeField(auto_now=False, auto_now_add=True)\n\n    def __str__(self):\n        return self.text\n\n```\n\nUser 모델을 가져온뒤, foreign key로 설정했네요.\n\n\n그리고 모델을 수정했으니 다시한번 migrate 해줍니다.\n\n```bash\n$ (venv) python manage.py makemigrations\n$ (venv) python manage.py migrate\n```\n\nviews.py에서는 모든 노트를 불러왔던것을 이제 owner별로 불러오는 작업을 해주겠습니다. 그리고, 노트를 만들때, owner 필드에 값을 넣어야겠죠?\n\n`notes/views.py`\n\n```python\nfrom rest_framework import viewsets, permissions\nfrom .models import Notes\n\n\nclass NoteViewSet(viewsets.ModelViewSet):\n\tpermission_classes = [permissions.IsAuthenticated, ]\n    serializer_class = NoteSerializer\n\n    def get_queryset(self):\n        return self.request.user.notes.all().order_by(\"-created_at\")\n\n    def perform_create(self, serializer):\n        serializer.save(owner=self.request.user)\n```\n\n자 이제, 회원가입 및 로그인에 대한 API 구현을 해보겠습니다.\n\n\n`notes/serializers.py`\n\n```python\nfrom rest_framework import serializers\nfrom .models import Notes\nfrom django.contrib.auth.models import User\nfrom django.contrib.auth import authenticate\n\n...\n\n# 회원가입 시리얼라이저\n\nclass CreateUserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = (\"id\", \"username\", \"password\")\n        extra_kwargs = {\"password\": {\"write_only\": True}}\n\n    def create(self, validated_data):\n        user = User.objects.create_user(\n            validated_data[\"username\"], None, validated_data[\"password\"]\n        )\n        return user\n\n\n# 접속 유지중인지 확인할 시리얼라이저\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = (\"id\", \"username\")\n\n\n# 로그인 시리얼라이저 \n\nclass LoginUserSerializer(serializers.Serializer):\n    username = serializers.CharField()\n    password = serializers.CharField()\n\n    def validate(self, data):\n        user = authenticate(**data)\n        if user and user.is_active:\n            return user\n        raise serializers.ValidationError(\"Unable to log in with provided credentials.\")\n\n```\n\n위와같이 serializer를 만들고, \n\n\n`notes/views.py`\n\n```python\nfrom rest_framework import viewsets, permissions, generics\nfrom rest_framework.response import Response\nfrom .models import Notes\nfrom .serializers import (\n    NoteSerializer,\n    CreateUserSerializer,\n    UserSerializer,\n    LoginUserSerializer,\n)\nfrom knox.models import AuthToken\n\n....\n\n\n\nclass RegistrationAPI(generics.GenericAPIView):\n    serializer_class = CreateUserSerializer\n\n    def post(self, request, *args, **kwargs):\n        if len(request.data[\"username\"]) < 6 or len(request.data[\"password\"]) < 4:\n            body = {\"message\": \"short field\"}\n            return Response(body, status=status.HTTP_400_BAD_REQUEST)\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = serializer.save()\n        return Response(\n            {\n                \"user\": UserSerializer(\n                    user, context=self.get_serializer_context()\n                ).data,\n                \"token\": AuthToken.objects.create(user),\n            }\n        )\n\n\nclass LoginAPI(generics.GenericAPIView):\n    serializer_class = LoginUserSerializer\n\n    def post(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = serializer.validated_data\n        return Response(\n            {\n                \"user\": UserSerializer(\n                    user, context=self.get_serializer_context()\n                ).data,\n                \"token\": AuthToken.objects.create(user),\n            }\n        )\n\n\nclass UserAPI(generics.RetrieveAPIView):\n    permission_classes = [permissions.IsAuthenticated]\n    serializer_class = UserSerializer\n\n    def get_object(self):\n        return self.request.user\n\n```\n\nserializer들도 만들어 줍니다.\n\n`notes/urls.py`\n\n```python\nfrom django.conf.urls import url\nfrom .views import NoteViewSet, RegistrationAPI, LoginAPI, UserAPI\n\n\nnote_list = NoteViewSet.as_view({\"get\": \"list\", \"post\": \"create\"})\n\nnote_detail = NoteViewSet.as_view(\n    {\"get\": \"retrieve\", \"patch\": \"partial_update\", \"delete\": \"destroy\"}\n)\n\n\nurlpatterns = [\n    url(\"^notes/$\", note_list, name=\"note-list\"),\n    url(\"^notes/(?P<pk>[0-9]+)/$\", note_detail, name=\"note-detail\"),\n    url(\"^auth/register/$\", RegistrationAPI.as_view()),\n    url(\"^auth/login/$\", LoginAPI.as_view()),\n    url(\"^auth/user/$\", UserAPI.as_view()),\n]\n\n```\n이렇게 url 라우팅도 해주면 장고작업은 끝이납니다.\n\npostman 에서 body에 raw -> JSON형태로\n```json\n{\n\t\"username\": \"testing\",\n\t\"password\": \"1234\"\n}\n```\n를 넣어주시고, http://localhost:8000/api/auth/register/ 와 http://localhost:8000/api/auth/login/ 을 POST 방식으로 실행하면 잘 실행이 될것입니다.\n\n또한 접속된 유저 정보를 보기  위해서는, http://localhost:8000/api/auth/user/ 로 Headers 에 Authorization 항목을 넣고 __token 토큰값__ 으로 GET 실행 하면 유저 정보가 뜨게됩니다.\n\n마지막으로 로그아웃을 구현하는것은 간단합니다.\n\n`d_note/urls.py`\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\n\nfrom notes import urls\nfrom django.conf.urls import include, url\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    url(r\"^api/\", include(urls)),\n    url(r\"^api/auth\", include(\"knox.urls\")),\n]\n\n```\n다음과 같이 설정하면, /api/auth/logout/ 으로 Authorization: token 토큰값 으로 실행하면 로그아웃이 됩니다.\n","thumbnail":"Velog.png","excerpt":"Dnote 5 - 1. Django - 권한 설정 및 로그인 / 회원가입 구현","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-23T10:05:17.452Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 7. React - 404페이지 완성 및 빌드된 리액트 띄우기":{"id":161,"title":"Dnote 7. React - 404페이지 완성 및 빌드된 리액트 띄우기","content":"음 이제 마지막이네요!\n\n그러나 로그인 후 에러가 나타나는 현상을 방지하기 위해,\n\nNoteContainer를 다음과 같이 바꿔주도록 하겠습니다!\n\n`containers/NoteContainer.js`\n\n```jsx\n...\nimport * as authActions from \"store/modules/auth\";\n\n...\n\n\ncomponentDidMount() {\n  // 에러 초기화\n  this.props.initializeError();\n  this.getNotes();\n  window.addEventListener(\"scroll\", this.handleScroll);\n}\n\n...\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    changeNoteInput: ({ value }, isEditing) => {\n      dispatch(noteActions.changeNoteInput({ value }, isEditing));\n    },\n    addNote: () => {\n      dispatch(noteActions.addNote());\n    },\n    getNotes: () => {\n      dispatch(noteActions.getNotes());\n    },\n    toggleNote: ({ id, text }) => {\n      dispatch(noteActions.toggleNote({ id, text }));\n    },\n    updateNote: () => {\n      dispatch(noteActions.updateNote());\n    },\n    deleteNote: ({ id }) => {\n      dispatch(noteActions.deleteNote({ id }));\n    },\n    getMoreNotes: ({ lastId }) => {\n      dispatch(noteActions.getMoreNotes({ lastId }));\n    },\n    //에러 초기화\n    initializeError: () => {\n      dispatch(authActions.initializeError());\n    }\n  };\n};\n\n...\n```\n\n404페이지를 완성하고 장고서버로 빌드된 리액트를 띄워볼까요?\n\n다음과 같이 NotFound 컴포넌트를 생성해주세요.\n\n\n`components/common/NotFound/NotFound.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NotFound.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst NotFound = () => (\n  <div className={cx(\"not-found\")}>\n    <div className={cx(\"description\")}>\n      Hmm...\n      <br /> You've reached some weird page!\n      <div className={cx(\"go-back\")}>Go Back</div>\n    </div>\n  </div>\n);\n\nexport default NotFound;\n\n\n```\n\n`components/common/NotFound/NotFound.scss`\n\n```css\n@import \"utils\";\n\n.not-found {\n  background: $oc-violet-7;\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  height: 100vh;\n  .description {\n    color: white;\n    font-size: 2rem;\n\n    @include media(\"<medium\") {\n      font-size: 1.5rem;\n      margin-left: 1rem;\n      margin-right: 1rem;\n    }\n    .go-back {\n      display: flex;\n      justify-content: center;\n      margin-top: 1rem;\n      color: white;\n      font-weight: 700;\n\n      border: 1px solid white;\n      border-radius: 2px;\n\n      cursor: pointer;\n\n      user-select: none;\n\n      &:hover {\n        background: $oc-violet-6;\n      }\n\n      &:active {\n        background: $oc-violet-7;\n      }\n    }\n  }\n}\n\n```\n\n\n`components/common/NotFound/index.js`\n```js\nexport { default } from './NotFound';\n```\n\n컨테이너도 하나 만들어 줍니다.\n\n`containers/NotFoundContainer.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport NotFound from \"components/common/NotFound\";\n\nexport class NotFoundContainer extends Component {\n  render() {\n    return <NotFound />;\n  }\n}\n\nconst mapStateToProps = state => ({});\n\nconst mapDispatchToProps = {};\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(NotFoundContainer);\n\n```\n\n페이지에 반영해줍니다.\n\n`pages/NotFound.js`\n\n```jsx\nimport React from \"react\";\nimport NotFoundContainer from \"containers/NotFoundContainer\";\nconst NotFound = () => {\n  return <NotFoundContainer />;\n};\n\nexport default NotFound;\n\n```\n\n이렇게 하면 나름 깔끔한 NotFound페이지가 보여지게 됩니다.\n\n이제 뒤로가기 기능을 추가해보겠습니다.\n\n`containers/NoteContainer.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport NotFound from \"components/common/NotFound\";\nimport { withRouter } from \"react-router-dom\";\n\nexport class NotFoundContainer extends Component {\n  handleGoBack = () => {\n    const { history } = this.props;\n    history.goBack();\n  };\n  render() {\n    const { handleGoBack } = this;\n    return <NotFound onGoBack={handleGoBack} />;\n  }\n}\n\nconst mapStateToProps = state => ({});\n\nconst mapDispatchToProps = {};\n\nexport default withRouter(\n  connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(NotFoundContainer)\n);\n\n```\n\n`components/common/NotFound/NotFound.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NotFound.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst NotFound = ({ onGoBack }) => (\n  <div className={cx(\"not-found\")}>\n    <div className={cx(\"description\")}>\n      Hmm...\n      <br /> You've reached some weird page!\n      <div className={cx(\"go-back\")} onClick={onGoBack}>\n        Go Back\n      </div>\n    </div>\n  </div>\n);\n\nexport default NotFound;\n\n```\n\n이제 뒤로가기도 잘됩니다!\n\n자 이제는 빌드한것을 띄우는 노드 서버를 하나 개설해 보겠습니다.\n그 전에 yarn build로 미리 빌드 해주세요.\n\n우리의 백엔드와 프론트엔드가 있는 같은 위치에 build-server라는 폴더를 만들어 주세요. 그리고 그 폴더로 들어가서 \n\n```bash\nyarn init -y \n```\n\n를 해주십시오.\n\n그다음에 다음 명령어로 필요한 node 패키지들을 다운받아줍니다.\n\n\n```bash\nyarn add koa koa-connect-history-api-fallback koa-proxy koa-static\n```\n\n저희는 express보다 조금더 가벼운 노드 서버 라이브러리인 koa를 사용하겠습니다.\n\n그리고 src 폴더를 하나 만들고 그 밑에 index.js 를 만들어주세요.\n\n`src/index.js`\n\n```js\nconst Koa = require(\"koa\");\n\nconst proxy = require(\"koa-proxy\");\n\nconst path = require(\"path\");\nconst serve = require(\"koa-static\");\nconst fallback = require(\"koa-connect-history-api-fallback\");\n\nconst buildPath = path.join(__dirname, \"../../frontend/build\");\n\nconst port = 4000;\n\nconst app = new Koa();\n\napp.use(\n  proxy({\n    host: \"http://localhost:8000\",\n    match: /^\\/api\\/*.*/\n  })\n);\n\napp.use(fallback());\n\napp.use(serve(buildPath));\n\napp.listen(port, () => {\n  console.log(\"build server is running on port\", port);\n});\n\n```\n\n다음과 같이 작성해줍니다.\n\n저희의 빌드 된 파일은 frontend/build 에 들어가 있으므로, 그 파일을 serve해주는 것입니다.\n\n그런데, 저희는 백엔드 포트를 8000번을 사용하므로, proxy를 설정해주어야 합니다.\n\n그 후에 fallback을 사용하여 빌드된 리액트의 라우팅을 모두 싱크시켜줍니다.\n\n자 이렇게 하고 localhost:4000 에 접속하면 잘뜨게 됩니다!\n\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 7. React - 404페이지 완성 및 빌드된 리액트 띄우기","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-23T10:07:28.385Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Mongodb 덤프하고 백업하기":{"id":162,"title":"Mongodb 덤프하고 백업하기","content":"AWS를 쓰는 ... (무료로쓰는 혹은 돌려막기 하는...) 저같은 사용자에게 꼭필요한 DB덤프하고 덮어쓰기 !\n\n이 블로그 또한 10개월 남짓 남은것 같은데 한 9개월 정도 남았을때에 덤프 과정이 필요할거 같아서 서핑 후 글을 남긴다.\n\n# 덤프하기 \n\n일단 몽고디비가 깔려있다면, mongodump라는 명령어로 덤프를 시켜야한다.\n\n아래 명령어를 실행하게 되면 내 현재 위치에 dump라는 폴더가 생기게된다.\n\n```bash\nmongodump --host 127.0.0.1 --port 27017\n```\n\n--out 명령어로 위치를 지정해줄수도 있다. host와 port는 기본값인 127.0.0.1과 27017을 사용했다.\n\n```bash\nmongodump --out ~/mongo_backup --host 127.0.0.1 --port 27017\n```\n\n혹은 아이디와 비밀번호로 잠금된 몽고디비라면\n\n```bash\nmongodump --out ~/mongo_backup --host 127.0.0.1 --port 27017 -u계정명 -p계정비번 \n```\n\n으로 가능하고, 또한 모든 데이터베이스를 덤프하려는게 아니면 --db옵션을 사용하여 선택적으로 덤프가 가능하다.\n\n```bash\nmongodump --out ~/mongo_backup --host 127.0.0.1 --port 27017 -u계정명 -p계정비번 --db 선택적으로 복구하려는 db명\n```\n\n즉, dump 명령어를 정리하자면 다음과 같다.\n\n```bash\nmongodump --out 덤프지정위치(디렉터리) --host 127.0.0.1 --port 27017 -u계정명 -p계정비번 --db 선택적으로 복구하려는 db명\n```\n\n# 복구하기\n\n덤프를 했으니, 덤프를 해놓은 데이터들을 바탕으로 복구를 해야한다.\n\n마찬가지로 mongodb가 설치되어 있다면, command창에서 mongorestore를 사용가능 할것이다.\n\n```bash\nmongorestore --host 127.0.0.1 --port 27017 -u계정명 -p비번 --drop 원래디비에서 드랍시킬 디비명 --db 선택적으로 복구하려는 db명 \"복구하려는 덤프된 디렉터리 위치\"\n```\n\n--drop 옵션은 덤프하려는 데이터와 현재 디비에있는 데이터가 겹칠시 drop시키는 기능이다.\n\n나의 블로그 복구를 예로들어보겠다.\n\n## ex)\n\n```bash\nmongorestore --host 127.0.0.1 --port 27017 --drop myblog --db myblog ~/mongo_backup\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n> 유용하게 보셨다면 다른 좋은글이 있을지는 모르겠으나,,, 함들러보세요!\n\nhttps://killi8n.com\n\n","thumbnail":"Velog.png","excerpt":"Mongodb 덤프하고 백업하기","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-30T10:00:15.808Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 6 - 1. React - 무한 스크롤링 기능 구현.":{"id":163,"title":"Dnote 6 - 1. React - 무한 스크롤링 기능 구현.","content":"이제 무한 스크롤링 기능을 구현해 보겠습니다.\n\n무한 스크롤링은 브라우저가 아래에 닿았을때, 저희가 마지막으로 보여주는 노트 아이템의 id를 기준으로 다음 10개의 노트 아이템들을 받아올 예정입니다.\n\nNoteContainer에 다음을 추가해주겠습니다.\n\n`containers/NoteContainer.js`\n\n```jsx\n...\n\ncomponentDidMount() {\n  this.getNotes();\n  // 스크롤링 이벤트 추가\n  window.addEventListener(\"scroll\", this.handleScroll);\n}\n\ncomponentWillUnmount() {\n  // 언마운트 될때에, 스크롤링 이벤트 제거\n  window.removeEventListener(\"scroll\", this.handleScroll);\n}\n\n...\n\nhandleScroll = () => {\n  const { innerHeight } = window;\n  const { scrollHeight } = document.body;\n  // IE에서는 document.documentElement 를 사용.\n  const scrollTop =\n    (document.documentElement && document.documentElement.scrollTop) ||\n    document.body.scrollTop;\n  // 스크롤링 했을때, 브라우저의 가장 밑에서 100정도 높이가 남았을때에 실행하기위함.\n  if (scrollHeight - innerHeight - scrollTop < 100) {\n    console.log(\"Almost Bottom Of This Browser\");\n  }\n};\n```\n\n일단 스크롤링을 해야하므로 노트들을 20개정도 추가해주세요.\n\n그리고 스크롤링해서 바닥에 닿으면 console에 로그가 찍힙니다.\n\n그러면 이제 바닥에 거의 닿았을때, 더 많은 노트를 가져오는 API를 작성한후, redux처리를 해서 기능을 구현해야 합니다.\n\n장고쪽으로 다시 돌아와주세요.\n\n`notes/views.py`\n\n```python\nclass LoadMoreNotes(generics.ListAPIView):\n    permission_classes = [permissions.IsAuthenticated, ]\n    serializer_class = NoteSerializer\n\n    def get(self, request, *args, **kwargs):\n        flagId = kwargs['id']\n        notes = Notes.objects.filter(owner=self.request.user).filter(id__lt=flagId).order_by('-created_at')[:10]\n        isLast = False\n        if len(notes) < 10:\n            isLast = True\n        serializer = self.get_serializer(notes, many=True, context={\"request\": request})\n        return Response({\n            \"notes\": serializer.data,\n            \"isLast\": isLast\n        })\n```\n\n`notes/urls.py`\n\n```python\nfrom django.conf.urls import url\nfrom .views import NoteViewSet, RegistrationAPI, LoginAPI, UserAPI, LoadMoreNotes\n# LoadMoreNotes 가져오기\n\n\nnote_list = NoteViewSet.as_view({\"get\": \"list\", \"post\": \"create\"})\n\nnote_detail = NoteViewSet.as_view(\n    {\"get\": \"retrieve\", \"patch\": \"partial_update\", \"delete\": \"destroy\"}\n)\n\n\nurlpatterns = [\n    url(\"^notes/$\", note_list, name=\"note-list\"),\n    url(\"^notes/(?P<pk>[0-9]+)/$\", note_detail, name=\"note-detail\"),\n    url(\"^notes/next/(?P<id>[0-9]+)/$\", LoadMoreNotes.as_view()),\n    # 상단을 추가해줍니다\n    url(\"^auth/register/$\", RegistrationAPI.as_view()),\n    url(\"^auth/login/$\", LoginAPI.as_view()),\n    url(\"^auth/user/$\", UserAPI.as_view()),\n]\n\n```\nurl: `/api/notes/next/{id}/`\n\n이렇게 되면 url의 id를 바탕으로 작성자의 노트중 id 이후의 10개를 가져옵니다.\n\n그럼 이제 API작업은 끝났으니, 다시 리액트로 돌아와서 무한스크롤링을 마저 구현해보겠습니다.\n\nredux의 notes모듈에서 더 받아오기 epic을 추가해주겟습니다.\n\n`modules/notes.js`\n\n```js\nimport { ajax } from \"rxjs/observable/dom/ajax\";\nimport { of } from \"rxjs\";\nimport { map, mergeMap, catchError, withLatestFrom, \n        // 잠시간의 delay를 두어 로딩뷰를 띄우기 위해 추가해줍니다.\n        delay } from \"rxjs/operators\";\nimport { ofType } from \"redux-observable\";\n\n...\n\n\nconst GET_MORE_NOTES = \"notes/GET_MORE_NOTES\";\nconst GET_MORE_NOTES_SUCCESS = \"notes/GET_MORE_NOTES_SUCCESS\";\nconst GET_MORE_NOTES_FAILURE = \"notes/GET_MORE_NOTES_FAILURE\";\n\n...\n\nexport const getMoreNotes = lastId => ({\n  type: GET_MORE_NOTES,\n  payload: {\n    lastId\n  }\n});\n\nexport const getMoreNotesSuccess = ({ notes, isLast }) => ({\n  type: GET_MORE_NOTES_SUCCESS,\n  payload: {\n    notes,\n    isLast\n  }\n});\n\nexport const getMoreNotesFailure = error => ({\n  type: GET_MORE_NOTES_FAILURE,\n  payload: {\n    error\n  }\n});\n\n....\n\n\nconst getMoreNotesEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(GET_MORE_NOTES),\n    // 0.75초간의 딜레이를 줍니다.\n    delay(750),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      const token = localStorage.getItem(\"userInfo\")\n        ? JSON.parse(localStorage.getItem(\"userInfo\")).token\n        : null;\n      const { lastId } = action.payload;\n      return ajax\n        .get(`/api/notes/next/${lastId}/`, {\n          \"Content-Type\": \"application/json\",\n          Authorization: `token ${token}`\n        })\n        .pipe(\n          map(response => {\n            const { notes, isLast } = response.response;\n            return getMoreNotesSuccess({ notes, isLast });\n          }),\n          catchError(error =>\n            of({\n              type: GET_MORE_NOTES_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n\n...\n\n\nconst initialState = {\n  noteInput: \"\",\n  notes: [],\n  error: {\n    triggered: false,\n    message: \"\"\n  },\n  editing: {\n    id: null,\n    text: \"\"\n  },\n  // 아래 추가.\n  isLast: false,\n  isLoading: false\n};\n\n...\n\ncase GET_MORE_NOTES:\n      return {\n        ...state,\n        isLoading: true\n      };\ncase GET_MORE_NOTES_SUCCESS:\n  return {\n    ...state,\n    notes: state.notes.concat(action.payload.notes),\n    isLast: action.payload.isLast,\n    isLoading: false\n  };\ncase GET_MORE_NOTES_FAILURE:\n  return {\n    ...state,\n    error: {\n      triggered: true,\n      message: \"ERROR WHILE LOAD MORE, TRY AGAIN\"\n    }\n  };\n\n...\n\nexport const notesEpics = {\n  addNoteEpic,\n  getNotesEpic,\n  updateNoteEpic,\n  deleteNoteEpic,\n  getMoreNotesEpic\n};\n```\n\n`modules/index.js`\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { auth, authEpics } from \"./auth\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes, auth });\nexport const rootEpics = combineEpics(\n  notesEpics.addNoteEpic,\n  notesEpics.getNotesEpic,\n  notesEpics.updateNoteEpic,\n  notesEpics.deleteNoteEpic,\n  authEpics.loginEpic,\n  authEpics.registerEpic,\n  authEpics.checkUserEpic,\n  authEpics.logoutEpic,\n  notesEpics.getMoreNotesEpic\n);\n\n```\n\n`containers/NoteContainer.js`\n```jsx\n\n....\n\nhandleScroll = () => {\n  const { innerHeight } = window;\n  const { scrollHeight } = document.body;\n  const scrollTop =\n    (document.documentElement && document.documentElement.scrollTop) ||\n    document.body.scrollTop;\n  if (scrollHeight - innerHeight - scrollTop < 100) {\n    if (!this.props.isLoading && !this.props.isLast) {\n      const lastId = this.props.notes[this.props.notes.length - 1].id;\n      this.props.getMoreNotes({ lastId });\n    }\n  }\n};\n\n.....\n\nconst mapStateToProps = state => ({\n  noteInput: state.notes.noteInput,\n  notes: state.notes.notes,\n  error: state.notes.error,\n  editing: state.notes.editing,\n  // 아래 추가.\n  isLast: state.notes.isLast,\n  isLoading: state.notes.isLoading\n});\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    changeNoteInput: ({ value }, isEditing) => {\n      dispatch(noteActions.changeNoteInput({ value }, isEditing));\n    },\n    addNote: () => {\n      dispatch(noteActions.addNote());\n    },\n    getNotes: () => {\n      dispatch(noteActions.getNotes());\n    },\n    toggleNote: ({ id, text }) => {\n      dispatch(noteActions.toggleNote({ id, text }));\n    },\n    updateNote: () => {\n      dispatch(noteActions.updateNote());\n    },\n    deleteNote: ({ id }) => {\n      dispatch(noteActions.deleteNote({ id }));\n    },\n    // 아래 추가.\n    getMoreNotes: ({lastId}) => {\n      dispatch(noteActions.getMoreNotes({lastId}));\n    }\n  };\n};\n....\n```\n이렇게 되면 바닥에 닿았을때, 0.75초 간격으로 가져오게 됩니다.\n\n중복 받아오기를 방지하기 위하여 isLoading이거나, isLast일때에는 받아오지 않게 설정해놓았습니다.\n\n자 이제 로딩 뷰를 보여줘야겠죠?\n\n```bash\n$ yarn add better-react-spinkit\n```\n위와같은 모듈을 받아줍니다.\n\n잘 만들어진 로딩뷰를 보여주는 모듈입니다.\n\n그리고 LoadingView 컴포넌트를 다음과 같이 만들어줍니다.\n\n\n`components/notes/LoadingView/LoadingView.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./LoadingView.scss\";\nimport classNames from \"classnames/bind\";\nimport { ChasingDots } from \"better-react-spinkit\";\n\nconst cx = classNames.bind(styles);\n\nconst LoadingView = ({ isLoading }) => {\n  if (!isLoading) return null;\n  return (\n    <div className={cx(\"loading-view\")}>\n      <ChasingDots color={\"black\"} size={60} />\n    </div>\n  );\n};\n\nexport default LoadingView;\n\n```\n\n`components/notes/LoadingView/LoadingView.scss`\n\n```css\n@import \"utils\";\n\n.loading-view {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  padding-top: 1rem;\n  padding-bottom: 1rem;\n}\n\n```\n`components/notes/LoadingView/index.js`\n\n```js\nexport { default } from './LoadingView';\n```\n\n이 컴포넌트를 컨테이너에 반영합니다.\n\n`containers/NoteContainer.js`\n\n```jsx\n...\nimport LoadingView from \"components/notes/LoadingView\";\n\n...\n\n\nrender() {\n  const { noteInput, error, notes, editing, isLoading } = this.props;\n  const {\n    handleChange,\n    addNote,\n    handleToggle,\n    updateNote,\n    deleteNote\n  } = this;\n  return (\n    <div>\n      <NoteWrapper>\n        <InsertForm\n          noteInput={noteInput}\n          onChangeInput={handleChange}\n          onAdd={addNote}\n          error={error}\n        />\n        <NoteList\n          notes={notes}\n          editing={editing}\n          onToggle={handleToggle}\n          onChange={handleChange}\n          onUpdate={updateNote}\n          onDelete={deleteNote}\n        />\n        <LoadingView isLoading={isLoading} />\n      </NoteWrapper>\n    </div>\n  );\n}\n...\n\n```\n\n오 이제 로딩뷰도 보여지고, 무한 스크롤링이 아주 잘됩니다.\n\n\n근데 한가지 문제점이 남아있죠~ 바로 isLast가 아닌 상태에서 즉, 10개만 받아왔다고 가정하고, 나머지 10개가 남아있다는 상황에서 위에서부터 삭제를 하면 10개는 모두 사라지지만, 나머지 10개가 받아와지지 않습니다.\n\n이 문제를 해결하기 위해 다음과 같이 변경해줍니다.\n\n`containers/NoteContainer.js`\n\n```jsx\ndeleteNote = ({ id }) => {\n  const { deleteNote } = this.props;\n  deleteNote({ id });\n\n  const scrollHeight =\n    (document.documentElement && document.documentElement.scrollHeight) ||\n    document.body.scrollHeight;\n  const clientHeight =\n    (document.documentElement && document.documentElement.clientHeight) ||\n    document.body.clientHeight;\n  const offsetFlag = scrollHeight - clientHeight < 100;\n  if (offsetFlag) {\n    const lastId = this.props.notes[this.props.notes.length - 1].id;\n    if (!this.props.isLast) {\n      this.props.getMoreNotes({ lastId });\n    }\n  }\n};\n```\n\n지웠을때, 남아있는 스크롤의 높이가 100보다 작아지면 만약 isLast가 아니라면 더 받아오는 형식입니다.\n\n그러나 이렇게 했을때에도 버그가 있습니다.\n\n엄청나게 빨리 눌렀을때에 로딩이 되는도중에도 삭제가 진행되기 때문인데요.\n\n이 버그를 고쳐보겠습니다.\n\n`containers/NoteContainer.js`\n\n```jsx\ndeleteNote = ({ id }) => {\n  const { deleteNote } = this.props;\n  // 현재 props의 isLoading이 아닐때만 지워줍니다.\n  if (!this.props.isLoading) {\n    deleteNote({ id });\n  }\n\n  const scrollHeight =\n    (document.documentElement && document.documentElement.scrollHeight) ||\n    document.body.scrollHeight;\n  const clientHeight =\n    (document.documentElement && document.documentElement.clientHeight) ||\n    document.body.clientHeight;\n  const offsetFlag = scrollHeight - clientHeight < 100;\n  if (offsetFlag) {\n    const lastId = this.props.notes[this.props.notes.length - 1].id;\n    if (!this.props.isLast) {\n      this.props.getMoreNotes({ lastId });\n    }\n  }\n};\n```\n\n유후 이제 버그도 고쳤고 무한스크롤링도 되고 삭제시에도 더 많은 노트들을 보여줄수 있습니다!\n\n","thumbnail":"Velog.png","excerpt":"Dnote 6 - 1. React - 무한 스크롤링 기능 구현.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-23T10:06:55.996Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 5 - 3. React - 로그인 유지 및 로그아웃 기능 구현.":{"id":164,"title":"Dnote 5 - 3. React - 로그인 유지 및 로그아웃 기능 구현.","content":"자 이제는 로그인과 회원가입이 되었으니 로그인이 되었을때, 유지하는 기능을 추가하고, 로그인이 만약 안되었다면, 접속시 바로 로그인 페이지로 넘겨보고, 마지막으로 로그아웃 기능까지 구현해보겠습니다.\n\n일단 장고 앱에서는 회원가입만 하더라도, 토큰을 부여하게 됩니다. 그러니까, 회원가입 하자마자 로그인을 한다고 생각하시면 될것 같습니다.\n\n일단 로그인을 유지하려면 localStorage를 이용해야 합니다.\n\n따라서 로그인이나 회원가입이 완료되면 저희 redux 의 auth에서 logged라는 state가 있는데, 이 logged가 true로 바뀌게 됩니다.\n\n`modules/auth.js`\n\n```js\ncase REGISTER_SUCCESS:\n  return {\n    ...state,\n    logged: true,\n    userInfo: {\n      id: action.payload.user.id,\n      username: action.payload.user.username,\n      token: action.payload.token\n    }\n  };\n\n...\n\n\ncase LOGIN_SUCCESS:\n  return {\n    ...state,\n    logged: true,\n    userInfo: {\n      id: action.payload.user.id,\n      username: action.payload.user.username,\n      token: action.payload.token\n    }\n  };\n```\n\n위와 같이 말이죠. 그리고 userInfo라는 state도 그에 맞에 변경이 됩니다.\n\n저희는 이제 이 값들을 AuthContainer에서 componentDidUpdate로 이용할 계획입니다.\n\n`containers/AuthContainer.js`\n\n```jsx\ncomponentDidUpdate(prevProps, prevState) {\n  // 하단에 AuthContainer를 withRouter로 감쌌기 때문에, history를 props로 이용할수 있습니다.\n  const { history } = this.props;\n  if (prevProps.kind !== this.props.kind) {\n    this.initialize();\n  }\n\n  if (prevProps.logged !== this.props.logged && this.props.logged) {\n    // logged가 true가 되면 localStorage에 값을 저장합니다. \n    localStorage.setItem(\n      \"userInfo\",\n      JSON.stringify({\n        id: this.props.userInfo.id,\n        username: this.props.userInfo.username,\n        token: this.props.userInfo.token\n      })\n    );\n    // 값을 저장후, main페이지로 이동시켜줍니다.\n    history.push(\"/\");\n  }\n}\n```\n\n자 이제 회원가입이나 로그인을 해보시면 이동하고, chrome 개발자 콘솔을 사용하여 localStorage로 쳐보시면 값이 저장된것을 알수 있습니다. 또한 localStorage에는 문자열밖에 저장하지 못하므로, JSON.stringify를 사용하여 JSON을 문자열로 변환시켜줍니다. \n\n아직까지는 에러가 발생하죠? 이유는 간단합니다, 저희가 메인 페이지로 이동하자마자 NoteContainer에서는 componentDidMount로 바로 노트 리스트를 받아오기 때문인데요, 저희는 아직 Header에 토큰값을 넘겨주지 않았기 때문에 401 에러가 뜹니다.\n\n\n이 에러를 고쳐주기 위해서는 redux의 notes모듈로 넘어가서 Header값에 Authorization을 넣어주어야 합니다.\n\n`modules/notes.js`\n\n```jsx\nconst getNotesEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(GET_NOTES),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      // localStorage의 userInfo를 JSON.parse를 통해 string을 JSON화 시킨후 token값만 가져옵니다.\n      const token = localStorage.getItem(\"userInfo\")\n        ? JSON.parse(localStorage.getItem(\"userInfo\")).token\n        : null;\n      // 헤더에 Authroization을 토큰값과 함께 넣어줍니다.\n      return ajax\n        .get(`/api/notes/`, {\n          \"Content-Type\": \"application/json\",\n          Authorization: `token ${token}`\n        })\n        .pipe(\n          map(response => {\n            const notes = response.response;\n            return getNotesSuccess({ notes });\n          }),\n          catchError(error =>\n            of({\n              type: GET_NOTES_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n```\n\n음 이렇게 바꾸고나니 또 에러가뜨죠? 이유는 저희가 django 앱에서 rest framework의 paging 기능을 사용했기 때문인데요, 이렇게 되면 받아올때 다음과 같은 정보들을 받게 됩니다.\n\n```js\n{count: 0, next: null, previous: null, results: []}\n```\n이런식으로 말이죠, count는 받아오는 아이템의 갯수, next는 다음 페이지의 api url, previous는 전 페이지의 api url, results에는 아이템들의 리스트값이 담겨 옵니다. 따라서 results라는 변수로 response값을 다시 가져와야 합니다.\n\n`modules/notes.js`\n\n```js\ncase GET_NOTES_SUCCESS:\n  return {\n    ...state,\n    notes: action.payload.notes.results\n  };\n```\n\nreducer의 GET_NOTES_SUCCESS 부분을 다음과 같이 바꿔줍니다. 이렇게 되면 오류가 나지 않고, 받아온 리스트들을 잘 보여주게 됩니다. \n\n저희는 다른 payload들은 사용하지 않습니다. 예를들면, count, next, previous같은 것들인데요, 단순히 보여주기만 한다면 위의 값들을 이용하여 무한스크롤링을 해도 상관이 없습니다만 저희는 중간에 삭제를 하거나 수정을 하기 때문에 마지막 아이템을 기준으로 다시 노트들을 가져옵니다. 따라서 딱히 이용할 이유가 없으므로, 일단 results값만 사용하겠습니다.\n\n자 이제는 다시 auth모듈로 돌아가서 로그인 정보를 유지하고 로그인 되지 않았다면, auth page로 보내는 기능을 추가하겠습니다. 전에 저희가 django에서 만든 checkUser 를 이용할 계획입니다.\n\n`modules/auth.js`\n\n```js\n...\nconst CHECK_USER = \"auth/CHECK_USER\";\nconst CHECK_USER_SUCCESS = \"auth/CHECK_USER_SUCCESS\";\nconst CHECK_USER_FAILURE = \"auth/CHECK_USER_FAILURE\";\n\nconst SET_USER_TEMP = \"auth/SET_USER_TEMP\";\n\n...\n\nexport const checkUser = () => ({\n  type: CHECK_USER\n});\n\nexport const checkUserSuccess = () => ({\n  type: CHECK_USER_SUCCESS\n});\n\nexport const checkUserFailure = error => ({\n  type: CHECK_USER_FAILURE,\n  payload: {\n    error\n  }\n});\n\nexport const setUserTemp = ({ id, username, token }) => ({\n  type: SET_USER_TEMP,\n  payload: {\n    id,\n    username,\n    token\n  }\n});\n\n...\n\nconst checkUserEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(CHECK_USER),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      const token = localStorage.getItem(\"userInfo\")\n        ? JSON.parse(localStorage.getItem(\"userInfo\")).token\n        : null;\n      return ajax\n        .get(`/api/auth/user/`, {\n          \"Content-Type\": \"application/json\",\n          Authorization: `token ${token}`\n        })\n        .pipe(\n          map(response => {\n            return checkUserSuccess();\n          }),\n          catchError(error =>\n            of({\n              type: CHECK_USER_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n\n...\ncase CHECK_USER_SUCCESS:\n  return {\n    ...state\n  };\ncase CHECK_USER_FAILURE:\n  return {\n    ...state,\n    logged: false,\n    userInfo: {\n      id: null,\n      username: \"\",\n      token: null\n    }\n  };\ncase SET_USER_TEMP:\n  return {\n    ...state,\n    logged: true,\n    userInfo: {\n      id: action.payload.id,\n      username: action.payload.username,\n      token: action.payload.token\n    }\n  };\n\nexport const authEpics = { registerEpic, loginEpic, checkUserEpic };\n\n\n```\n\n`modules.index.js`\n\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { auth, authEpics } from \"./auth\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes, auth });\nexport const rootEpics = combineEpics(\n  notesEpics.addNoteEpic,\n  notesEpics.getNotesEpic,\n  notesEpics.updateNoteEpic,\n  notesEpics.deleteNoteEpic,\n  authEpics.loginEpic,\n  authEpics.registerEpic,\n  authEpics.checkUserEpic\n);\n\n```\n\n위와같이 작성한후, 전역적으로 사용할 BaseContainer.js 를 만들어줍니다.\n\n`containers/BaseContainer.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport * as authActions from \"store/modules/auth\";\nimport { withRouter } from \"react-router-dom\";\n\nexport class BaseContainer extends Component {\n  componentDidMount() {\n    this.checkUser();\n  }\n\n  checkUser = () => {\n    const { checkUser, setUserTemp, history } = this.props;\n\n    // 먼저 localStorage에 값이 저장되있는지 확인, userInfo값이 있다면, 로그인을 한것으로 인식하고,\n    // 바로 setUserTemp를 실시.\n    // 이를 하는 이유는 새로고침 했을시, state가 초기화 되어 logged값도 false로 바뀌는데, 새로고침 했을시\n    // 로그인을 유지하기 위함.\n    if (localStorage.getItem(\"userInfo\")) {\n      const userInfo = JSON.parse(localStorage.getItem(\"userInfo\"));\n      setUserTemp({\n        id: userInfo.id,\n        username: userInfo.username,\n        token: userInfo.token\n      });\n      return;\n    }\n\n    // 만약 userInfo값이 localStorage에 없을때에는, api통신을 실시.\n    checkUser();\n\n    // 만약 checkUser가 실패 했다면, logged는 false로 바뀌므로, 로그인 페이지로 이동시킨다.\n    // 또한, /auth/register에서는 /auth/login으로 이동할 필요가 없으므로, auth라는 path가 url에 포함될때는 제외시킨다\n    if (!this.props.logged && !window.location.pathname.includes(\"auth\")) {\n      history.push(\"/auth/login\");\n    }\n  };\n\n  render() {\n    return <div />;\n  }\n}\n\nconst mapStateToProps = state => ({\n  logged: state.auth.logged\n});\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    checkUser: () => {\n      dispatch(authActions.checkUser());\n    },\n    setUserTemp: ({ id, username }) => {\n      dispatch(authActions.setUserTemp({ id, username }));\n    }\n  };\n};\n\nexport default withRouter(\n  connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(BaseContainer)\n);\n\n```\n\n그리고 이 BaseContainer를 App.js에 반영한다.\n\n`components/App.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { Switch, Route } from \"react-router-dom\";\nimport { Main, Auth, NotFound } from \"pages\";\nimport BaseContainer from \"containers/BaseContainer\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <Switch>\n          <Route path=\"/\" exact={true} component={Main} />\n          <Route path=\"/auth/:kind\" exact={true} component={Auth} />\n          <Route component={NotFound} />\n        </Switch>\n        <BaseContainer />\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n```\n이렇게 되면 로그인이 되었다면, 새로고침을 해도 로그인 상태가 유지됩니다.\n\n만약 로그인이 되어있지 않다면, /auth/login으로 이동하겠죠.\n\n그렇다면 이제 로그아웃 기능을 구현해볼까요?\n\n`modules/auth.js`\n\n```js\n...\n\nconst LOGOUT = \"auth/LOGOUT\";\nconst LOGOUT_SUCCESS = \"auth/LOGOUT_SUCCESS\";\nconst LOGOUT_FAILURE = \"auth/LOGOUT_FAILURE\";\n\n...\n\nexport const logout = () => ({\n  type: LOGOUT\n});\n\nexport const logoutSuccess = () => ({\n  type: LOGOUT_SUCCESS\n});\n\nexport const logoutFailure = () => ({\n  type: LOGOUT_FAILURE\n});\n\n\n....\n\nconst logoutEpic = (action$, state$) => {\n    return action$.pipe(\n      ofType(LOGOUT),\n      withLatestFrom(state$),\n      mergeMap(([action, state]) => {\n        const token = localStorage.getItem(\"userInfo\")\n          ? JSON.parse(localStorage.getItem(\"userInfo\")).token\n          : null;\n        return ajax\n          .post(\n            `/api/auth/logout/`,\n            // post의 body를 비워놓는다.\n            {},\n            {\n              \"Content-Type\": \"application/json\",\n              Authorization: `token ${token}`\n            }\n          )\n          .pipe(\n            map(response => {\n              // success시 localStorage에서 userInfo 삭제.\n              localStorage.removeItem(\"userInfo\");\n              return logoutSuccess();\n            }),\n            catchError(error => {\n              of({\n                type: LOGIN_FAILURE,\n                payload: error,\n                error: true\n              });\n            })\n          );\n      })\n    );\n  };\n\n....\n\ncase LOGOUT_SUCCESS:\n  return {\n    ...state,\n    logged: false,\n    userInfo: {\n      id: null,\n      message: \"\",\n      token: null\n    }\n  };\ncase LOGOUT_FAILURE:\n  return {\n    ...state,\n    error: {\n      triggered: true,\n      message: \"LOGOUT ERROR, PLEASE TRY AGAIN\"\n    }\n  };\n\n...\n\nexport const authEpics = { registerEpic, loginEpic, checkUserEpic, logoutEpic };\n```\n\n`modules/index.js`\n\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { auth, authEpics } from \"./auth\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes, auth });\nexport const rootEpics = combineEpics(\n  notesEpics.addNoteEpic,\n  notesEpics.getNotesEpic,\n  notesEpics.updateNoteEpic,\n  notesEpics.deleteNoteEpic,\n  authEpics.loginEpic,\n  authEpics.registerEpic,\n  authEpics.checkUserEpic,\n  authEpics.logoutEpic\n);\n```\n\n로그아웃 버튼을 눌러야 하기 때문에 HeaderContainer를 만들어줍니다.\n\n`containers/HeaderContainer.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport Header from \"components/structure/Header\";\nimport * as authActions from \"store/modules/auth\";\n\nexport class HeaderContainer extends Component {\n  handleLogout = () => {\n    const { logout } = this.props;\n    logout();\n  };\n  render() {\n    const { handleLogout } = this;\n    return <Header onLogout={handleLogout} />;\n  }\n}\n\nconst mapStateToProps = state => ({});\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    logout: () => {\n      dispatch(authActions.logout());\n    }\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(HeaderContainer);\n\n```\n\n그리고 components의 MainStructure에서 Header를 HeaderContainer로 변경해줍니다.\n\n`components/structure/MainStructure/MainStructure.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./MainStructure.scss\";\nimport classNames from \"classnames/bind\";\nimport HeaderContainer from \"containers/HeaderContainer\";\n\nconst cx = classNames.bind(styles);\n\nconst MainStructure = ({ children }) => (\n  <div>\n    <HeaderContainer />\n    <main>{children}</main>\n  </div>\n);\n\nexport default MainStructure;\n\n```\n이제 로그아웃버튼을 누르면 로그아웃 통신이 일어나게 되는데 페이지 변경이 안되죠? 다음과 같이 변경해줍니다.\n\n`containers/BaseContainer.js`\n\n```jsx\ncomponentDidUpdate(prevProps, prevState) {\n  if (prevProps.logged !== this.props.logged && !this.props.logged) {\n    window.location.href = \"/auth/login\";\n  }\n}\n```\n로그아웃 한채로 / 로 이동하면 다시 로그인 페이지로 돌아오게됩니다.\n(register페이지 제외)\n자 이제 로그아웃 기능까지 완료되었습니다! \n\n아 그리고 빼먹은 부분이 있는데, 이제는 모든 CRUD기능들에 Authorization Header를 붙여줘야 합니다. 안그러면 401 에러가 뜨게됩니다.\n\n`modules/notes.js`\n\n```js\nconst addNoteEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(ADD_NOTE),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      const token = localStorage.getItem(\"userInfo\")\n        ? JSON.parse(localStorage.getItem(\"userInfo\")).token\n        : null;\n      return ajax\n        .post(\n          `/api/notes/`,\n          { text: state.notes.noteInput },\n          {\n            \"Content-Type\": \"application/json\",\n            Authorization: `token ${token}`\n          }\n        )\n        .pipe(\n          map(response => {\n            const note = response.response;\n            return addNoteSuccess(note);\n          }),\n          catchError(error =>\n            of({\n              type: ADD_NOTE_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n\nconst deleteNoteEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(DELETE_NOTE),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      const token = localStorage.getItem(\"userInfo\")\n        ? JSON.parse(localStorage.getItem(\"userInfo\")).token\n        : null;\n      return ajax\n        .delete(`/api/notes/${action.payload.id}/`, {\n          \"Content-Type\": \"application/json\",\n          Authorization: `token ${token}`\n        })\n        .pipe(\n          map(response => {\n            return deleteNoteSuccess({ id: action.payload.id });\n          }),\n          catchError(error =>\n            of({\n              type: DELETE_NOTE_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n\nconst updateNoteEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(UPDATE_NOTE),\n    withLatestFrom(state$),\n\n    mergeMap(([action, state]) => {\n      const token = localStorage.getItem(\"userInfo\")\n        ? JSON.parse(localStorage.getItem(\"userInfo\")).token\n        : null;\n      return ajax\n        .patch(\n          `/api/notes/${state.notes.editing.id}/`,\n          {\n            text: state.notes.editing.text\n          },\n          {\n            \"Content-Type\": \"application/json\",\n            Authorization: `token ${token}`\n          }\n        )\n        .pipe(\n          map(response => {\n            const note = response.response;\n\n            return updateNoteSuccess({ note });\n          }),\n          catchError(error =>\n            of({\n              type: UPDATE_NOTE_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n```\n\n이렇게 되면 CRUD도 정상 작동합니다.\n\n\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 5 - 3. React - 로그인 유지 및 로그아웃 기능 구현.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-23T10:06:24.397Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 4 - 5. React - 노트 생성 시 에러 처리.":{"id":165,"title":"Dnote 4 - 5. React - 노트 생성 시 에러 처리.","content":"자 이제 생성은 되는데, 아무것도 없이 엔터만 치면 에러가 나겠죠?\n\n이 에러를 반영해주는 작업들을 해보겠습니다.\n\nredux의 initialState에 다음을 추가해줍니다.\n\n`modules/notes.js`\n\n```js\nconst initialState = {\n  noteInput: \"\",\n  notes: [],\n  // 에러 관련 state 등록.\n  error: {\n    triggered: false,\n    message: \"\"\n  }\n};\n```\n\n`containers/NoteContainer.js`\n\n```jsx\n...\n\nrender() {\n    const { noteInput, error } = this.props;\n    const { handleChange, addNote } = this;\n    return (\n      <div>\n        <NoteWrapper>\n          <InsertForm\n            noteInput={noteInput}\n            onChangeInput={handleChange}\n            onAdd={addNote}\n            error={error}\n          />\n        </NoteWrapper>\n      </div>\n    );\n  }\n\n...\n\nconst mapStateToProps = state => ({\n  noteInput: state.notes.noteInput,\n  notes: state.notes.notes,\n  error: state.notes.error\n});\n```\n`components/notes/InsertForm/InsertForm.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./InsertForm.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst InsertForm = ({ noteInput, onChangeInput, onAdd, error }) => {\n  const handleChange = e => {\n    const { value } = e.target;\n    onChangeInput({ value });\n  };\n\n  const handleKeyPress = e => {\n    if (e.key === \"Enter\") {\n      onAdd();\n    }\n  };\n\n  return (\n    <div className={cx(\"form\")}>\n      <div className={cx(\"title\")}>Insert Your Note Here...</div>\n      <div className={cx(\"error\")}>\n        {error.triggered && (\n          <div className={cx(\"message\")}>{error.message}</div>\n        )}\n      </div>\n      <input\n        type=\"text\"\n        name=\"note\"\n        value={noteInput}\n        onChange={handleChange}\n        onKeyPress={handleKeyPress}\n      />\n    </div>\n  );\n};\n\nexport default InsertForm;\n```\n\n이제 에러가 생기면 반영이 됩니다. 그러나 제대로 입력했을때도 남아있으니, 이부분을 고쳐보겠습니다.\n\n`store/modules/notes.js`\n\n```js\ncase ADD_NOTE_SUCCESS:\n      const { note } = action.payload;\n      return {\n        ...state,\n        notes: [note].concat(state.notes),\n        noteInput: \"\",\n        // 성공시 에러 초기화.\n        error: {\n          triggered: false,\n          message: \"\"\n        }\n      };\n```\n\n다음에는 생성된 노트들을 보여주는 처리를 해보겠습니다.\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 4 - 5. React - 노트 생성 시 에러 처리.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-21T14:12:54.092Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 4 - 3. React - 입력 폼 만들고 상태 관리.":{"id":166,"title":"Dnote 4 - 3. React - 입력 폼 만들고 상태 관리.","content":"`components/notes/InsertForm/InsertForm.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./InsertForm.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst InsertForm = () => {\n  return (\n    <div className={cx(\"form\")}>\n      <div className={cx(\"title\")}>Insert Your Note Here...</div>\n      <input type=\"text\" name=\"note\" />\n    </div>\n  );\n};\n\nexport default InsertForm;\n\n```\n\n`components/notes/InsertForm/InsertForm.scss`\n\n```css\n@import \"utils\";\n\n.form {\n  display: flex;\n  flex-direction: column;\n  margin-bottom: 1rem;\n  .title {\n    border-bottom: 1px solid $oc-gray-8;\n    padding-bottom: 0.75rem;\n\n    font-size: 1.25rem;\n    font-weight: 500;\n  }\n\n  input {\n    margin-top: 0.75rem;\n    height: 2.5rem;\n    border: 1px solid $oc-gray-5;\n    border-radius: 2px;\n\n    outline: none;\n\n    font-size: 1.5rem;\n    padding: 0.25rem;\n\n    background: $oc-gray-5;\n\n    color: white;\n    font-weight: 600;\n\n    flex: 1;\n  }\n}\n```\n\n`components/notes/InsertForm/InsertForm.js`\n\n```js\nexport { default } from './InsertForm';\n```\n\n\n이 InsertForm을 Main 페이지에 반영해보겠습니다.\n\n`pages/Main.js`\n\n```jsx\nimport React from \"react\";\nimport MainStructure from \"components/structure/MainStructure\";\nimport InsertForm from \"components/notes/InsertForm\";\n\nconst Main = () => {\n  return (\n    <MainStructure>\n      <InsertForm />\n    </MainStructure>\n  );\n};\n\nexport default Main;\n```\n\n이렇게 되면 너무 넓이가 넓어지므로, wrapper컴포넌트를 하나 만들어야합니다.\n\n`components/notes/NoteWrapper/NoteWrapper.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteWrapper.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteWrapper = ({ children }) => (\n  <div className={cx(\"wrapper\")}>{children}</div>\n);\n\nexport default NoteWrapper;\n```\n\n`components/notes/NoteWrapper/NoteWrapper.scss`\n\n```css\n@import \"utils\";\n\n.wrapper {\n  margin: 0 auto;\n\n  display: flex;\n  flex-direction: column;\n\n  width: 1024px;\n  @include media(\"<medium\") {\n    width: 95%;\n  }\n\n  padding-top: 1rem;\n  padding-bottom: 1rem;\n}\n```\n\n`components/notes/NoteWrapper/index.js`\n\n```js\nexport { default } from './NoteWrapper';\n```\n\n이제 이 wrapper로 InsertForm을 감싸줍니다.\n\n`pages/Main.js`\n\n```jsx\nimport React from \"react\";\nimport MainStructure from \"components/structure/MainStructure\";\nimport InsertForm from \"components/notes/InsertForm\";\nimport NoteWrapper from \"components/notes/NoteWrapper\";\n\nconst Main = () => {\n  return (\n    <MainStructure>\n      <NoteWrapper>\n        <InsertForm />\n      </NoteWrapper>\n    </MainStructure>\n  );\n};\n\nexport default Main;\n```\n\n위치가 나름 잡아졌죠?\n\n그렇다면 이제 이 입력폼을 가지고 실제로 redux를 사용하여 django와 통신하여 새 노트를 한번 만들어보겠습니다.\n\n일단 노트 input의 value 상태를 반영할 action과 리듀서를 생성해보겠습니다.\n\n`store/modules/notes.js`\n\n```js\nconst CHANGE_NOTE_INPUT = \"notes/CHANGE_NOTE_INPUT\";\n\nexport const changeNoteInput = ({ value }) => ({\n  type: CHANGE_NOTE_INPUT,\n  payload: { value }\n});\n\nconst initialState = {\n  noteInput: \"\"\n};\n\nexport const notes = (state = initialState, action) => {\n  switch (action.type) {\n    case CHANGE_NOTE_INPUT:\n      return {\n        ...state,\n        noteInput: action.payload.value\n      };\n\n    default:\n      return state;\n  }\n};\n```\n\n이제 이 모듈을 index에서 반영해줍니다.\n\n`store/modules/index.js`\n\n```js\n// 원래 있던 ping은 삭제해도 무방합니다.\nimport { notes } from \"./notes\";\nimport { combineReducers } from \"redux\";\n\nexport const rootReducers = combineReducers({ notes });\n```\n\n그럼 이제 이 모듈을 사용해서 input값을 관리해볼까요?\n\n일단 그러기 위해서 container를 하나 생성해주어야합니다.\n\n`containers/NoteContainer.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport InsertForm from \"components/notes/InsertForm\";\nimport NoteWrapper from \"components/notes/NoteWrapper\";\n\nimport * as noteActions from \"store/modules/notes\";\n\nexport class NoteContainer extends Component {\n  handleChange = ({ value }) => {\n    const { changeNoteInput } = this.props;\n    changeNoteInput({ value });\n  };\n\n  render() {\n    const { noteInput } = this.props;\n    const { handleChange } = this;\n    return (\n      <div>\n        <NoteWrapper>\n          <InsertForm noteInput={noteInput} onChangeInput={handleChange} />\n        </NoteWrapper>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  noteInput: state.notes.noteInput\n});\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    changeNoteInput: ({ value }) => {\n      dispatch(noteActions.changeNoteInput({ value }));\n    }\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(NoteContainer);\n```\n\n그런 뒤에 pages에서 이 컨테이너만 렌더해줍니다.\n\n`pages/Main.js`\n\n```jsx\nimport React from \"react\";\nimport MainStructure from \"components/structure/MainStructure\";\nimport NoteContainer from \"containers/NoteContainer\";\n\nconst Main = () => {\n  return (\n    <MainStructure>\n      <NoteContainer />\n    </MainStructure>\n  );\n};\n\nexport default Main;\n```\n\n이제 InsertForm 컴포넌트에서 마무리 작업을 해줍니다.\n\n`components/notes/InsertForm/InsertForm.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./InsertForm.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst InsertForm = ({ noteInput, onChangeInput }) => {\n  const handleChange = e => {\n    const { value } = e.target;\n    onChangeInput({ value });\n  };\n\n  return (\n    <div className={cx(\"form\")}>\n      <div className={cx(\"title\")}>Insert Your Note Here...</div>\n      <input\n        type=\"text\"\n        name=\"note\"\n        value={noteInput}\n        onChange={handleChange}\n      />\n    </div>\n  );\n};\n\nexport default InsertForm;\n```\n\n이제 리덕스 데브툴스로 보면 입력을 할때마다 값이 바뀌는것을 알수 있습니다.\n\n다음에는 이 값을 가지고 실제 노트를 하나 생성해보겠습니다.\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 4 - 3. React - 입력 폼 만들고 상태 관리.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-21T14:11:43.275Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 4 - 4. React - 노트 생성 기능 구현.":{"id":167,"title":"Dnote 4 - 4. React - 노트 생성 기능 구현.","content":"`store/modules/notes.js`\n\n```js\nimport { ajax } from \"rxjs/observable/dom/ajax\";\nimport { of } from \"rxjs\";\nimport { map, mergeMap, catchError, withLatestFrom } from \"rxjs/operators\";\nimport { ofType } from \"redux-observable\";\n\nconst CHANGE_NOTE_INPUT = \"notes/CHANGE_NOTE_INPUT\";\n\nconst ADD_NOTE = \"notes/ADD_NOTE\";\nconst ADD_NOTE_SUCCESS = \"notes/ADD_NOTE_SUCCESS\";\nconst ADD_NOTE_FAILURE = \"notes/ADD_NOTE_FAILURE\";\n\nexport const changeNoteInput = ({ value }) => ({\n  type: CHANGE_NOTE_INPUT,\n  payload: { value }\n});\n\nexport const addNote = () => ({\n  type: ADD_NOTE\n});\nexport const addNoteSuccess = note => ({\n  type: ADD_NOTE_SUCCESS,\n  payload: {\n    note\n  }\n});\nexport const addNoteFailure = error => ({\n  type: ADD_NOTE_FAILURE,\n  payload: {\n    error\n  }\n});\n\nconst addNoteEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(ADD_NOTE),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      return ajax.post(`/api/notes/`, { text: state.notes.noteInput }).pipe(\n        map(response => {\n          const note = response.response;\n          return addNoteSuccess(note);\n        }),\n        catchError(error =>\n          of({\n            type: ADD_NOTE_FAILURE,\n            payload: error,\n            error: true\n          })\n        )\n      );\n    })\n  );\n};\n\nconst initialState = {\n  noteInput: \"\",\n  notes: []\n};\n\nexport const notes = (state = initialState, action) => {\n  switch (action.type) {\n    case CHANGE_NOTE_INPUT:\n      return {\n        ...state,\n        noteInput: action.payload.value\n      };\n    case ADD_NOTE_SUCCESS:\n      const { note } = action.payload;\n      return {\n        ...state,\n        notes: [note].concat(state.notes),\n        noteInput: \"\"\n      };\n    case ADD_NOTE_FAILURE:\n      return {\n        ...state,\n        error: {\n          triggered: true,\n          message: \"Error! Please Try With Unempty Note\"\n        }\n      };\n    default:\n      return state;\n  }\n};\n\nexport const notesEpics = {\n  addNoteEpic\n};\n```\n\n위와 같이 note를 추가하는 epic과 액션, 리듀서들을 생성해주세요.\n\n그리고, index.js에서 epic을 반영해주세요.\n\n`modules/index.js`\n\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes });\nexport const rootEpics = combineEpics(notesEpics.addNoteEpic);\n\n```\n\n처음으로 epic이 나왔는데요, 이 epic은 configure에서 다음과 같이 등록해주어야 사용할수 있습니다.\n\n`store/configure.js`\n\n```js\nimport { createStore, applyMiddleware, compose } from \"redux\";\nimport { createEpicMiddleware } from \"redux-observable\";\n\nimport { rootReducers, rootEpics } from \"./modules\";\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\nconst epicMiddleware = createEpicMiddleware();\n\nexport default createStore(\n  rootReducers,\n  composeEnhancers(applyMiddleware(epicMiddleware))\n);\n\nepicMiddleware.run(rootEpics);\n```\n\n이제 container로 다시 돌아와서 다음 작업들을 해줘야합니다.\n\n`containers/NoteContainer.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport InsertForm from \"components/notes/InsertForm\";\nimport NoteWrapper from \"components/notes/NoteWrapper\";\n\nimport * as noteActions from \"store/modules/notes\";\n\nexport class NoteContainer extends Component {\n  handleChange = ({ value }) => {\n    const { changeNoteInput } = this.props;\n    changeNoteInput({ value });\n  };\n\n  addNote = () => {\n    const { addNote } = this.props;\n    addNote();\n  };\n\n  render() {\n    const { noteInput } = this.props;\n    const { handleChange, addNote } = this;\n    return (\n      <div>\n        <NoteWrapper>\n          <InsertForm\n            noteInput={noteInput}\n            onChangeInput={handleChange}\n            onAdd={addNote}\n          />\n        </NoteWrapper>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  noteInput: state.notes.noteInput,\n  notes: state.notes.notes\n});\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    changeNoteInput: ({ value }) => {\n      dispatch(noteActions.changeNoteInput({ value }));\n    },\n    addNote: () => {\n      dispatch(noteActions.addNote());\n    }\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(NoteContainer);\n```\n\n`components/notes/InsertForm/InsertForm.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./InsertForm.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst InsertForm = ({ noteInput, onChangeInput, onAdd }) => {\n  const handleChange = e => {\n    const { value } = e.target;\n    onChangeInput({ value });\n  };\n\n  const handleKeyPress = e => {\n    if (e.key === \"Enter\") {\n      onAdd();\n    }\n  };\n\n  return (\n    <div className={cx(\"form\")}>\n      <div className={cx(\"title\")}>Insert Your Note Here...</div>\n      <input\n        type=\"text\"\n        name=\"note\"\n        value={noteInput}\n        onChange={handleChange}\n        onKeyPress={handleKeyPress}\n      />\n    </div>\n  );\n};\n\nexport default InsertForm;\n\n```\n\n근데 이상태로는 오류가 납니다, 이유는 proxy설정을 안했기 때문인데요, package.json에서 프록시 설정을 해줍니다.\n\n`package.json`\n\n```js\n\"proxy\": \"http://localhost:8000\"\n```\n\n자 이제 엔터를 치면 노트가 생성됨을 알수 있습니다.\n\n크롬 개발자도구를 키고, network에서 보시면 201 생성이 뜨죠?\n\n![Imgur](https://i.imgur.com/zeTJmsp.png)\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 4 - 4. React - 노트 생성 기능 구현.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-21T14:12:10.363Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 5 - 2. React - 로그인 및 회원가입 기능 구현.":{"id":168,"title":"Dnote 5 - 2. React - 로그인 및 회원가입 기능 구현.","content":"Django API를 바탕으로, 리액트에서 로그인 및 회원가입 기능을 구현해보겠습니다.\n\n이제 첫 화면에서는 오류가 나겠죠? 401 Unauthorized가 나옵니다.\n권한 설정을 했는데, 저희는 Header에 Authorization을 주지 않아서 그런건데요, 일단 이 오류는 무시하고 로그인 회원가입 기능을 구현하겠습니다.\n\n다음 파일들을 생성해줍니다.\n\n`components/auth/AuthForm/AuthForm.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./AuthForm.scss\";\nimport classNames from \"classnames/bind\";\nimport { Link } from \"react-router-dom\";\n\nconst cx = classNames.bind(styles);\n\nconst AuthForm = ({ kind }) => {\n  return (\n    <div className={cx(\"auth-form\")}>\n      <div className={cx(\"title\")}>{kind.toUpperCase()}</div>\n      <div className={cx(\"line-wrapper\")}>\n        <div className={cx(\"input-title\")}>username</div>\n        <input type=\"text\" name=\"username\" />\n      </div>\n      <div className={cx(\"line-wrapper\")}>\n        <div className={cx(\"input-title\")}>password</div>\n        <input type=\"password\" name=\"password\" />\n      </div>\n      <div className={cx(\"auth-button\")}>{kind.toUpperCase()}</div>\n      {kind === \"register\" ? (\n        <Link to={`/auth/login`} className={cx(\"description\")}>\n          if you already have account...\n        </Link>\n      ) : (\n        <Link to={`/auth/register`} className={cx(\"description\")}>\n          if you don't have an account...\n        </Link>\n      )}\n    </div>\n  );\n};\n\nexport default AuthForm;\n\n```\n\n\n`components/auth/AuthForm/AuthForm.scss`\n\n```css\n@import \"utils\";\n\n.auth-form {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n\n  border: 3px solid $oc-gray-6;\n  border-radius: 3px;\n  width: 512px;\n\n  @include media(\"<medium\") {\n    width: 100%;\n    border: none;\n    top: 0%;\n    transform: translate(-50%, 0%);\n  }\n\n  padding: 1rem;\n  .title {\n    text-align: center;\n\n    font-size: 2rem;\n    font-weight: 700;\n    user-select: none;\n    padding-top: 1rem;\n    padding-bottom: 1rem;\n  }\n\n  .error {\n    display: flex;\n    justify-content: center;\n    .message {\n      font-size: 1.25rem;\n      font-weight: 500;\n      color: $oc-red-7;\n    }\n  }\n\n  .line-wrapper {\n    display: flex;\n    flex-direction: column;\n\n    .input-title {\n      font-size: 1.6rem;\n      font-weight: 600;\n      margin-bottom: 1rem;\n    }\n\n    input {\n      height: 3rem;\n      outline: none;\n      border: 1px solid $oc-gray-6;\n      border-radius: 2px;\n      font-size: 1.5rem;\n      padding: 0.5rem;\n\n      font-weight: 600;\n    }\n  }\n\n  .line-wrapper + .line-wrapper {\n    margin-top: 1.5rem;\n  }\n\n  .auth-button {\n    // height: 3rem;\n    background: $oc-violet-7;\n\n    margin-top: 2rem;\n    border: 1px solid $oc-violet-7;\n    border-radius: 2px;\n    padding-top: 0.5rem;\n    padding-bottom: 0.5rem;\n    padding-left: 0.25rem;\n    padding-right: 0.25rem;\n\n    text-align: center;\n\n    color: white;\n    font-weight: 600;\n    font-size: 1.5rem;\n\n    cursor: pointer;\n    user-select: none;\n\n    &:hover {\n      background: $oc-violet-8;\n    }\n\n    &:active {\n      background: $oc-violet-7;\n    }\n  }\n\n  .description {\n    padding-top: 1rem;\n    padding-bottom: 0.5rem;\n\n    display: flex;\n    flex-direction: row-reverse;\n\n    font-size: 1.2rem;\n    color: $oc-blue-7;\n\n    @include media(\"<medium\") {\n      justify-content: center;\n    }\n  }\n}\n\n```\n`components/auth/AuthForm/index.js`\n\n```js\nexport { default } from './AuthForm';\n```\n\n그리고 pages의 Auth를 손봐야합니다.\n\n`pages/Auth.js`\n\n```jsx\nimport React from \"react\";\nimport AuthForm from \"components/auth/AuthForm\";\n\nconst Auth = ({ match }) => {\n  // App.js /:kind로 설정해둔 값입니다.\n  const { kind } = match.params;\n  return (\n    <div>\n      <AuthForm kind={kind} />\n    </div>\n  );\n};\n\nexport default Auth;\n\n```\n\n이제 redux의 auth module을 생성해볼까요?\n\n일단 다음 액션들만 처리해주겠습니다.\n\n`modules/auth.js`\n\n```js\nconst INITIALIZE_INPUT = \"auth/INITIALIZE_INPUT\";\n\nconst CHANGE_INPUT = \"auth/CHANGE_INPUT\";\n\nexport const initializeInput = () => ({\n  type: INITIALIZE_INPUT\n});\n\nexport const changeInput = ({ name, value }) => ({\n  type: CHANGE_INPUT,\n  payload: {\n    name,\n    value\n  }\n});\n\nconst initialState = {\n  form: {\n    username: \"\",\n    password: \"\"\n  }\n};\n\nexport const auth = (state = initialState, action) => {\n  switch (action.type) {\n    case INITIALIZE_INPUT:\n      return {\n        ...state,\n        form: {\n          username: \"\",\n          password: \"\"\n        }\n      };\n    case CHANGE_INPUT:\n      let newForm = state.form;\n      newForm[action.payload.name] = action.payload.value;\n      return {\n        ...state,\n        form: newForm\n      };\n\n    default:\n      return state;\n  }\n};\n\n```\n\n`modules/index.js`\n\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { auth } from \"./auth\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes, auth });\nexport const rootEpics = combineEpics(\n  notesEpics.addNoteEpic,\n  notesEpics.getNotesEpic,\n  notesEpics.updateNoteEpic,\n  notesEpics.deleteNoteEpic\n);\n\n```\n\n`containers/AuthContainer.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport AuthForm from \"components/auth/AuthForm\";\nimport { withRouter } from \"react-router-dom\";\nimport * as authActions from \"store/modules/auth\";\n\nexport class AuthContainer extends Component {\n  componentDidMount() {\n    const { initializeInput } = this.props;\n    initializeInput();\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const { initializeInput } = this.props;\n\n    if (prevProps.kind !== this.props.kind) {\n      initializeInput();\n    }\n  }\n\n  handleChangeInput = ({ name, value }) => {\n    const { changeInput } = this.props;\n    changeInput({ name, value });\n  };\n  render() {\n    const { kind, username, password } = this.props;\n    const { handleChangeInput } = this;\n    return (\n      <AuthForm\n        kind={kind}\n        username={username}\n        password={password}\n        onChangeInput={handleChangeInput}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  username: state.auth.form.username,\n  password: state.auth.form.password\n});\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    initializeInput: () => {\n      dispatch(authActions.initializeInput());\n    },\n    changeInput: ({ name, value }) => {\n      dispatch(authActions.changeInput({ name, value }));\n    }\n  };\n};\n\nexport default withRouter(\n  connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(AuthContainer)\n);\n\n```\n\n`pages/Auth.js`\n\n```jsx\nimport React from \"react\";\nimport AuthContainer from \"containers/AuthContainer\";\n\nconst Auth = ({ match }) => {\n  const { kind } = match.params;\n  return (\n    <div>\n      <AuthContainer kind={kind} />\n    </div>\n  );\n};\n\nexport default Auth;\n\n```\n\n`components/auth/AuthForm/AuthForm.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./AuthForm.scss\";\nimport classNames from \"classnames/bind\";\nimport { Link } from \"react-router-dom\";\n\nconst cx = classNames.bind(styles);\n\nconst AuthForm = ({ kind, onChangeInput, username, password }) => {\n  const handleChange = e => {\n    const { name, value } = e.target;\n    onChangeInput({ name, value });\n  };\n  return (\n    <div className={cx(\"auth-form\")}>\n      <div className={cx(\"title\")}>{kind.toUpperCase()}</div>\n      <div className={cx(\"line-wrapper\")}>\n        <div className={cx(\"input-title\")}>username</div>\n        <input\n          type=\"text\"\n          name=\"username\"\n          value={username}\n          onChange={handleChange}\n        />\n      </div>\n      <div className={cx(\"line-wrapper\")}>\n        <div className={cx(\"input-title\")}>password</div>\n        <input\n          type=\"password\"\n          name=\"password\"\n          value={password}\n          onChange={handleChange}\n        />\n      </div>\n      <div className={cx(\"auth-button\")}>{kind.toUpperCase()}</div>\n      {kind === \"register\" ? (\n        <Link to={`/auth/login`} className={cx(\"description\")}>\n          if you already have account...\n        </Link>\n      ) : (\n        <Link to={`/auth/register`} className={cx(\"description\")}>\n          if you don't have an account...\n        </Link>\n      )}\n    </div>\n  );\n};\n\nexport default AuthForm;\n\n```\n\n이렇게 까지하면, 폼인풋들을 상태관리 할수 있고, 레지스터와 로그인 페이지간 이동할때, 모든 인풋밸류가 초기화 됩니다.\n\n그렇다면 이제 API통신을 통해 login 과 register기능을 구현해보겠습니다.\n\n그리고 그에따른 에러처리를 해보도록 하죠.\n\n`modules/auth.js`\n\n```js\n....\n\nconst REGISTER = \"auth/REGISTER\";\nconst REGISTER_SUCCESS = \"auth/REGISTER_SUCCESS\";\nconst REGISTER_FAILURE = \"auth/REGISTER_FAILURE\";\n\nconst LOGIN = \"auth/LOGIN\";\nconst LOGIN_SUCCESS = \"auth/LOGIN_SUCCESS\";\nconst LOGIN_FAILURE = \"auth/LOGIN_FAILURE\";\n\nconst INITIALIZE_ERROR = \"auth/INITIALIZE_ERROR\";\n...\n\nexport const register = () => ({\n  type: REGISTER\n});\n\nexport const registerSuccess = ({ user, token }) => ({\n  type: REGISTER_SUCCESS,\n  payload: {\n    user,\n    token\n  }\n});\n\nexport const registerFailure = error => ({\n  type: REGISTER_FAILURE,\n  payload: {\n    error\n  }\n});\n\nexport const login = () => ({\n  type: LOGIN\n});\n\nexport const loginSuccess = ({ user, token }) => ({\n  type: LOGIN_SUCCESS,\n  payload: {\n    user,\n    token\n  }\n});\n\nexport const loginFailure = error => ({\n  type: LOGIN_FAILURE,\n  payload: {\n    error\n  }\n});\n\n\nexport const initializeError = () => ({\n  type: INITIALIZE_ERROR\n});\n\n...\n\nconst registerEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(REGISTER),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      const { username, password } = state.auth.form;\n      return ajax.post(`/api/auth/register/`, { username, password }).pipe(\n        map(response => {\n          const { user, token } = response.response;\n          return registerSuccess({ user, token });\n        }),\n        catchError(error =>\n          of({\n            type: REGISTER_FAILURE,\n            payload: error,\n            error: true\n          })\n        )\n      );\n    })\n  );\n};\n\nconst loginEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(LOGIN),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      const { username, password } = state.auth.form;\n      return ajax.post(`/api/auth/login/`, { username, password }).pipe(\n        map(response => {\n          const { user, token } = response.response;\n          return loginSuccess({ user, token });\n        }),\n        catchError(error =>\n          of({\n            type: LOGIN_FAILURE,\n            payload: error,\n            error: true\n          })\n        )\n      );\n    })\n  );\n};\n\n...\nconst initialState = {\n  form: {\n    username: \"\",\n    password: \"\"\n  },\n  error: {\n    triggered: false,\n    message: \"\"\n  },\n  logged: false,\n  userInfo: {\n    id: null,\n    username: \"\",\n    token: null\n  }\n};\n\nexport const auth = (state = initialState, action) => {\n  switch (action.type) {\n    case INITIALIZE_INPUT:\n      return {\n        ...state,\n        form: {\n          username: \"\",\n          password: \"\"\n        }\n      };\n    case CHANGE_INPUT:\n      let newForm = state.form;\n      newForm[action.payload.name] = action.payload.value;\n      return {\n        ...state,\n        form: newForm\n      };\n    case INITIALIZE_ERROR:\n      return {\n        ...state,\n        error: {\n          triggered: false,\n          message: \"\"\n        }\n      };\n    case REGISTER_SUCCESS:\n      return {\n        ...state,\n        logged: true,\n        userInfo: {\n          id: action.payload.user.id,\n          username: action.payload.user.username,\n          token: action.payload.token\n        }\n      };\n    case REGISTER_FAILURE:\n      switch (action.payload.status) {\n        case 400:\n          return {\n            ...state,\n            error: {\n              triggered: true,\n              message: \"WRONG USERNAME OR PASSWORD\"\n            }\n          };\n        case 500:\n          return {\n            ...state,\n            error: {\n              triggered: true,\n              message: \"TOO SHORT USERNAME OR PASSWORD\"\n            }\n          };\n        default:\n          return {\n            ...state\n          };\n      }\n    case LOGIN_SUCCESS:\n      return {\n        ...state,\n        logged: true,\n        userInfo: {\n          id: action.payload.user.id,\n          username: action.payload.user.username,\n          token: action.payload.token\n        }\n      };\n    case LOGIN_FAILURE:\n      switch (action.payload.status) {\n        case 400:\n          return {\n            ...state,\n            error: {\n              triggered: true,\n              message: \"WRONG USERNAME OR PASSWORD\"\n            }\n          };\n        case 500:\n          return {\n            ...state,\n            error: {\n              triggered: true,\n              message: \"PLEASE TRY AGAIN\"\n            }\n          };\n        default:\n          return {\n            ...state\n          };\n      }\n\n    default:\n      return state;\n  }\n};\n\n\n```\n\n`modules/index.js`\n\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { auth, authEpics } from \"./auth\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes, auth });\nexport const rootEpics = combineEpics(\n  notesEpics.addNoteEpic,\n  notesEpics.getNotesEpic,\n  notesEpics.updateNoteEpic,\n  notesEpics.deleteNoteEpic,\n  authEpics.loginEpic,\n  authEpics.registerEpic\n);\n\n```\n\n`containers/AuthContainer.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport AuthForm from \"components/auth/AuthForm\";\nimport { withRouter } from \"react-router-dom\";\nimport * as authActions from \"store/modules/auth\";\n\nexport class AuthContainer extends Component {\n  componentDidMount() {\n    this.initialize();\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.kind !== this.props.kind) {\n      this.initialize();\n    }\n  }\n\n  initialize = () => {\n    const { initializeInput, initializeError } = this.props;\n    initializeError();\n    initializeInput();\n  };\n\n  handleChangeInput = ({ name, value }) => {\n    const { changeInput } = this.props;\n    changeInput({ name, value });\n  };\n\n  handleLogin = () => {\n    const { login } = this.props;\n    login();\n  };\n\n  handleRegister = () => {\n    const { register } = this.props;\n    register();\n  };\n  render() {\n    const { kind, username, password, error } = this.props;\n    const { handleChangeInput, handleLogin, handleRegister } = this;\n    return (\n      <AuthForm\n        kind={kind}\n        username={username}\n        password={password}\n        onChangeInput={handleChangeInput}\n        onLogin={handleLogin}\n        onRegister={handleRegister}\n        error={error}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  username: state.auth.form.username,\n  password: state.auth.form.password,\n  userInfo: state.auth.userInfo,\n  logged: state.auth.logged,\n  error: state.auth.error\n});\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    initializeInput: () => {\n      dispatch(authActions.initializeInput());\n    },\n    changeInput: ({ name, value }) => {\n      dispatch(authActions.changeInput({ name, value }));\n    },\n    initializeError: () => {\n      dispatch(authActions.initializeError());\n    },\n    register: () => {\n      dispatch(authActions.register());\n    },\n    login: () => {\n      dispatch(authActions.login());\n    }\n  };\n};\n\nexport default withRouter(\n  connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(AuthContainer)\n);\n\n\n```\n\n`components/auth/AuthForm/AuthForm.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./AuthForm.scss\";\nimport classNames from \"classnames/bind\";\nimport { Link } from \"react-router-dom\";\n\nconst cx = classNames.bind(styles);\n\nconst AuthForm = ({\n  kind,\n  onChangeInput,\n  username,\n  password,\n  onLogin,\n  onRegister,\n  error\n}) => {\n  const handleChange = e => {\n    const { name, value } = e.target;\n    onChangeInput({ name, value });\n  };\n\n  const handleKeyPress = e => {\n    if (e.key === \"Enter\") {\n      switch (kind) {\n        case \"register\":\n          onRegister();\n          return;\n        case \"login\":\n          onLogin();\n          return;\n        default:\n          return;\n      }\n    }\n  };\n  return (\n    <div className={cx(\"auth-form\")}>\n      <div className={cx(\"title\")}>{kind.toUpperCase()}</div>\n      <div className={cx(\"error\")}>\n        {error.triggered && (\n          <div className={cx(\"message\")}>{error.message}</div>\n        )}\n      </div>\n      <div className={cx(\"line-wrapper\")}>\n        <div className={cx(\"input-title\")}>username</div>\n        <input\n          type=\"text\"\n          name=\"username\"\n          value={username}\n          onChange={handleChange}\n          onKeyPress={handleKeyPress}\n        />\n      </div>\n      <div className={cx(\"line-wrapper\")}>\n        <div className={cx(\"input-title\")}>password</div>\n        <input\n          type=\"password\"\n          name=\"password\"\n          value={password}\n          onChange={handleChange}\n          onKeyPress={handleKeyPress}\n        />\n      </div>\n      {kind === \"register\" ? (\n        <div className={cx(\"auth-button\")} onClick={onRegister}>\n          {kind.toUpperCase()}\n        </div>\n      ) : (\n        <div className={cx(\"auth-button\")} onClick={onLogin}>\n          {kind.toUpperCase()}\n        </div>\n      )}\n      {kind === \"register\" ? (\n        <Link to={`/auth/login`} className={cx(\"description\")}>\n          if you already have account...\n        </Link>\n      ) : (\n        <Link to={`/auth/register`} className={cx(\"description\")}>\n          if you don't have an account...\n        </Link>\n      )}\n    </div>\n  );\n};\n\nexport default AuthForm;\n\n\n```\n\n\n이렇게 되면 API 통신이 완료됩니다. 그에따른 오류처리도 됩니다.\n\n다음 에서는 로그인을 유지하고, 로그인이 되지 않았을때에는, 로그인 페이지로 보내고, 로그아웃 기능을 구현해보겠습니다.\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 5 - 2. React - 로그인 및 회원가입 기능 구현.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-23T10:05:49.815Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 3 - 3. React - 개발 환경 설정 및 구조 잡기. (Redux 설정하기)":{"id":169,"title":"Dnote 3 - 3. React - 개발 환경 설정 및 구조 잡기. (Redux 설정하기)","content":"기본적인 스타일과 구조를 잡았으니, 이제 리덕스를 설정해야겠습니다.\n\n리덕스는 글로벌하게 상태관리를 할수있게 도와주는 도구라고 생각하는데요, 딱히 복잡하지 않은 프로젝트에서는 굳이 리덕스를 사용하지 않아도 된다고 생각합니다. 허나 저는 API통신을 할 것이고, 평소에 리덕스를 사용해왔기 때문에, 리덕스 스토어에서 전체 상태를 관리할 예정입니다.\n\n또한 이 튜토리얼의 리덕스는 redux-observable을 사용합니다. rxjs의 개념이 도입된 라이브러리 인데요, rxjs의 개념을 가지고 계신 분들이라면 충분히 따라오실수 있고, 만약 아니라도, API통신에만 rxjs가 사용되므로, 각자 궁금하신 부분들은 https://redux-observable.js.org/ 이 페이지에서 학습하셔도 금방 따라오실수 있을거라고 생각합니다.\n\n자 그럼 이제부터 리덕스 설정을 해보겠습니다.\n\nstore폴더 밑에 modules 폴더를 생성해주세요.\n\n그리고 일단 redux-devtools로 띄워봐야 하니, 간단하게 modules 밑에 ping.js라는 파일을 생성해서 스테이트를 생성해보겠습니다.\n\n그전에 리덕스 설정에 필요한 라이브러리들을 다운로드 해줘야합니다.\n\n```bash\n$ yarn add redux react-redux redux-observable rxjs rxjs-compat\n```\n\n`store/modules/ping.js`\n\n```js\nconst PING = \"PING\";\n\nconst initialState = {\n  ping: \"ping\"\n};\n\nexport const ping = (state = initialState, action) => {\n  switch (action.type) {\n    case PING:\n      return {\n        ping: \"pong\"\n      };\n    default:\n      return state;\n  }\n};\n\n```\n\n그리고 modules밑에 index.js를 생성해주세요. 다음과 같이 작성해줍니다.\n\n`modules/index.js`\n\n```js\nimport { ping } from \"./ping\";\nimport { combineReducers } from \"redux\";\n\nexport const rootReducers = combineReducers({ ping });\n\n```\n\n다음으로 store밑에 configure.js 를 생성해주세요.\n\n`store/configure.js`\n\n```js\nimport { createStore, applyMiddleware, compose } from \"redux\";\nimport { createEpicMiddleware } from \"redux-observable\";\n\nimport { rootReducers } from \"./modules\";\n\n// 크롬 데브 툴스 설정입니다.\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\nconst epicMiddleware = createEpicMiddleware();\n\nexport default createStore(\n  rootReducers,\n  composeEnhancers(applyMiddleware(epicMiddleware))\n);\n\n```\n\n그리고 Root.js에서 다음과 같이 코딩해줍니다.\n\n`Root.js`\n\n```jsx\nimport React from \"react\";\nimport App from \"components/App\";\nimport { Provider } from \"react-redux\";\nimport store from \"store/configure\";\n\nconst Root = () => {\n  return (\n    <Provider store={store}>\n      <App />\n    </Provider>\n  );\n};\nexport default Root;\n```\n\n크롬 devtools에서 표식이 뜨면서 개발자 도구를 눌러서 보면 다음과 같이 뜨나요?? * 혹시 크롬 데브툴스가 없다면, redux-devtools로 검색하셔서 웹스토어 추가 해주시면 됩니다. *\n\n![Imgur](https://i.imgur.com/EbTU21N.png)\n\n기본적인 리덕스 설정이 끝났습니다!\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 3 - 3. React - 개발 환경 설정 및 구조 잡기. (Redux 설정하기)","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-21T05:28:59.139Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 4 - 2. React - 페이지 구조 생성.":{"id":170,"title":"Dnote 4 - 2. React - 페이지 구조 생성.","content":"지난 튜토리얼에서 만든 API를 바탕으로 통신하여, 리액트에서 CRUD를 실시해보겠습니다.\n\n일단 처음에 react-router-dom을 사용하여 클라이언트쪽 라우팅을 해보겠습니다.\n\n```bash\n$ yarn add react-router-dom\n```\n\n`Root.js`\n\n```jsx\nimport React from \"react\";\nimport App from \"components/App\";\nimport { Provider } from \"react-redux\";\nimport store from \"store/configure\";\nimport { BrowserRouter } from \"react-router-dom\";\n\nconst Root = () => {\n  return (\n    <Provider store={store}>\n      <BrowserRouter>\n        <App />\n      </BrowserRouter>\n    </Provider>\n  );\n};\n\nexport default Root;\n\n```\n\n\nRoot.js를 다음과 같이 BrowserRouter로 감싸줍니다.\n\n그런 뒤 라우팅에 쓰이게 될 pages들을 생성하겠습니다.\n\npages밑에 다음과 같은 파일들을 생성해주세요.\n\n`Main.js`: 노트들이 리스트되어 나타날 페이지\n\n```jsx\nimport React from \"react\";\n\nconst Main = () => {\n  return <div>Main Page</div>;\n};\n\nexport default Main;\n\n```\n\n`Auth.js`: 로그인 / 회원가입 페이지\n\n```jsx\nimport React from \"react\";\n\nconst Auth = () => {\n  return <div>Auth Page</div>;\n};\n\nexport default Auth;\n\n```\n\n`NotFound.js`: 라우팅 되지 않은 곳에서 나타날 페이지\n\n```jsx\nimport React from \"react\";\n\nconst NotFound = () => {\n  return <div>NotFound Page</div>;\n};\n\nexport default NotFound;\n\n```\n\n그런뒤 이 페이지들을 한곳에 모아줄 index.js를 생성합니다.\n\n`pages/index.js`\n\n```js\nexport { default as Main } from \"./Main\";\nexport { default as Auth } from \"./Auth\";\nexport { default as NotFound } from \"./NotFound\";\n```\n\nApp.js에서 페이지들을 라우팅 해줍니다.\n\n`App.js`\n\n```jsx\nimport React, { Component } from \"react\";\nimport { Switch, Route } from \"react-router-dom\";\nimport { Main, Auth, NotFound } from \"pages\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <Switch>\n          <Route path=\"/\" exact={true} component={Main} />\n          <Route path=\"/auth/:kind\" exact={true} component={Auth} />\n          <Route component={NotFound} />\n        </Switch>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n라우팅이 끝났으면, 이제 다음과 같은 주소들이 작동할것입니다.\n\nhttp://localhost:3000/ -> Main\nhttp://localhost:3000/auth/login -> Auth\nhttp://localhost:3000/auth/register -> Auth\nhttp://localhost:3000/alskjdalskdj -> NotFound\n\n그럼 이제 라우팅은 되었으니, 실제 UI들을 조금씩 만들어보겠습니다.\n\n메인 스트럭쳐를 뜻하는 structure 폴더를 components 밑에 생성해줍니다.\n\n그 뒤 Header를 만들어주겠습니다.\n\n![Imgur](https://i.imgur.com/qVw6aCd.png)\n\n다음과 같은 구조를 가집니다! \n아 그리고 로그아웃 버튼을 만들기 위해 react-icons를 인스톨 해줍니다.\n 또한, color제공 라이브러리인 open-color와 미디어 쿼리를 좀더 자유롭게 사용하게 해주는 include-media도 다운로드 해주겠습니다. \n classnames는 여러개의 클래스를 한번에 사용하게도 하고, scss와 bind하여 굳이 styles라는 이름을 사용하지 않아도 되게하는 라이브러리 입니다.\n\n```bash\n$ yarn add react-icons open-color include-media classnames\n```\n\n그리고 이 라이브러리들을 모든 scss에서 적용할수 있게 해보겠습니다.\n\n`styles/utils.scss`\n\n```css\n@import \"~open-color/open-color\";\n@import \"~include-media/dist/include-media\";\n\n$breakpoints: (\n  small: 320px,\n  medium: 768px,\n  large: 1024px,\n  wide: 1400px\n);\n\n```\n앞으로 모든 scss파일에서 임포트 하게될 utils.scss를 생성했습니다.\n\n\n\n`Header.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./Header.scss\";\nimport classNames from \"classnames/bind\";\nimport { Link } from \"react-router-dom\";\nimport { MdLock } from \"react-icons/md\";\n\nconst cx = classNames.bind(styles);\n\nconst Header = ({ onLogout }) => (\n  <div className={cx(\"header\")}>\n    <Link to={\"/\"} className={cx(\"logo\")}>\n      D-Note\n    </Link>\n    <div className={cx(\"logout\")}>\n      <MdLock onClick={onLogout} />\n    </div>\n  </div>\n);\n\nexport default Header;\n```\n\n`Header.scss`\n\n```css\n@import \"utils\";\n\n.header {\n  background: $oc-violet-6;\n  height: 5rem;\n\n  display: flex;\n  align-items: center;\n\n  .logo {\n    color: white;\n\n    font-weight: 800;\n    font-size: 1.5rem;\n\n    cursor: pointer;\n\n    margin-left: 1rem;\n\n    user-select: none;\n  }\n\n  .logout {\n    margin-left: auto;\n    margin-right: 1rem;\n    color: white;\n\n    font-weight: 800;\n    font-size: 2rem;\n\n    cursor: pointer;\n  }\n}\n```\n\n`index.js`\n\n```js\nexport { default } from './Header';\n```\n\n그럼 이제 이 헤더를 반영시켜볼까요?\n\n`pages/Main.js`\n\n```jsx\nimport React from \"react\";\nimport Header from \"components/structure/Header\";\n\nconst Main = () => {\n  return <Header />;\n};\n\nexport default Main;\n```\n\n잘 나타나나요?\n\n근데 이런식으로 매 페이지에서 Header를 import 하는건 비효율 적이므로, 페이지 구조를 만들어주는 컴포넌트를 하나 생성하겠습니다.\n\n`components/structure/MainStructure.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./MainStructure.scss\";\nimport classNames from \"classnames/bind\";\nimport Header from \"components/structure/Header\";\n\nconst cx = classNames.bind(styles);\n\nconst MainStructure = ({ children }) => (\n  <div>\n    <Header />\n    <main>{children}</main>\n  </div>\n);\n\nexport default MainStructure;\n```\n\n`components/structure/index.js`\n\n```jsx\nexport { default } from './MainStructure';\n```\n\n그리고 이 MainStructure를 Main 페이지에 반영해줍니다.\n\n`pages/Main.js`\n\n```jsx\nimport React from \"react\";\nimport MainStructure from \"components/structure/MainStructure\";\n\nconst Main = () => {\n  return <MainStructure>Main Page</MainStructure>;\n};\n\nexport default Main;\n```\n\n다음에는 노트를 입력하는 노트 입력 폼을 만들어보겠습니다.\n\n\n\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 4 - 2. React - 페이지 구조 생성.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-21T14:10:25.372Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 4 - 1. Django - CRUD API 작업":{"id":171,"title":"Dnote 4 - 1. Django - CRUD API 작업","content":"이제 웹통신을 할 장고 API를 설정해보겠습니다.\n\ndjango쪽 디렉터리에서 앱을 하나 생성해줍니다.\n\n```bash\n$ (venv) python manage.py startapp notes\n```\n\n`settings.py`\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # notes 앱 추가\n    'notes',\n]\n```\n\n일단, REST Framework를 사용할 것이기 때문에 먼저 인스톨부터 하죠.\n\n```bash\n$ (venv) pip install djangorestframework\n```\n\n그런뒤 마찬가지로 INSTALLED_APPS 에 추가합니다.\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # notes 앱 추가\n    'notes',\n    # rest framework 추가\n    'rest_framework',\n]\n```\n\n저희가 notes 앱 에서 쓸 파일들은 다음과 같습니다.\n\n`urls.py`: API 라우팅\n\n`models.py`: 모델\n\n`serializers.py`: 모델을 참조하여 serializing\n\n`views.py`: 실제 일을 하는 곳. serializer 참조.\n\n일단 models.py 에서 모델을 생성해야합니다.\n\n`notes/models.py`\n\n```python\nfrom django.db import models\n\nclass Notes(models.Model):\n    text = models.CharField(max_length=255)\n    created_at = models.DateTimeField(auto_now=False, auto_now_add=True)\n\n    def __str__(self):\n        return self.text\n\n```\n\n한줄 노트가 들어갈 text필드와 만들어진 날짜를 구분하는 created_at필드를 가진 Notes모델을 생성했습니다.\n\n항상 모델을 등록한후에는 migration을 해주어야 합니다.\n\n```bash\n$ (venv) python manage.py makemigrations\n$ (venv) python manage.py migrate\n```\n\nserializer를 생성하겠습니다.\n\n`notes/serializers.py`\n\n```python\nfrom rest_framework import serializers\nfrom .models import Notes\n\n\nclass NoteSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Notes\n        fields = (\"id\", \"text\")\n```\n\n다음과 같이 Note 모델을 시리얼라이징 해주는 시리얼라이저를 생성했습니다.\n\n그리고 views.py에서 ViewSet을 하나 만든 후 urls.py에서 라우팅 해주겠습니다.\n\n`notes/views.py`\n\n```python\nfrom rest_framework import viewsets\nfrom .serializers import NoteSerializer\nfrom .models import Notes\n\n\nclass NoteViewSet(viewsets.ModelViewSet):\n    serializer_class = NoteSerializer\n\n    def get_queryset(self):\n        return Notes.objects.all().order_by(\"-created_at\")\n\n    def perform_create(self, serializer):\n        serializer.save()\n```\n\n`notes/urls.py`\n\n```python\nfrom django.conf.urls import url\nfrom .views import NoteViewSet\n\nnote_list = NoteViewSet.as_view({\"get\": \"list\", \"post\": \"create\"})\n\nnote_detail = NoteViewSet.as_view(\n    {\"get\": \"retrieve\", \"patch\": \"partial_update\", \"delete\": \"destroy\"}\n)\n\n\nurlpatterns = [\n    url(\"^notes/$\", note_list, name=\"note-list\"),\n    url(\"^notes/(?P<pk>[0-9]+)/$\", note_detail, name=\"note-detail\"),\n]\n```\n\n그 다음 root앱의 urls.py에서 notes의 urls.py를 반영해줍니다.\n\n`urls.py`\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\n\nfrom notes import urls\nfrom django.conf.urls import include, url\n\nurlpatterns = [\n\tpath(\"admin/\", admin.site.urls), \n    url(r\"^api/\", include(urls))\n]\n```\n\n이제 다음의 url들이 통신이 될것입니다.\n\nhttp://localhost:8000/api/notes/ (GET - Note List)\nhttp://localhost:8000/api/notes/ (POST - Create Note)\nhttp://localhost:8000/api/notes/{id}/ (GET - Get Single Note by id)\nhttp://localhost:8000/api/notes/{id}/ (PATCH - update partial)\nhttp://localhost:8000/api/notes/{id}/ (DELETE - destroy a single note by id)\n\n\n일단 권한 설정을 하지 않았습니다. \n지금까지 만들어놓은 API를 가지고 react에서 반영해보겠습니다.\n\n\n\n\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 4 - 1. Django - CRUD API 작업","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-21T12:44:28.410Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 3 - 2. React - 개발 환경 설정 및 구조 잡기.(프로젝트 구조잡기)":{"id":172,"title":"Dnote 3 - 2. React - 개발 환경 설정 및 구조 잡기.(프로젝트 구조잡기)","content":"자 redux설정에 앞서 잠시 기본 적인 sass 스타일의 틀을 잡고 가보겠습니다.\n\n`styles/index.scss`\n\n```css\n@import url(\"//fonts.googleapis.com/css?family=Do+Hyeon:400\");\n\nbody {\n  margin: 0;\n  box-sizing: border-box;\n  font-family: \"Do Hyeon\", sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n* {\n  box-sizing: inherit;\n}\n\na {\n  text-decoration: inherit;\n  color: inherit;\n}\n\n```\n\n설명을 드리자면 도현체를 사용하기 위해서 도현체를 import시키고, 전체적인 body태그의 스타일을 해준것입니다. \n또한 a 태그로 링크를 걸때, 자동적으로 나오는 못생긴 스타일들을 없애주었습니다.\n\n이제 index.js에 이 스타일을 불러와야 하는데, 불러오기 전에 경로를 비교하여 불러오기 귀찮으므로, .env파일을 생성하여 NODE_PATH를 src로 정해줍니다.\n\n이렇게 하면 src를 기준으로 불러올수 있습니다.\n\n`src/.env`\n\n```js\nNODE_PATH=src\n```\n\n그런 뒤 앱을 한번 다시 실행시켜주세요.\n\n이제 index.js로 돌아와서 스타일을 임포트한후 확인해보겠습니다.\n\n`src/index.js`\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n// 기존에 있던 App을 지웠습니다.\nimport \"styles/index.scss\";\nimport registerServiceWorker from \"./registerServiceWorker\";\n\nReactDOM.render(<div>도현체</div>, document.getElementById(\"root\"));\nregisterServiceWorker();\n\n```\n\n도현체가 나타나서 잘뜨나요?\n\n그렇다면 성공입니다. 이제는 기본적인 개발 구조를 잡아보겠습니다.\n\n일단 원래 있던 파일들을 조금 삭제할 건데요, 다음 파일들을 일단 삭제하겠습니다.\n\n`src/App.css`\n`src/App.test.js`\n`src/index.css`\n`src/logo.svg`\n\n그리고 src 밑에 다음과 같은 폴더들을 생성해줍니다.\n\n`containers`: 리액트 컨테이너 파일들 집합\n`components`: 리액트 컴포넌트 파일들 집합\n`pages`: Routing에서 사용될 page 파일들 집합\n`store`: redux모듈들과 configure파일들 집합\n\n그리고 원래 있던 App.js를 components로 옮겨주고, src밑에 나중에 리덕스 스토어를 반영할 Root.js를 생성해줍니다.\n\nApp.js는 다음과 같이 코드를 비워줍니다.\n\n`components/App.js`\n\n```jsx\nimport React, { Component } from \"react\";\n\nclass App extends Component {\n  render() {\n    return <div>App.js</div>;\n  }\n}\n\nexport default App;\n\n```\n\n`src/Root.js`\n\n```jsx\nimport React from \"react\";\nimport App from \"components/App\";\n\nconst Root = () => {\n  return <App />;\n};\n\nexport default Root;\n\n```\n\n\n\n그리고 이 Root.js를 index에서 렌더시켜줍니다.\n\n`src/index.js`\n\n```jsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Root from \"./Root\";\nimport \"styles/index.scss\";\nimport registerServiceWorker from \"./registerServiceWorker\";\n\nReactDOM.render(<Root />, document.getElementById(\"root\"));\nregisterServiceWorker();\n```\n\n잘 나타나나요? 그렇다면 성공입니다.\n\n다음에서는 redux설정을 통해서 redux-devtools (크롬 웹스토어) 로 반영해보겠습니다.\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 3 - 2. React - 개발 환경 설정 및 구조 잡기.(프로젝트 구조잡기)","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-21T05:09:31.610Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 4 - 6. React - 노트 리스트 구현 및 수정 / 삭제 기능 구현.":{"id":173,"title":"Dnote 4 - 6. React - 노트 리스트 구현 및 수정 / 삭제 기능 구현.","content":"이제 할것은 노트 리스트 보여주기인데, Django API의 notes 앱의 url 중 \n\n```python\nurl(\"^notes/$\", note_list, name=\"note-list\")\n```\n을 참조하여 가져올것이다.\n\n일단 우리는 권한 설정을 하지 않았으므로, 모든 노트들을 가져올수 있다.\n\npostman으로 위 url에 접근해보자.\n\n```js\n[\n    {\n        \"id\": 5,\n        \"text\": \"에러?\"\n    },\n    {\n        \"id\": 4,\n        \"text\": \"제대로 입력?\"\n    },\n    {\n        \"id\": 3,\n        \"text\": \"에러가 아니다!\"\n    },\n    {\n        \"id\": 2,\n        \"text\": \"노트를 생성했다!\"\n    }\n]\n```\n\n입력된 리스트들을 받아올수 있다.\n\n이것을 우리는 React에서 보여줄것이다.\n\n일단 redux 처리부터 해보자.\n\n`store/modules/notes.js`\n\n```js\n...\n\nconst GET_NOTES = \"notes/GET_NOTES\";\nconst GET_NOTES_SUCCESS = \"notes/GET_NOTES_SUCCESS\";\nconst GET_NOTES_FAILURE = \"notes/GET_NOTES_FAILURE\";\n// 액션들을 추가해주고,\n\n... \n\nexport const getNotes = () => ({\n  type: GET_NOTES\n});\nexport const getNotesSuccess = ({notes}) => ({\n  type: GET_NOTES_SUCCESS,\n  payload: {\n    notes\n  }\n});\nexport const getNotesFailure = error => ({\n  type: GET_NOTES_FAILURE,\n  payload: {\n    error\n  }\n});\n\n// 그에 따른 함수들을 정의한다.\n\n...\n\nconst getNotesEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(GET_NOTES),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      return ajax\n        .get(`/api/notes/`)\n        .pipe(\n          map(response => {\n            const notes = response.response;\n            return getNotesSuccess({notes});\n          }),\n          catchError(error =>\n            of({\n              type: GET_NOTES_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n\n// api 통신에 쓰일 epic도 정의한다.\n\n...\n\ncase GET_NOTES_SUCCESS:\n    return {\n      ...state,\n      notes: action.payload.notes\n    };\ncase GET_NOTES_FAILURE:\n  return {\n    ...state,\n    error: {\n      triggered: true,\n      message: \"Error! Please Try Again!\"\n    }\n  };\n\n...\n\nexport const notesEpics = {\n  addNoteEpic,\n  getNotesEpic\n};\n\n// 마지막으로  reducer를 손보고, epic에 추가해준다.\n```\n\n`modules/index.js`\n\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes });\nexport const rootEpics = combineEpics(notesEpics.addNoteEpic, notesEpics.getNotesEpic);\n// getNotesEpic 등록한다.\n```\n\n이렇게 되면 리덕스 작업은 끝이났고, 이제 UI에서 렌더링해줄 작업이 남아있다.\n\n`containers/NoteContainer.js`\n\n```jsx\n\tcomponentDidMount() {\n      this.getNotes();\n    }\n\n    getNotes = () => {\n      const { getNotes } = this.props;\n      getNotes();\n    };\n\n...\n\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    changeNoteInput: ({ value }) => {\n      dispatch(noteActions.changeNoteInput({ value }));\n    },\n    addNote: () => {\n      dispatch(noteActions.addNote());\n    },\n    // 추가\n    getNotes: () => {\n      dispatch(noteActions.getNotes())\n    }\n  };\n};\n```\n\n이렇게 componentDidMount에서 노트를 불러오면 redux 상태가 다음과 같아진다!\n\n![Imgur](https://i.imgur.com/OUW6JFc.png)\n\n이제 통신은 완료 되었고, UI를 생성해보자.\n\ncomponents에 NoteList와 NoteItem을 추가해준다.\n\n`components/notes/NoteItem/NoteItem.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteItem.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteItem = ({ note }) => {\n  return (\n    <div className={cx(\"note-item\")}>\n      <div className={cx(\"note\")}>{note.text}</div>\n      <div className={cx(\"delete\")}>&times;</div>\n    </div>\n  );\n};\n\nexport default NoteItem;\n```\n`components/notes/NoteItem/NoteItem.scss`\n\n```css\n@import \"utils\";\n\n.note-item {\n  display: flex;\n  align-items: center;\n  height: 3rem;\n  background: $oc-gray-5;\n\n  padding-left: 1rem;\n  padding-right: 1rem;\n\n  cursor: pointer;\n\n  .note {\n    color: white;\n\n    font-weight: 600;\n    font-size: 1.25rem;\n  }\n\n  .delete {\n    margin-left: auto;\n    cursor: pointer;\n\n    color: white;\n    font-weight: 800;\n    font-size: 2rem;\n\n    user-select: none;\n  }\n  .return {\n    display: flex;\n    align-items: center;\n    margin-left: auto;\n    cursor: pointer;\n\n    color: white;\n    font-weight: 800;\n    font-size: 1.5rem;\n  }\n\n  input {\n    height: 100%;\n    width: 100%;\n\n    outline: none;\n    background: $oc-gray-6;\n    border: 1px solid $oc-gray-6;\n\n    font-size: 1.5rem;\n    color: white;\n    font-weight: 600;\n  }\n}\n\n.editing {\n  background: $oc-gray-6;\n}\n\n```\n\n\n`components/notes/NoteList/NoteList.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteList.scss\";\nimport classNames from \"classnames/bind\";\nimport NoteItem from \"components/notes/NoteItem\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteList = ({ notes }) => {\n  const noteList = notes.map((note, i) => {\n    return <NoteItem note={note} key={note.id} />;\n  });\n  return (\n    <div className={cx(\"note-list\")}>\n      <div className={cx(\"title\")}>Your Notes...</div>\n      {noteList}\n    </div>\n  );\n};\n\nexport default NoteList;\n\n```\n`components/notes/NoteList/NoteList.scss`\n\n```css\n@import \"utils\";\n\n.note-list {\n  .title {\n    border-bottom: 1px solid $oc-gray-5;\n    padding-bottom: 0.75rem;\n\n    font-size: 1.25rem;\n    font-weight: 500;\n\n    margin-bottom: 1rem;\n  }\n\n  .note-item + .note-item {\n    margin-top: 1rem;\n  }\n}\n\n```\n\n마지막으로 NoteContainer에서 NoteList를 불러오고, notes를 props로 전달해준다.\n\n`containers/NoteContainer.js`\n```jsx\n...\nimport NoteList from \"../components/notes/NoteList/NoteList\";\n...\n\n\nrender() {\n  const { noteInput, error, notes } = this.props;\n  const { handleChange, addNote } = this;\n  return (\n    <div>\n      <NoteWrapper>\n        <InsertForm\n          noteInput={noteInput}\n          onChangeInput={handleChange}\n          onAdd={addNote}\n          error={error}\n        />\n        <NoteList notes={notes} />\n      </NoteWrapper>\n    </div>\n  );\n}\n...\n```\n\n이렇게 되면 작성된 노트의 리스트를 모두 보여줬다.\n\n리스트를 모두 보여줬으니, 그에 따른 기능들을 구현해볼까??\n\n일단 수정하는 기능을 추가해보자. 수정은 노트아이템을 클릭하면 수정할수 있게 만들것이고, 되돌아 가려면 다시한번 토글하면 되는 식이다.\n\nredux로 돌아가서 수정 기능을 추가해보자.\n\n`modules/notes.js`\n\n```js\nconst TOGGLE_NOTE = \"notes/TOGGLE_NOTE\";\n// 노트를 수정하기위해 토글하는 액션 추가\n\n...\n\nexport const toggleNote = ({ id, text }) => ({\n  type: TOGGLE_NOTE,\n  payload: {\n    id,\n    text\n  }\n});\n\n// 토글 함수 추가\n\n...\n\n\nconst initialState = {\n  noteInput: \"\",\n  notes: [],\n  error: {\n    triggered: false,\n    message: \"\"\n  },\n  // 수정하는 노트아이템을 표시하는 state 추가.\n  editing: {\n    id: null,\n    text: \"\"\n  }\n};\n\n\n...\n\n// 토글 리듀서 추가\ncase TOGGLE_NOTE:\n    return {\n      ...state,\n      editing: {\n        id: parseInt(action.payload.id, 10),\n        note: action.payload.text\n      }\n    };\n...\n```\n\n이렇게 되면 토글시, editing 에 토글된 노트의 id와 text값이 저장된다.\n\n`containers/NoteContainer.js`\n\n```jsx\n\n...\n\t// 토글하는 함수 추가\n    handleToggle = ({ id, text }) => {\n      const { toggleNote, editing } = this.props;\n  \t// 이미 에디팅 중이면 한번 더 토글시 초기화\n      if (editing.id === id) {\n        toggleNote({ id: null, text: \"\" });\n      } else {\n        // 아니면 에디팅 표시.\n        toggleNote({ id, text });\n      }\n    };\n\n\trender() {\n      const { noteInput, error, notes, editing } = this.props;\n      const { handleChange, addNote, handleToggle } = this;\n      return (\n        <div>\n          <NoteWrapper>\n            <InsertForm\n              noteInput={noteInput}\n              onChangeInput={handleChange}\n              onAdd={addNote}\n              error={error}\n            />\n            <NoteList \n              notes={notes} \n              editing={editing} \n              onToggle={handleToggle} />\n          </NoteWrapper>\n        </div>\n      );\n    }\n\n....\n\nconst mapStateToProps = state => ({\n  noteInput: state.notes.noteInput,\n  notes: state.notes.notes,\n  error: state.notes.error,\n  // editing state 추가\n  editing: state.notes.editing\n});\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    changeNoteInput: ({ value }) => {\n      dispatch(noteActions.changeNoteInput({ value }));\n    },\n    addNote: () => {\n      dispatch(noteActions.addNote());\n    },\n    getNotes: () => {\n      dispatch(noteActions.getNotes());\n    },\n    // toggle 함수 추가\n    toggleNote: ({ id, text }) => {\n      dispatch(noteActions.toggleNote({ id, text }));\n    }\n  };\n};\n....\n```\n\n`components/notes/NoteList/NoteList.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteList.scss\";\nimport classNames from \"classnames/bind\";\nimport NoteItem from \"components/notes/NoteItem\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteList = ({ notes, editing, onToggle }) => {\n  const noteList = notes.map((note, i) => {\n    return <NoteItem \n             note={note} \n             key={note.id} \n             editing={editing}\n             onToggle={onToggle} />;\n  });\n  return (\n    <div className={cx(\"note-list\")}>\n      <div className={cx(\"title\")}>Your Notes...</div>\n      {noteList}\n    </div>\n  );\n};\n\nexport default NoteList;\n\n```\n\n`components/notes/NoteItem/NoteItem.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteItem.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteItem = ({ note, editing, onToggle }) => {\n  const handleToggle = () => {\n    onToggle({ id: note.id, text: note.text });\n  };\n  return (\n    <div\n      className={cx(\"note-item\", editing.id === note.id && \"editing\")}\n      onClick={handleToggle}\n    >\n      <div className={cx(\"note\")}>{note.text}</div>\n      <div className={cx(\"delete\")}>&times;</div>\n    </div>\n  );\n};\n\nexport default NoteItem;\n\n```\n\n여기까지하면 토글시 다음과 같이 나타날 것이다.\n\n![Imgur](https://i.imgur.com/4O11xvW.png)\n\n단, 여기서 input에서는 value값만 주고 onChange함수를 작성하지 않아서 오류가 뜰텐데, 이것을 고쳐보자.\n\n일단 다시 redux로 돌아가서 changeNoteInput부분을 바꾸어 주어야 한다.\n\n`modules/notes.js`\n\n```js\n...\nexport const changeNoteInput = ({ value }, isEditing) => ({\n  type: CHANGE_NOTE_INPUT,\n  payload: { value, isEditing }\n});\n..\n\n// reducer부분 \n\ncase CHANGE_NOTE_INPUT:\n  if (action.payload.isEditing) {\n    return {\n      ...state,\n      editing: {\n        ...state.editing,\n        text: action.payload.value\n      }\n    };\n  }\n  return {\n    ...state,\n    noteInput: action.payload.value\n  };\n```\n\n`containers/NoteContainer.js`\n\n```jsx\n  handleChange = ({ value }, isEditing) => {\n    const { changeNoteInput } = this.props;\n    changeNoteInput({ value }, isEditing);\n  };\n\n\t\n  render() {\n      const { noteInput, error, notes, editing } = this.props;\n      const { handleChange, addNote, handleToggle } = this;\n      return (\n        <div>\n          <NoteWrapper>\n            <InsertForm\n              noteInput={noteInput}\n              onChangeInput={handleChange}\n              onAdd={addNote}\n              error={error}\n            />\n            <NoteList\n              notes={notes}\n              editing={editing}\n              onToggle={handleToggle}\n              onChange={handleChange}\n            />\n          </NoteWrapper>\n        </div>\n      );\n    }\n\t// NoteList props에 onChange 추가\n\n...\n\nconst mapDispatchToProps = dispatch => {\n  return {\n   \t// 변경\n    changeNoteInput: ({ value }, isEditing) => {\n      dispatch(noteActions.changeNoteInput({ value }, isEditing));\n    },\n    addNote: () => {\n      dispatch(noteActions.addNote());\n    },\n    getNotes: () => {\n      dispatch(noteActions.getNotes());\n    },\n    toggleNote: ({ id, text }) => {\n      dispatch(noteActions.toggleNote({ id, text }));\n    }\n  };\n};\n\n```\n\n`components/notes/NoteList.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteList.scss\";\nimport classNames from \"classnames/bind\";\nimport NoteItem from \"components/notes/NoteItem\";\n\nconst cx = classNames.bind(styles);\n// onChange 추가 및 NoteItem props 전달\nconst NoteList = ({ notes, editing, onToggle, onChange }) => {\n  const noteList = notes.map((note, i) => {\n    return (\n      <NoteItem\n        note={note}\n        key={note.id}\n        editing={editing}\n        onToggle={onToggle}\n        onChange={onChange}\n      />\n    );\n  });\n  return (\n    <div className={cx(\"note-list\")}>\n      <div className={cx(\"title\")}>Your Notes...</div>\n      {noteList}\n    </div>\n  );\n};\n\nexport default NoteList;\n\n```\n\n`components/notes/NoteItem.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteItem.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteItem = ({ note, editing, onToggle, onChange }) => {\n  const handleToggle = () => {\n    onToggle({ id: note.id, text: note.text });\n  };\n\n  // change함수 추가 및 input 태그 value값과 onChange 추가.\n  const handleChange = e => {\n    const { value } = e.target;\n    onChange({ value }, true);\n  };\n  return (\n    <div\n      className={cx(\"note-item\", editing.id === note.id && \"editing\")}\n      onClick={handleToggle}\n    >\n      {editing.id === note.id ? (\n        <input\n          type=\"text\"\n          name=\"note\"\n          value={editing.text}\n          autoFocus\n          onChange={handleChange}\n        />\n      ) : (\n        <div className={cx(\"note\")}>{note.text}</div>\n      )}\n      <div className={cx(\"delete\")}>&times;</div>\n    </div>\n  );\n};\n\nexport default NoteItem;\n\n```\n\n이렇게 되면 토글을 할때에도, 전혀 문제가 되지 않고 수정시에도 수정한 글자들이 모두 상태에 반영됩니다.\n\n그럼 이제, 실제로 수정 기능을 구현해볼까요?\n\n\n`modules/notes.js`\n\n```js\nconst UPDATE_NOTE = \"notes/UPDATE_NOTE\";\nconst UPDATE_NOTE_SUCCESS = \"notes/UPDATE_NOTE_SUCCESS\";\nconst UPDATE_NOTE_FAILURE = \"notes/UPDATE_NOTE_FAILURE\";\n\n...\n\n\nexport const updateNote = () => ({\n  type: UPDATE_NOTE\n});\nexport const updateNoteSuccess = ({ note }) => ({\n  type: UPDATE_NOTE_SUCCESS,\n  payload: {\n    note\n  }\n});\nexport const updateNoteFailure = error => ({\n  type: UPDATE_NOTE_FAILURE,\n  payload: {\n    error\n  }\n});\n\n...\n\nconst updateNoteEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(UPDATE_NOTE),\n    withLatestFrom(state$),\n\n    mergeMap(([action, state]) => {\n      return ajax\n        .patch(`/api/notes/${state.notes.editing.id}/`, {\n          text: state.notes.editing.text\n        })\n        .pipe(\n          map(response => {\n            const note = response.response;\n            return updateNoteSuccess({ note });\n          }),\n          catchError(error =>\n            of({\n              type: UPDATE_NOTE_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n\n...\n\ncase UPDATE_NOTE_SUCCESS:\n  const { id, text } = action.payload.note;\n  let notes = state.notes;\n  let index = notes.findIndex((note, i) => {\n    return note.id === id;\n  });\n  notes[parseInt(index, 10)] = {\n    id,\n    text\n  };\n  return {\n    ...state,\n    editing: {\n      id: null,\n      note: \"\"\n    },\n    notes\n  };\n\nexport const notesEpics = {\n  addNoteEpic,\n  getNotesEpic,\n  updateNoteEpic\n};\n\n\n```\n\n`modules/index.js`\n\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes });\nexport const rootEpics = combineEpics(\n  notesEpics.addNoteEpic,\n  notesEpics.getNotesEpic,\n  notesEpics.updateNoteEpic\n);\n\n```\n\n`containers/NoteContainer.js`\n\n```jsx\n....\n  updateNote = () => {\n    const { updateNote } = this.props;\n    updateNote();\n  };\n\n\n....\nrender() {\n    const { noteInput, error, notes, editing } = this.props;\n    const { handleChange, addNote, handleToggle, updateNote } = this;\n    return (\n      <div>\n        <NoteWrapper>\n          <InsertForm\n            noteInput={noteInput}\n            onChangeInput={handleChange}\n            onAdd={addNote}\n            error={error}\n          />\n          <NoteList\n            notes={notes}\n            editing={editing}\n            onToggle={handleToggle}\n            onChange={handleChange}\n            onUpdate={updateNote}\n          />\n        </NoteWrapper>\n      </div>\n    );\n  }\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    changeNoteInput: ({ value }, isEditing) => {\n      dispatch(noteActions.changeNoteInput({ value }, isEditing));\n    },\n    addNote: () => {\n      dispatch(noteActions.addNote());\n    },\n    getNotes: () => {\n      dispatch(noteActions.getNotes());\n    },\n    toggleNote: ({ id, text }) => {\n      dispatch(noteActions.toggleNote({ id, text }));\n    },\n    updateNote: () => {\n      dispatch(noteActions.updateNote());\n    }\n  };\n};\n\n\n```\n\n`components/notes/NoteList/NoteList.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteList.scss\";\nimport classNames from \"classnames/bind\";\nimport NoteItem from \"components/notes/NoteItem\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteList = ({ notes, editing, onToggle, onChange, onUpdate }) => {\n  const noteList = notes.map((note, i) => {\n    return (\n      <NoteItem\n        note={note}\n        key={note.id}\n        editing={editing}\n        onToggle={onToggle}\n        onChange={onChange}\n        onUpdate={onUpdate}\n      />\n    );\n  });\n  return (\n    <div className={cx(\"note-list\")}>\n      <div className={cx(\"title\")}>Your Notes...</div>\n      {noteList}\n    </div>\n  );\n};\n\nexport default NoteList;\n\n```\n`components/notes/NoteItem/NoteItem.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteItem.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteItem = ({ note, editing, onToggle, onChange, onUpdate }) => {\n  const handleToggle = () => {\n    onToggle({ id: note.id, text: note.text });\n  };\n\n  const handleChange = e => {\n    const { value } = e.target;\n    onChange({ value }, true);\n  };\n\n  const handleKeyPress = e => {\n    if (e.key === \"Enter\") {\n      onUpdate();\n    }\n  };\n  return (\n    <div\n      className={cx(\"note-item\", editing.id === note.id && \"editing\")}\n      onClick={handleToggle}\n    >\n      {editing.id === note.id ? (\n        <input\n          type=\"text\"\n          name=\"note\"\n          value={editing.text}\n          autoFocus\n          onChange={handleChange}\n          onKeyPress={handleKeyPress}\n        />\n      ) : (\n        <div className={cx(\"note\")}>{note.text}</div>\n      )}\n      <div className={cx(\"delete\")}>&times;</div>\n    </div>\n  );\n};\n\nexport default NoteItem;\n\n```\n\n\n자 이렇게 되면 노트 수정까지 완료되었습니다.\n\n이제 삭제를 해볼까요?\n\n`modules/notes.js`\n\n\n```js\n...\nconst DELETE_NOTE = \"notes/DELETE_NOTE\";\nconst DELETE_NOTE_SUCCESS = \"notes/DELETE_NOTE_SUCCESS\";\nconst DELETE_NOTE_FAILURE = \"notes/DELETE_NOTE_FAILURE\";\n...\n\nexport const deleteNote = ({ id }) => ({\n  type: DELETE_NOTE,\n  payload: {\n    id\n  }\n});\nexport const deleteNoteSuccess = ({ id }) => ({\n  type: DELETE_NOTE_SUCCESS,\n  payload: {\n    id\n  }\n});\nexport const deleteNoteFailure = error => ({\n  type: DELETE_NOTE_FAILURE,\n  payload: {\n    error\n  }\n});\n\n\n...\n\nconst deleteNoteEpic = (action$, state$) => {\n  return action$.pipe(\n    ofType(DELETE_NOTE),\n    withLatestFrom(state$),\n    mergeMap(([action, state]) => {\n      const token = localStorage.getItem(\"userInfo\")\n        ? JSON.parse(localStorage.getItem(\"userInfo\")).token\n        : null;\n      return ajax\n        .delete(`/api/notes/${action.payload.id}/`, {\n          \"Content-Type\": \"application/json\",\n          Authorization: `token ${token}`\n        })\n        .pipe(\n          map(response => {\n            return deleteNoteSuccess({ id: action.payload.id });\n          }),\n          catchError(error =>\n            of({\n              type: DELETE_NOTE_FAILURE,\n              payload: error,\n              error: true\n            })\n          )\n        );\n    })\n  );\n};\n...\n\ncase DELETE_NOTE_SUCCESS:\n  return {\n    ...state,\n    notes: state.notes.filter(note => note.id !== action.payload.id)\n  };\n\n...\n\n\nexport const notesEpics = {\n  addNoteEpic,\n  getNotesEpic,\n  updateNoteEpic,\n  deleteNoteEpic\n};\n\n```\n\n`modules/index.js`\n```js\nimport { notes, notesEpics } from \"./notes\";\nimport { combineReducers } from \"redux\";\nimport { combineEpics } from \"redux-observable\";\n\nexport const rootReducers = combineReducers({ notes });\nexport const rootEpics = combineEpics(\n  notesEpics.addNoteEpic,\n  notesEpics.getNotesEpic,\n  notesEpics.updateNoteEpic,\n  notesEpics.deleteNoteEpic\n);\n\n```\n\n`containers/NoteContainer.js`\n\n```jsx\n...\n  deleteNote = ({ id }) => {\n    const { deleteNote } = this.props;\n    deleteNote({ id });\n  };\n\n...\n\nrender() {\n    const { noteInput, error, notes, editing } = this.props;\n    const {\n      handleChange,\n      addNote,\n      handleToggle,\n      updateNote,\n      deleteNote\n    } = this;\n    return (\n      <div>\n        <NoteWrapper>\n          <InsertForm\n            noteInput={noteInput}\n            onChangeInput={handleChange}\n            onAdd={addNote}\n            error={error}\n          />\n          <NoteList\n            notes={notes}\n            editing={editing}\n            onToggle={handleToggle}\n            onChange={handleChange}\n            onUpdate={updateNote}\n            onDelete={deleteNote}\n          />\n        </NoteWrapper>\n      </div>\n    );\n  }\n\n...\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    changeNoteInput: ({ value }, isEditing) => {\n      dispatch(noteActions.changeNoteInput({ value }, isEditing));\n    },\n    addNote: () => {\n      dispatch(noteActions.addNote());\n    },\n    getNotes: () => {\n      dispatch(noteActions.getNotes());\n    },\n    toggleNote: ({ id, text }) => {\n      dispatch(noteActions.toggleNote({ id, text }));\n    },\n    updateNote: () => {\n      dispatch(noteActions.updateNote());\n    },\n    // 추가\n    deleteNote: ({ id }) => {\n      dispatch(noteActions.deleteNote({ id }));\n    }\n  };\n};\n```\n\n\n`NoteList.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteList.scss\";\nimport classNames from \"classnames/bind\";\nimport NoteItem from \"components/notes/NoteItem\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteList = ({\n  notes,\n  editing,\n  onToggle,\n  onChange,\n  onUpdate,\n  onDelete\n}) => {\n  const noteList = notes.map((note, i) => {\n    return (\n      <NoteItem\n        note={note}\n        key={note.id}\n        editing={editing}\n        onToggle={onToggle}\n        onChange={onChange}\n        onUpdate={onUpdate}\n        onDelete={onDelete}\n      />\n    );\n  });\n  return (\n    <div className={cx(\"note-list\")}>\n      <div className={cx(\"title\")}>Your Notes...</div>\n      {noteList}\n    </div>\n  );\n};\n\nexport default NoteList;\n\n```\n\n`NoteItem.js`\n\n```jsx\nimport React from \"react\";\nimport styles from \"./NoteItem.scss\";\nimport classNames from \"classnames/bind\";\n\nconst cx = classNames.bind(styles);\n\nconst NoteItem = ({\n  note,\n  editing,\n  onToggle,\n  onChange,\n  onUpdate,\n  onDelete\n}) => {\n  const handleToggle = () => {\n    onToggle({ id: note.id, text: note.text });\n  };\n\n  const handleChange = e => {\n    const { value } = e.target;\n    onChange({ value }, true);\n  };\n\n  const handleKeyPress = e => {\n    if (e.key === \"Enter\") {\n      onUpdate();\n    }\n  };\n\n  const handleDelete = e => {\n    // handleToggle이 되는것을 방지\n    e.stopPropagation();\n    onDelete({ id: note.id });\n  };\n  return (\n    <div\n      className={cx(\"note-item\", editing.id === note.id && \"editing\")}\n      onClick={handleToggle}\n    >\n      {editing.id === note.id ? (\n        <input\n          type=\"text\"\n          name=\"note\"\n          value={editing.text}\n          autoFocus\n          onChange={handleChange}\n          onKeyPress={handleKeyPress}\n        />\n      ) : (\n        <div className={cx(\"note\")}>{note.text}</div>\n      )}\n      <div className={cx(\"delete\")} onClick={handleDelete}>\n        &times;\n      </div>\n    </div>\n  );\n};\n\nexport default NoteItem;\n\n```\n\n이렇게 되면 삭제도 가능해집니다!\n\n다음에는 권한설정 및 무한 스크롤링 기능을 구현해보겠습니다.\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 4 - 6. React - 노트 리스트 구현 및 수정 / 삭제 기능 구현.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-23T10:04:35.022Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 2. React / Django 프로젝트 생성.":{"id":174,"title":"Dnote 2. React / Django 프로젝트 생성.","content":"> # 각 프로젝트 생성\n\n```bash\n# 프로젝트 워크스페이스로 이동해주세요.\n# 큰 집 안에 backend와 frontend가 있는 구조입니다.\n\n# 루트 폴더를 생성합니다.\n$ mkdir dnote\n$ cd dnote\n\n# React 프로젝트를 생성합니다.\n\n$ create-react-app frontend\n...\n...\n...\n# react 앱 생성 완료!\n\n# django 프로젝트가 위치할 디렉터리를 생성합니다.\n$ mkdir backend\n$ cd backend\n```\n\n> # Django - Virtual Env 생성\n\n```bash\n# 저는 python3를 쓰기 때문에 \n# 다음과 같이 virtual env를 생성해주겠습니다.\n# virtualenv 가 없다면 pip install virtualenv 로 설치 하여 주세요\n$ virtualenv --python=python3 venv\n\n# 마지막 venv는 virtual env 폴더의 이름이므로 \n# 원하는 이름으로 해주어도 무방합니다.\n```\n\n> # Django - Virtual Env 실행\n\n```bash\n# 장고 앱 개발에서는 항상 virtual env가 사용됩니다.\n# 따라서 개발시 제일 처음으로 venv를 실행해주세요!\n\n# mac\n$ source venv/bin/activate\n\n# windows\n$ venv\\Scripts\\activate.bat\n\n# venv환경에서 탈출하려면 deactivate 명령어를 치시면 됩니다.\n\n# venv가 액티베잇 되었으면 터미널 앞쪽에 (venv)가 붙게 됩니다.\n```\n\n> # django 설치 / project 생성\n\n```bash\n$ (venv) pip install django\n$ (venv) django-admin startproject dnote\n$ (venv) cd dnote\n$ (venv) ./manage.py migrate\n$ (venv) ./manage.py runserver\n```\nhttp://localhost:8000 으로 들어가시면 첫화면을 보시게 될 것 입니다.\n\n다음 글에서는 React 개발 환경 설정 및 구조를 잡아 보겠습니다. 또한 sass 및 redux등의 개발 기초작업을 해보겠습니다.\n\n\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 2. React / Django 프로젝트 생성.","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-20T13:30:40.361Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 3 - 1. React - 개발 환경 설정 및 구조 잡기.(sass 설정)":{"id":175,"title":"Dnote 3 - 1. React - 개발 환경 설정 및 구조 잡기.(sass 설정)","content":"자 이제 프로젝트를 모두 생성했으니, 리액트쪽부터 건들여 볼까요?\n\n```bash\n$ cd frontend\n# 저는 vscode를 쓰므로..\n$ code ./\n```\n> # eject 하기\n\nsass를 사용하려면 eject를 해서 설정파일들을 만져줘야 하므로 일단 eject부터 하겠습니다.\n\n\n```bash\n$ yarn eject\n....\n...\n...\n# eject completed.\n\n# 실행 전에 바로 eject하면 오류가 나므로 다시 모듈을 다운로드 해줍니다.\n\n$ yarn\n# 혹은 npm install\n# 저는 yarn을 쓰므로 앞으로는 yarn으로 진행하겠습니다.\n\n$ yarn start\n```\n첫화면이 잘 뜬다면 다음으로 넘어가겠습니다.\n\n> # sass 설정\n\n일단 css대신 scss를 쓰려면 다음 패키지들을 다운로드 해주세요.\n\n```bash\n$ yarn add --dev node-sass sass-loader\n```\n그리고 `config/paths.js` 로 이동해주세요.\n\n`config/paths.js`\n```js\n// config after eject: we're in ./config/\nmodule.exports = {\n  dotenv: resolveApp(\".env\"),\n  appBuild: resolveApp(\"build\"),\n  appPublic: resolveApp(\"public\"),\n  appHtml: resolveApp(\"public/index.html\"),\n  appIndexJs: resolveApp(\"src/index.js\"),\n  appPackageJson: resolveApp(\"package.json\"),\n  appSrc: resolveApp(\"src\"),\n  yarnLockFile: resolveApp(\"yarn.lock\"),\n  testsSetup: resolveApp(\"src/setupTests.js\"),\n  appNodeModules: resolveApp(\"node_modules\"),\n  publicUrl: getPublicUrl(resolveApp(\"package.json\")),\n  servedPath: getServedPath(resolveApp(\"package.json\")),\n  // 추가해줍니다.\n  styles: resolveApp(\"src/styles\")\n};\n```\n\n그런 다음 src밑에 styles폴더를 생성하여 주세요.\n\n그 후 `config/webpack.config.dev.js` 로 이동하여 주세요.\n\n`config/webpack.config.dev.js`\n```js\n{\n  test: /\\.css$/,\n  use: [\n    require.resolve(\"style-loader\"),\n    {\n      loader: require.resolve(\"css-loader\"),\n      options: {\n        importLoaders: 1\n      }\n    },\n    {\n      loader: require.resolve(\"postcss-loader\"),\n      options: {\n        // Necessary for external CSS imports to work\n        // https://github.com/facebookincubator/create-react-app/issues/2677\n        ident: \"postcss\",\n        plugins: () => [\n          require(\"postcss-flexbugs-fixes\"),\n          autoprefixer({\n            browsers: [\n              \">1%\",\n              \"last 4 versions\",\n              \"Firefox ESR\",\n              \"not ie < 9\" // React doesn't support IE8 anyway\n            ],\n            flexbox: \"no-2009\"\n          })\n        ]\n      }\n    }\n  ]\n},\n// \"file\" loader makes sure those assets get served by WebpackDevServer.\n```\n쭉 내리다보면 위와같은 부분이 있는데, 찾는 팁을 드리자면\nctrl + f 하고 .css로 찾은뒤 첫번째로 찾아지는 부분입니다.\n\n저 위 코드들을 쭉 복사하신후 바로 밑에 붙여넣기 해주세요.\n\n그 뒤에 다음과 같이 설정해줍니다.\n\n```bash\n{\n\t# css 를 scss로 바꿔줍니다.\n  test: /\\.scss$/,\n  use: [\n    require.resolve(\"style-loader\"),\n    {\n      loader: require.resolve(\"css-loader\"),\n      options: {\n        importLoaders: 1\n      }\n    },\n    {\n      loader: require.resolve(\"postcss-loader\"),\n      options: {\n        // Necessary for external CSS imports to work\n        // https://github.com/facebookincubator/create-react-app/issues/2677\n        ident: \"postcss\",\n        plugins: () => [\n          require(\"postcss-flexbugs-fixes\"),\n          autoprefixer({\n            browsers: [\n              \">1%\",\n              \"last 4 versions\",\n              \"Firefox ESR\",\n              \"not ie < 9\" // React doesn't support IE8 anyway\n            ],\n            flexbox: \"no-2009\"\n          })\n        ]\n      }\n    },\n    # 추가해줍니다.\n    {\n      loader: require.resolve(\"sass-loader\"),\n      options: {\n        includePaths: [paths.styles]\n      }\n    }\n  ]\n},\n```\n\n`config/webpack.config.prod.js`로 이동해줍니다.\n\n`config/webpack.config.prod.js`\n\n```js\n// 여기서도 .css 를 찾은뒤 밑으로 똑같이 복사해줍니다.\n\n{\n  // css -> scss\n  test: /\\.scss$/,\n  loader: ExtractTextPlugin.extract(\n    Object.assign(\n      {\n        fallback: {\n          loader: require.resolve('style-loader'),\n          options: {\n            hmr: false,\n          },\n        },\n        use: [\n          {\n            loader: require.resolve('css-loader'),\n            options: {\n              importLoaders: 1,\n              minimize: true,\n              sourceMap: shouldUseSourceMap,\n            },\n          },\n          {\n            loader: require.resolve('postcss-loader'),\n            options: {\n              // Necessary for external CSS imports to work\n              // https://github.com/facebookincubator/create-react-app/issues/2677\n              ident: 'postcss',\n              plugins: () => [\n                require('postcss-flexbugs-fixes'),\n                autoprefixer({\n                  browsers: [\n                    '>1%',\n                    'last 4 versions',\n                    'Firefox ESR',\n                    'not ie < 9', // React doesn't support IE8 anyway\n                  ],\n                  flexbox: 'no-2009',\n                }),\n              ],\n            },\n          },\n          // 추가해줍니다.\n          {\n            loader: require.resolve(\"sass-loader\"),\n            options: {\n              includePaths: [paths.styles]\n            }\n          }\n        ],\n      },\n      extractTextPluginOptions\n    )\n  ),\n  // Note: this won't work without `new ExtractTextPlugin()` in `plugins`.\n},\n```\n\n자 이제 sass에 대한 환경 설정은 모두 끝났습니다.\n\n\n\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 3 - 1. React - 개발 환경 설정 및 구조 잡기.(sass 설정)","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-20T13:46:27.088Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"개발에 대한 피로도를 푸는 나의 방법? 및 요즘 드는 생각들..":{"id":176,"title":"개발에 대한 피로도를 푸는 나의 방법? 및 요즘 드는 생각들..","content":"> 벨로그가 오래 살아남았으면 하는 바람으로 올려보는 글.\n\n개발을 하다보면 여러가지 피로도에 휩싸이게 된다.\n\n일단 처음에 시작한 작업들이 흐지부지 하게 되거나, 내가 할 수 있었던것 같았던 작업들이 장벽에 부딪혔을때 등등 여러가지 요인들에 의해 작업 피로도들이 점점 나타나기 시작한다.\n\n개발자를 업으로 삼는 사람들에게는 이 조그마한 피로도들이 쌓이기 시작하면 나비효과로 번지게 된다.\n\n나의 경우는 학생이므로, 큰 규모의 개발을 하지도 않고, 개발이라고 해봤자, 내가하는 사이드 프로젝트들이 대부분인데, 간혹 학교에서 시험이 있다거나 프로젝트 과제가 있다거나 해서 하던 사이드 프로젝트들이 우선순위에서 밀리게 되므로써 흐지부지하게 되는 경우가 있을때 피로도들이 쌓이는 것 같다.\n\n이럴때 나의 경우는 그냥 하던 프로젝트들은 어차피 진행할 것이므로, 크게 미련을 두지않고, 그 상황에 내가 해보고 싶었던 공부나 무언가 신선한 충격을 주는 아티클 들에 대해 살펴보는 것으로 풀기도 한다.\n\n개발해야지 라는 수렁텅이에 빠진 뇌에 조금은 프레시한 공기를 넣어준달까...\n\n오늘은 추석 연휴가 시작되는 (나에게는) 날이다. 월화수만 학교를 나가는 나에게는 오늘 밤부터 연휴 시작인것이다.\n\n딱히 알바도 하지않고, 어디에 치이지 않아서 좋지만, 나름 이런 여유가 나는 시기를 그냥 보낼수는 없다고 생각한다.\n\n항상 나를 채찍질 하지만, 뭐 그렇다고 너무 사명감을 가지고 열심히 하는것도 아니라 평소에 시간이 있어도 둘러보지 않았던 것들에 대해 둘러보려고한다.\n\n예를들면, serverless 라던지?.. go lang이라던지... tensorflow라던지... blockchain 이라던지.. \n\n뭐 이것들 중에서 하나라도 둘러보기만 하더라도, 혹은 약간 맛보기만 하더라도 나중에 분명 도움이 될거라고 생각한다.\n\n요즘 학교에 다니는 것에 대해서도 많은 회의감을 느낀다. 애초에 전문대 일뿐더러, 원래 2년제에서 3년제로 작년에 전환 했기에 이 마지막 학기가 참 나에게는 무겁기도 하고, 왜 3년제 전환했나 싶기도 하다. 근데 뭐 그 상황의 나에게는 최선의 선택을 했다고 생각하기에 크나큰 후회는 하지 않고, 어차피 후회해봤자 나에게 도움이 되는것은 없기 때문에 내가 하고싶고, 내가 열정을 가지고 있는 개발쪽에 시간을 더 투자하고 싶은 마음이고, 그러고 있는것 같다.\n\n뭐 이런 문제들이 남들이 해결해 주는것도 아니라고 생각하고, 내가 제일 고민을 많이 털어놓는 부모님에게 약간의 상담을 받는 정도이다.\n\n결국 살아가다 보면, 내가 열심히 하다보면, 딱히 별것 아닌 문제들이고 오히려 내가 배부른 고민을 하는게 아닌가 싶다.\n\n어차피 한 학기 남았으니까.... 마지막까지 열심히(?) 다닐지는 모르겠지만 나에게 누를 끼쳐서는 안된다고 생각한다.\n\n맘잡고 개발한지 1년반정도? 된것 같다. 뭐 학생때 파란만장하게 놀았기 때문에 전문대에 오게된것이고, 모든게 나의 노력 부족에 대한 결과물일 뿐더러, 오히려 지금이라도 맘잡고 하는게 나는 나에게 대견스럽다. \n\n개발.. 뭐 참 아리까리 하지만 지금은 나름대로 내 개발을 즐기고 있다. 더도 덜도 아니다. 그냥 개발이 좋아지기 시작했고, 앞으로도 그럴것 같다.\n\n뭐 여러 한국의 좋은 개발자들을 보면 대부분 어릴때 (학생 시절) 부터 개발에 관심을 가진것 같다. 개발은 결국 실력이기에 몇년간의 갭 차이를 내가 바로 줄이기는 어렵겠지만.. 뭐 1년반만에 뭔가 그냥 주도적으로 개발에 많이 재미를 붙인것 자체가 타고난 개발자가 아닌 나에게는 큰 결과물이라고 생각한다.\n\n이번 여름방학때 모 기업에 지원을 했고, 나름 사람이 많이 급했던지, 주니어 개발자인 나를 시니어 개발자를 모집하는 곳에 합격시켰다. 나는 아직 학생 신분이어서 조기취업을 선택해야 했다. 여러 고민끝에 입사를 포기하게 되었다.\n\n그 당시에는 많은 아쉬움과 안타까움이 나에게 많았다. 입사를 포기한 이유가 학생 신분이라는 것에 국한되는것 이었기 때문이다. 내가 조기취업 한다면 할수 있었지만, 담당 교수님과 주변 여러 의견들에 대다수가 굳이 한 학기 남기고 위험하게 졸업 취소될수 있는 조기취업에 반대 하는 입장이었다. 결국 선택은 내가 했던 것이기에 남을 탓하는것은 절대 아니다.\n\n뭐 그러나 결국 최종 목표가 취업이었고, 학교 다니는것도 지긋지긋 했기 때문에 조기취업을 하고자 마음먹고 방학에 들어섰으나, 결국 입사를 포기한 내가 무언가 바보같기도 했지만 나름 잘이겨내고 있다.\n\n그래서 차 방안으로 요즘 대기업에 원서를 넣어보았다. 처음에 네이버 인턴 모바일 앱개발에 넣었는데, 서류에서 낙방했다. 그래서 신입 공채로 frontend개발쪽으로 넣었다. 결과는 아직 나오지 않았고, 딱히 많은 기대는 하지 않는다. 뭐 대기업이니까, 서류 합격한다고 해도 코딩 시험이 남아있고 내 주어진 상황에 최선을 다할 뿐이다.\n\n그냥 뭐 이때까지 이런저런 얘기를 했는데, 결론은 그렇다.\n\n나같은 학교는 재미없고, 그렇다고 취업할수도 없고, 이러한 상황, 즉 무언가 마음대로 안되는 상황에서 개발을 한다는것 자체가 피로도가 쌓인다. 처음에는 그냥 내 마음을 돌볼 결흘이 없었기에, 무작정 닥치는대로 코딩만 했는데, 요즘에 책도 보고 하다보니 내 마음을 다스리는게 코딩을 좀더 효율적으로 할수 있게 도와주더라는것을 깨닫게 되었다.\n\n이러한 나와 비슷한 상황에서는 코딩에 대한 피로도가 쌓이는데, 이 피로도는 단순히 문제가 해결되지 않는다는 것에서 비롯된 피로도라기 보다는.. 내 주어진 상황에서 나는 이걸 하고 싶은데, 시간이 없다거나 우선순위에서 밀려난다거나 해서 흐지부지하게 되어 나타나는 피로도를 말한다.\n\n근육 뭉칠때는 운동으로 풀듯이 그냥 뭔가 신선한 충격을 주는 개발 공부에 관심을 가지면 자연스레 풀리는것같다.\n\n그러다보면 내가 원래 시작했던 프로젝트들에도 자연스레 손이가게 되고 귀찮지만 다시 시작 하게된다.\n시작하다보면 끝을 볼수 있겠지.\n\n다시 뭐 내 이야기로 돌아가면, 또한 생각정리를 해보자면, 지나간 여러 일들이 눈에 거슬리지 않을수는 없다고 생각한다. 뭐 나름 충격이었던 경험들도 포함되있고, 사람이란게 잊고싶은 기억도 바로 잊혀지지는 않으니까..\n\n이런 상황에서 내 마음을 털어놓을수 있는 부모님과 여자친구가 있다는 것에 매우 감사한다.\n\n이런 나에게 장애물들이 되는 여러 상황들을 잊으려고 노력하고, 미래를 보는것이 나에게는 최선이라고 생각하고, 끊임없이 다시 나를 채찍질 해야겠다.\n\n\n> 원글 : https://killi8n.com/post/5ba23767b17fd60398c3da3e\n\n\n","thumbnail":"Velog.png","excerpt":"개발에 대한 피로도를 푸는 나의 방법? 및 요즘 드는 생각들..","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-19T13:55:24.694Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Dnote 1. 소개":{"id":177,"title":"Dnote 1. 소개","content":"안녕하세요? 딱히 제가 만든 프로젝트가 대단한 것은 아니지만, 장고와 리액트로 작업을 할때 저는 처음에 삽질을 많이 했는데요, 이러한 삽질을 하며 만들어본 경험을 바탕으로 리액트와 장고로 한줄 노트앱을 만드는 과정을 공유하고자 해서 튜토리얼을 써보게 되었습니다.\n\nhttps://velog.io/@killi8n/Django-React-%EB%A1%9C-%EC%B2%AB-%ED%99%94%EB%A9%B4-%EB%9D%84%EC%9B%8C%EB%B3%B4%EA%B8%B0-55jm970olw\n\n위 링크에 들어가시면 지난 튜토리얼을 보실수 있습니다.\n\n\n사실, 이번 튜토리얼은 지난 번에 썻던 Django와 React를 이용해서 첫 화면 띄워보기에 이어지는 튜토리얼 입니다. 본 아이디어는 지난 글에도 썼듯이 http://v1k45.com 에 나오는 튜토리얼입니다.\n\n아이디어와 많은 정보들을 위 블로그에서 얻었음을 알리며, 이 튜토리얼에서는 원글을 완전히 똑같이 따라하진 않았으며, 원래 글에는 구현되있지않은 무한스크롤링도 나름 구현해 보았으니 관심이 있으신분들은 나름 도움이 되리라고 생각하며, 글을 쓰도록 하겠습니다.\n\n이번에는 장고 서버로 리액트를 띄우는 과정을 가장 마지막에 해보도록 하고, 일단 React Dev모드에서 Backend(Django)와 통신하고, 모든 기능들을 추가 시킨 후 build하여 8000번에 띄워보도록 해보겠습니다!\n\nRedux를 사용할 예정인데, Redux는 rxjs를 활용한 redux-observable을 API통신에만 사용하여 구현해볼 예정입니다!\n(나머지 상태관리는 redux를 통해 이루어지지만, rxjs를 이용하지는 않았습니다.)\n\n> # 개요\n1. [소개](http://www.google.co.kr)\n2. [React / Django 프로젝트 생성](https://killi8n.com/post/5ba3ab51b17fd60398c3da40)\n3. \n\t1. [React - 개발 환경 설정 및 구조 잡기.(sass 설정)](https://killi8n.com/post/5ba3ab6eb17fd60398c3da41)\n    2. [React - 개발 환경 설정 및 구조 잡기.(프로젝트 구조잡기)](https://killi8n.com/post/5ba47cdcb17fd60398c3da42)\n    3. [React - 개발 환경 설정 및 구조 잡기. (Redux 설정하기)](https://killi8n.com/post/5ba48178b17fd60398c3da43)\n4. \n\t1. [Django - CRUD API 작업](https://killi8n.com/post/5ba4e776b17fd60398c3da44)\n    2. [React - 페이지 구조 생성](https://killi8n.com/post/5ba4ee30b17fd60398c3da45)\n    3. [React - 입력 폼 만들고 상태 관리](https://killi8n.com/post/5ba4f258b17fd60398c3da46)\n    4. [React - 노트 생성 기능 구현](https://killi8n.com/post/5ba4f70fb17fd60398c3da47)\n    5. [React - 노트 생성 시 에러 처리](https://killi8n.com/post/5ba4fb13b17fd60398c3da48)\n    6. [React - 노트 리스트 구현 및 수정 / 삭제 기능 구현](https://killi8n.com/post/5ba65f62be54be359e528453)\n5. \n\t1. [Django - 권한 설정 및 로그인 / 회원가입 구현](https://killi8n.com/post/5ba66554be54be359e528454)\n    2. [React - 로그인 및 회원가입 기능 구현](https://killi8n.com/post/5ba67282be54be359e528456)\n    3. [React - 로그인 유지 및 로그아웃 기능 구현](https://killi8n.com/post/5ba7366cbe54be359e528457)\n6. \n\t1. [React - 무한 스크롤링 기능 구현](https://killi8n.com/post/5ba7384bbe54be359e528458)\n7. [React - 404페이지 완성 밑 빌드된 리액트 띄우기](https://killi8n.com/post/5ba759e8be54be359e528459)\n\n# Github Repo\n## https://github.com/yungblud/d-note\n\n> # 프로젝트 미리보기\n\n일단 무엇을 하려는지는 알아야겠죠??\n\ninput태그를 이용하여 직관적으로 한줄 노트를 작성할수 있는 앱이며, 스크린샷을 첨부하도록 하겠습니다.\n\n## 그냥 화면..\n\n![Imgur](https://i.imgur.com/yusIEhg.png)\n\n## 무한 스크롤링 화면..\n\n\n![Imgur](https://i.imgur.com/plSZf0y.png)\n\n\n## 클릭하여 수정하기 화면..\n\n\n![Imgur](https://i.imgur.com/DpUiPv5.png)\n\n> ## 로그인 / 회원가입 화면..\n\n![Imgur](https://i.imgur.com/JvbJJwE.png)\n\n\n![Imgur](https://i.imgur.com/fBLLxz1.png)\n\n그렇다면 이제 본격적으로 코딩을 해볼까요?\n\n다음글에서 계속됩니다...\n\n\n\n","thumbnail":"Velog.png","excerpt":"Dnote 1. 소개","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-20T13:02:16.300Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]},"Django + React 로 첫 화면 띄워보기":{"id":178,"title":"Django + React 로 첫 화면 띄워보기","content":"> 이곳에 쓰인 모든 글은 http://v1k45.com/blog 의 http://v1k45.com/blog/modern-django-part-1-setting-up-django-and-react/ 에 쓰여진 대로 진행함을 알립니다.\n\n> 또한 이 글의 원본은 https://killi8n.com 에 있음을 알립니다! (블로그 홍보는 안 \n비밀...)\n\n이번에 올릴 글은 장고와 리액트로 dev 모드와 production 모드로 화면 띄워보기 입니다. 일단 구조는 Root 앱 밑에 Frontend(React) , Backend(Django) 두 폴더가 있는 구조 입니다.\n\n# 프로젝트 생성 하기\n\n```bash\nmkdir Deact\n# make react project directory from cra\ncreate-react-app deact-frontend\n\n# django project\nmkdir deact-backend\n\ncd deact-backend\n\n# make virtual env\nvirtualenv --python=python3 venv\n\n# activate virtual env\nsource venv/bin/activate\n\n# install django\npip install django\n\ndjango-admin startproject deact\n\ncd deact\npython manage.py migrate\npython manage.py runserver\n\n```\n\n자 그리고 이제 react directory로 와서 eject를 시켜주세요.\n\n```bash\nyarn eject\n```\n\n# React와 Django 통합하기\n\n다시 django 디렉토리로 와서 다음 명령어로 인스톨 해줍니다.\n\n```bash\npip install django-webpack-loader\n```\n\n그 다음에 settings.py에서 INSTALLED_APPS 에 'webpack_loader'를 추가해줍니다. 그리고 webpack_loader에 관한 설정과 저희의 리액트 앱을 보여줄 template에 관한 설정도 추가해줍니다.\n\n> settings.py\n\n```python\n...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'webpack_loader',\n]\n\n...\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, \"templates\"),],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n\n...\n\nWEBPACK_LOADER = {\n    'DEFAULT': {\n            'BUNDLE_DIR_NAME': 'bundles/',\n            'STATS_FILE': os.path.join(BASE_DIR, 'webpack-stats.dev.json'),\n        }\n}\n\n```\n\n그리고 templates 디렉토리를 장고 프로젝트의 Root디렉토리 밑에 만든후, index.html을 추가합니다.\n\n> templates/index.html\n\n```html\n{% load render_bundle from webpack_loader %}\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Deact</title>\n</head>\n\n<body>\n    <div id=\"root\">\n    </div>\n    {% render_bundle 'main' %}\n</body>\n\n</html>\n```\n\n그리고 urls.py에 해당 템플릿 뷰를 라우팅 해줍니다.\n\n> urls.py\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.views.generic import TemplateView\n\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', TemplateView.as_view(template_name=\"index.html\")),\n]\n\n```\n\n\n이제 localhost:8000 으로 접속하면, 다음과 같이 오류가 날것입니다!\n리액트 프로젝트에서 webpack loader설정을 안해서 나는 당연한 오류입니다.\n\n![Imgur](https://i.imgur.com/CMeIfq5.png)\n\n이제 리액트로 넘어와서 다시 설정을 해줘야 합니다.\n\n\n```bash\n# webpack bundle tracker 설치\nyarn add --dev webpack-bundle-tracker\n```\n\n> config/path.js\n\n```js\nmodule.exports = {\n  dotenv: resolveApp(\".env\"),\n  appBuild: resolveApp(\"build\"),\n  appPublic: resolveApp(\"public\"),\n  appHtml: resolveApp(\"public/index.html\"),\n  appIndexJs: resolveApp(\"src/index.js\"),\n  appPackageJson: resolveApp(\"package.json\"),\n  appSrc: resolveApp(\"src\"),\n  yarnLockFile: resolveApp(\"yarn.lock\"),\n  testsSetup: resolveApp(\"src/setupTests.js\"),\n  appNodeModules: resolveApp(\"node_modules\"),\n  publicUrl: getPublicUrl(resolveApp(\"package.json\")),\n  servedPath: getServedPath(resolveApp(\"package.json\")),\n  // 추가 해줍니다.\n  statsRoot: resolveApp(\"../deact-backend/deact\")\n};\n```\n\n> config/webpack.config.dev.js\n\n```js\n// bundleTracker를 import 해 줍니다.\nconst BundleTracker = require('webpack-bundle-tracker');\n// publicPath와 publicUrl을 다음과 같이 변경해줍니다.\nconst publicPath = 'http://localhost:3000/';\nconst publicUrl = 'http://localhost:3000/';\n\n// entry 부분을 아래와 같이 변경해줍니다.\nentry: [\n    require.resolve(\"./polyfills\"),\n    require.resolve(\"webpack-dev-server/client\") + \"?http://localhost:3000\",\n    require.resolve(\"webpack/hot/dev-server\"),\n    require.resolve(\"react-dev-utils/webpackHotDevClient\"),\n    paths.appIndexJs\n],\n  \n// 가장 아래의 plugins 쪽에 다음을 추가해줍니다. \nplugins: [\n\t...\n  \tnew BundleTracker({path: paths.statsRoot, filename: 'webpack-stats.dev.json'}),\n]\n\n```\n\n\n\n> config/webpackDevServer.config.js\n\n```js\n// host 밑에 다음을 추가해줍니다.\nhost: host,\nheaders: {\n  'Access-Control-Allow-Origin': '*'\n},\n```\n\n자 이제 다시 yarn start로 시작 한후, localhost:8000으로 접속하면 첫 화면이 뜰것입니다.\n\n여기까지 Dev모드의 React를 띄우는 것을 알아 보았는데요, 그럼 이번에는 build된 React를 띄우는 Prod 모드를 알아봅시다.\n\n루트 프로젝트 아래의 deact 앱 아래에 production_settings.py를 다음과 같이 생성해줍니다.\n\n> deact/deact/production_settings.py\n\n```python \nfrom .settings import *\n\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, \"assets\"),\n]\n\nWEBPACK_LOADER = {\n    'DEFAULT': {\n            'BUNDLE_DIR_NAME': 'bundles/',\n            'STATS_FILE': os.path.join(BASE_DIR, 'webpack-stats.prod.json'),\n        }\n}\n```\n그 다음에 templates 디렉토리와 같은 위치에 assets/bundles 디렉토리를 차례로 생성해줍니다. 나중에 리액트앱이 빌드 될때 파일이 이곳으로 모이게 됩니다.\n\n그리고 다시 리액트의 config/paths.js 에서 appBuild를 아까 만든 assets/bundles 경로로 설정해줍니다.\n\n> config/paths.js\n\n```js\nmodule.exports = {\n  dotenv: resolveApp(\".env\"),\n  // 변경 할 부분입니다. \n  appBuild: resolveApp(\"../deact-backend/deact/assets/bundles\"),\n  appPublic: resolveApp(\"public\"),\n  appHtml: resolveApp(\"public/index.html\"),\n  appIndexJs: resolveApp(\"src/index.js\"),\n  appPackageJson: resolveApp(\"package.json\"),\n  appSrc: resolveApp(\"src\"),\n  yarnLockFile: resolveApp(\"yarn.lock\"),\n  testsSetup: resolveApp(\"src/setupTests.js\"),\n  appNodeModules: resolveApp(\"node_modules\"),\n  publicUrl: getPublicUrl(resolveApp(\"package.json\")),\n  servedPath: getServedPath(resolveApp(\"package.json\")),\n  statsRoot: resolveApp(\"../deact-backend/deact\")\n};\n\n```\n\n그리고 config/webpack.config.prod.js 에서 다음과 같은 작업들을 해야합니다.\n\n> config/webpack.config.prod.js\n\n```js\n// Bundle Tracker를  import해줍니다(상단)\nconst BundleTracker = require('webpack-bundle-tracker');\n\n// 기존의 publicPath를 다음과 같이 바꿔줍니다.\nconst publicPath = \"/static/bundles/\";\n// 기존의 cssFilename을 다음과 같이 변경해줍니다. (앞의 static/ 을 없애줍니다.)\nconst cssFilename = 'css/[name].[contenthash:8].css';\n\n// 약 67 번째 라인에 있는 경로도 모두 static을 제거 해줍니다.\n...\noutput: {\n  ...\n  \n  filename: \"js/[name].[chunkhash:8].js\",\n  chunkFilename: \"js/[name].[chunkhash:8].chunk.js\",\n  \n  ...\n}\n  \n// 약 140번째 라인의 경로도 static을 제거해줍니다.\n  \n{\n    test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/],\n    loader: require.resolve(\"url-loader\"),\n    options: {\n      limit: 10000,\n      name: \"media/[name].[hash:8].[ext]\"\n    }\n},\n  \n  \n// 약 223번째 라인의 경로도 static을 제거해줍니다.\n  \noptions: {\n      name: \"media/[name].[hash:8].[ext]\"\n}\n  \n// 마지막 plugins 에 다음을 추가해줍니다.\n  \nplugins: [\n\t...\n  \tnew BundleTracker({\n      path: paths.statsRoot,\n      filename: \"webpack-stats.prod.json\"\n    })\t\n  \t...\n]\n...\n```\n쉽게 설명을 해드리면 ctrl + f 로 static을 검색하신후, 경로로 잡히는 모든것을 삭제해 주시면 됩니다. 그 후 plugins 에 bundleTracker관련 코드를 추가해 줍니다.\n\n그리고 리액트 쪽에서 build를 해줍니다.\n```bash\nyarn build\n```\n\n그 후 장고 쪽에서 다음과 같은 명령어로 production 모드를 띄워줍니다.\n\n```bash\npython manage.py runserver --settings=deact.production_settings\n```\n\n잘 뜨나요? \n여기 까지 되셨다면 production도 띄울수 있게 된것입니다!\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"Velog.png","excerpt":"Django + React 로 첫 화면 띄워보기","blogArticleCategoryId":3,"isPublic":true,"createdAt":"2018-09-19T13:38:34.013Z","deletedAt":null,"blogArticleCategory":{"name":"velog"},"blogArticleTags":[]}},"categories":["etc","dev","velog","univ","life"],"tags":["tree shaking","트리 쉐이킹","patterns.dev","rust","render pattern","rendering pattern","web assembly","client side rendering","wasm","static rendering","server side rendering","ssr"]}